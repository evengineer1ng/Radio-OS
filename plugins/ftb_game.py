"""
From the Backmarker - Racing Management Simulation Game Plugin

ONE comprehensive plugin containing:
- Entity system with full stat models (Driver ~26, Engineer ~24, etc.)
- Event system
- Economic system  
- Simulation engine (pure computation, NO LLM)
- Job board
- UI widget
- Feed worker (converts sim events to audio candidates)

Design principles:
- Simulation is pure math (no LLM calls)
- Money is the only constraint
- Time × Results × Role governs standing metrics
- No player stats, no archetypes
- ZenGM-style depth through multi-dimensional ratings
"""

from dataclasses import dataclass, field
from typing import Any, Dict, List, Optional, Set, Tuple, Union
from abc import ABC, abstractmethod
import random
import time
import json
import os
import uuid
import threading
import queue
import tkinter as tk
from tkinter import ttk, simpledialog, messagebox
from enum import Enum
from PIL import Image, ImageDraw
import numpy as np

# ── Debug gate ──────────────────────────────────────────────
# Set to True (or set env var FTB_DEBUG=1) to re-enable verbose prints.
FTB_DEBUG: bool = os.environ.get("FTB_DEBUG", "").strip() in ("1", "true", "yes")

def _dbg(*args, **kwargs):
    """Guarded print — only emits output when FTB_DEBUG is enabled."""
    if FTB_DEBUG:
        print(*args, **kwargs)
# ────────────────────────────────────────────────────────────


def _coerce_float(value: Any, default: Optional[float] = 0.0) -> Optional[float]:
    """Coerce a value to float with a safe fallback."""
    if isinstance(value, (int, float)):
        return float(value)
    if isinstance(value, dict):
        for key in ("value", "rating", "score"):
            if key in value:
                try:
                    return float(value[key])
                except (TypeError, ValueError):
                    break
    try:
        return float(value)
    except (TypeError, ValueError):
        return default

# Import name generation system
try:
    from plugins.ftb_names import generate_name, generate_team_name, generate_sponsor_name, generate_league_name
except ImportError:
    _dbg("[FTB] Warning: Could not import ftb_names")
    generate_name = None
    generate_team_name = None
    generate_sponsor_name = None
    generate_league_name = None

# Import sponsor generation system
try:
    from plugins import ftb_sponsors
except ImportError:
    _dbg("[FTB] Warning: Could not import ftb_sponsors")
    ftb_sponsors = None

# Import state database for narrator/delegate interface
try:
    from plugins import ftb_state_db
except ImportError:
    _dbg("[FTB] Warning: Could not import ftb_state_db")
    ftb_state_db = None

# Import race day management system
try:
    from plugins import ftb_race_day
except ImportError:
    _dbg("[FTB] Warning: Could not import ftb_race_day")
    ftb_race_day = None

# Import broadcast commentary generator
try:
    from plugins import ftb_broadcast_commentary
except ImportError:
    _dbg("[FTB] Warning: Could not import ftb_broadcast_commentary")
    ftb_broadcast_commentary = None

# Import customtkinter for UI widgets (optional for headless mode)
try:
    import customtkinter as ctk
except ImportError:
    _dbg("[FTB] Warning: Could not import customtkinter - UI widgets disabled")
    ctk = None

# ============================================================
# PLUGIN METADATA
# ============================================================

IS_FEED = False  # This is a widget-only plugin, not a feed
PLUGIN_NAME = "FTB Game"
PLUGIN_DESC = "From the Backmarker racing management simulation game"

# ============================================================
# CONSTANTS
# ============================================================

# Tier display names mapping
TIER_DISPLAY_NAMES = {
    1: "grassroots",
    2: "formula_v",
    3: "formula_x",
    4: "formula_y",
    5: "formula_z"
}

# Tier-specific feature gates (Phase 3)
TIER_FEATURES = {
    1: {  # Grassroots
        'max_drivers': 2,
        'max_engineers': 1,
        'max_mechanics': 2,
        'can_hire_strategist': False,
        'can_purchase_parts': True,
        'can_rd_projects': False,
        'can_manufacturer_contracts': False,
        'upgrade_packages_available': [],
        'max_car_development_cost': 25000,
    },
    2: {  # Formula V
        'max_drivers': 2,
        'max_engineers': 3,
        'max_mechanics': 3,
        'can_hire_strategist': True,
        'can_purchase_parts': True,
        'can_rd_projects': False,
        'can_manufacturer_contracts': True,
        'upgrade_packages_available': ['basic_aero', 'basic_engine'],
        'max_car_development_cost': 75000,
    },
    3: {  # Formula X
        'max_drivers': 2,
        'max_engineers': 5,
        'max_mechanics': 4,
        'can_hire_strategist': True,
        'can_purchase_parts': True,
        'can_rd_projects': False,
        'can_manufacturer_contracts': True,
        'upgrade_packages_available': ['basic_aero', 'basic_engine', 'advanced_suspension'],
        'max_car_development_cost': 200000,
    },
    4: {  # Formula Y
        'max_drivers': 2,
        'max_engineers': 8,
        'max_mechanics': 6,
        'can_hire_strategist': True,
        'can_purchase_parts': True,
        'can_rd_projects': True,
        'can_manufacturer_contracts': True,
        'upgrade_packages_available': ['basic_aero', 'basic_engine', 'advanced_suspension', 'advanced_aero', 'power_unit_upgrade'],
        'max_car_development_cost': 500000,
    },
    5: {  # Formula Z
        'max_drivers': 2,
        'max_engineers': 15,
        'max_mechanics': 10,
        'can_hire_strategist': True,
        'can_purchase_parts': True,
        'can_rd_projects': True,
        'can_manufacturer_contracts': True,
        'upgrade_packages_available': ['basic_aero', 'basic_engine', 'advanced_suspension', 'advanced_aero', 'power_unit_upgrade', 'complete_replatform'],
        'max_car_development_cost': 2000000,
    }
}

# Penalty Configuration - Tier-based strictness (Formula Z strictest → Grassroots most lenient)
PENALTY_CONFIG = {
    1: {  # Grassroots - Most forgiving
        'name': 'Grassroots',
        'crash_investigation_rate': 0.15,  # Only 15% of crashes investigated
        'track_limits_threshold': 10,  # 10+ violations to trigger penalty
        'warning_before_penalty_rate': 0.85,  # 85% chance of warning first
        'fine_multiplier': 0.3,  # Lower fines
        'grid_penalty_range': (1, 3),  # 1-3 grid positions
        'points_deduction_enabled': False,
        'base_fine_amounts': {
            'causing_collision': 1000,
            'track_limits': 500,
            'unsafe_release': 750,
            'brake_test': 1500
        }
    },
    2: {  # Formula V - More lenient
        'name': 'Formula V',
        'crash_investigation_rate': 0.30,
        'track_limits_threshold': 7,
        'warning_before_penalty_rate': 0.70,
        'fine_multiplier': 0.5,
        'grid_penalty_range': (1, 5),
        'points_deduction_enabled': False,
        'base_fine_amounts': {
            'causing_collision': 2500,
            'track_limits': 1000,
            'unsafe_release': 1500,
            'brake_test': 3000
        }
    },
    3: {  # Formula X - Balanced
        'name': 'Formula X',
        'crash_investigation_rate': 0.50,
        'track_limits_threshold': 5,
        'warning_before_penalty_rate': 0.50,
        'fine_multiplier': 0.7,
        'grid_penalty_range': (1, 5),
        'points_deduction_enabled': False,
        'base_fine_amounts': {
            'causing_collision': 5000,
            'track_limits': 2000,
            'unsafe_release': 3000,
            'brake_test': 7500
        }
    },
    4: {  # Formula Y - Strict
        'name': 'Formula Y',
        'crash_investigation_rate': 0.70,
        'track_limits_threshold': 3,
        'warning_before_penalty_rate': 0.30,
        'fine_multiplier': 1.0,
        'grid_penalty_range': (3, 10),
        'points_deduction_enabled': True,
        'points_deduction_threshold': 3,  # 3 penalties in 90 days = points deduction
        'base_fine_amounts': {
            'causing_collision': 15000,
            'track_limits': 5000,
            'unsafe_release': 10000,
            'brake_test': 25000,
            'dangerous_driving': 30000
        }
    },
    5: {  # Formula Z - Strictest
        'name': 'Formula Z',
        'crash_investigation_rate': 0.90,
        'track_limits_threshold': 3,
        'warning_before_penalty_rate': 0.10,  # Rarely get warnings
        'fine_multiplier': 1.5,
        'grid_penalty_range': (5, 15),
        'points_deduction_enabled': True,
        'points_deduction_threshold': 2,  # 2 penalties in 90 days = points loss
        'base_fine_amounts': {
            'causing_collision': 50000,
            'track_limits': 15000,
            'unsafe_release': 25000,
            'brake_test': 75000,
            'dangerous_driving': 100000,
            'unsportsmanlike_conduct': 60000
        }
    }
}

# Morale System Configuration (Phase 1 - Stabilization)
MORALE_CONFIG = {
    'daily_reversion_factor': 0.03,      # 3% daily pull toward baseline (was 8% - too aggressive)
    'baseline_range': (40.0, 60.0),      # Min/max personality baselines
    'diminishing_returns_threshold': 20,  # Distance from 50 before diminishing returns
    'extreme_morale_cap': 0.2,           # Max 20% effectiveness at extremes (>40 from 50)
    'dnf_base_penalty': -15.0,           # Base morale loss for DNF
    'max_single_change': 20.0,           # Maximum morale change in single event
    'reversion_enabled': True,           # Enable mean reversion system
}

# R&D Project Catalog (Phase 4) - Available to Tier 4+ only
RD_PROJECT_CATALOG = {
    # Aero development projects
    'rd_aero_efficiency': {
        'name': 'Aero Efficiency Study',
        'type': 'car_upgrade',
        'cost': 250000,
        'duration_ticks': 20,  # ~3 weeks
        'base_success_rate': 0.75,
        'target_stat': 'aero_efficiency',
        'target_improvement': 8.0,
        'description': 'Wind tunnel study to optimize aero efficiency',
        'risk_level': 'medium',
        'min_tier': 4
    },
    'rd_downforce_peak': {
        'name': 'Downforce Optimization',
        'type': 'car_upgrade',
        'cost': 300000,
        'duration_ticks': 24,
        'base_success_rate': 0.70,
        'target_stat': 'downforce_peak',
        'target_improvement': 10.0,
        'description': 'Maximize downforce generation without drag penalty',
        'risk_level': 'high',
        'min_tier': 4
    },
    'rd_drag_reduction': {
        'name': 'Drag Reduction Program',
        'type': 'car_upgrade',
        'cost': 200000,
        'duration_ticks': 18,
        'base_success_rate': 0.80,
        'target_stat': 'drag',
        'target_improvement': -6.0,  # Negative = reduce drag
        'description': 'Reduce aerodynamic drag for higher top speeds',
        'risk_level': 'low',
        'min_tier': 4
    },
    
    # Power unit projects
    'rd_power_output': {
        'name': 'Power Unit Development',
        'type': 'car_upgrade',
        'cost': 400000,
        'duration_ticks': 28,
        'base_success_rate': 0.65,
        'target_stat': 'power_output',
        'target_improvement': 12.0,
        'description': 'Extract more power from the power unit',
        'risk_level': 'high',
        'min_tier': 4
    },
    'rd_power_delivery': {
        'name': 'Power Delivery Refinement',
        'type': 'car_upgrade',
        'cost': 180000,
        'duration_ticks': 16,
        'base_success_rate': 0.80,
        'target_stat': 'power_delivery_smoothness',
        'target_improvement': 7.0,
        'description': 'Improve throttle response and power delivery',
        'risk_level': 'low',
        'min_tier': 4
    },
    
    # Chassis & platform projects
    'rd_platform_stability': {
        'name': 'Platform Stability Enhancement',
        'type': 'car_upgrade',
        'cost': 220000,
        'duration_ticks': 20,
        'base_success_rate': 0.75,
        'target_stat': 'platform_stability',
        'target_improvement': 8.0,
        'description': 'Improve chassis rigidity and balance',
        'risk_level': 'medium',
        'min_tier': 4
    },
    'rd_mechanical_grip': {
        'name': 'Mechanical Grip Development',
        'type': 'car_upgrade',
        'cost': 240000,
        'duration_ticks': 22,
        'base_success_rate': 0.72,
        'target_stat': 'mechanical_grip',
        'target_improvement': 9.0,
        'description': 'Optimize suspension geometry and tire contact',
        'risk_level': 'medium',
        'min_tier': 4
    },
    
    # Reliability & endurance
    'rd_reliability': {
        'name': 'Reliability Program',
        'type': 'car_upgrade',
        'cost': 280000,
        'duration_ticks': 26,
        'base_success_rate': 0.85,
        'target_stat': 'reliability',
        'target_improvement': 10.0,
        'description': 'Reduce component failure rates',
        'risk_level': 'low',
        'min_tier': 4
    },
    'rd_thermal_tolerance': {
        'name': 'Thermal Management Study',
        'type': 'car_upgrade',
        'cost': 200000,
        'duration_ticks': 18,
        'base_success_rate': 0.78,
        'target_stat': 'thermal_tolerance',
        'target_improvement': 8.0,
        'description': 'Improve cooling efficiency and heat rejection',
        'risk_level': 'medium',
        'min_tier': 4
    },
    
    # Driveability & setup
    'rd_driveability': {
        'name': 'Driveability Enhancement',
        'type': 'car_upgrade',
        'cost': 190000,
        'duration_ticks': 16,
        'base_success_rate': 0.80,
        'target_stat': 'driveability',
        'target_improvement': 7.0,
        'description': 'Make car more predictable and driver-friendly',
        'risk_level': 'low',
        'min_tier': 4,
        'uses_wind_tunnel': False,
        'uses_simulator': True,
        'benefits_from_driver_input': True
    },
    'rd_setup_window': {
        'name': 'Setup Window Expansion',
        'type': 'car_upgrade',
        'cost': 210000,
        'duration_ticks': 18,
        'base_success_rate': 0.75,
        'target_stat': 'setup_window',
        'target_improvement': 8.0,
        'description': 'Widen the viable setup range for different tracks',
        'risk_level': 'medium',
        'min_tier': 4
    },
    
    # Advanced part development (generates custom parts)
    'rd_develop_custom_engine': {
        'name': 'Custom Engine Development',
        'type': 'part_development',
        'cost': 600000,
        'duration_ticks': 40,
        'base_success_rate': 0.60,
        'generates_part': True,
        'part_type': 'engine',
        'description': 'Develop a bespoke engine optimized for your car',
        'risk_level': 'high',
        'min_tier': 5,  # Formula Z only
        'required_engineer_skills': {
            'technical_depth': 65,
            'mechanical_understanding': 60,
            'innovation_bias': 60
        },
        'uses_wind_tunnel': False,
        'uses_simulator': True,
        'benefits_from_driver_input': False
    },
    'rd_develop_custom_aero': {
        'name': 'Custom Aero Package',
        'type': 'part_development',
        'cost': 500000,
        'duration_ticks': 35,
        'base_success_rate': 0.65,
        'generates_part': True,
        'part_type': 'aero_package',
        'description': 'Design a bespoke aerodynamic package',
        'risk_level': 'high',
        'min_tier': 5,  # Formula Z only
        'required_engineer_skills': {
            'technical_depth': 60,
            'aero_understanding': 70,
            'innovation_bias': 55
        },
        'uses_wind_tunnel': True,
        'uses_simulator': False,
        'benefits_from_driver_input': False
    },
    'rd_develop_custom_chassis': {
        'name': 'Custom Chassis Development',
        'type': 'part_development',
        'cost': 700000,
        'duration_ticks': 45,
        'base_success_rate': 0.55,
        'generates_part': True,
        'part_type': 'chassis',
        'description': 'Design and manufacture a custom chassis platform',
        'risk_level': 'high',
        'min_tier': 5,  # Formula Z only
        'required_engineer_skills': {
            'technical_depth': 70,
            'mechanical_understanding': 65,
            'systems_thinking': 60
        },
        'uses_wind_tunnel': True,
        'uses_simulator': True,
        'benefits_from_driver_input': True
    },
    
    # Infrastructure unlock projects (Phase 3 expansion)
    'rd_unlock_factory': {
        'name': 'Professional Manufacturing Facility',
        'type': 'infrastructure_unlock',
        'cost': 600000,
        'duration_ticks': 45,
        'base_success_rate': 0.75,
        'facility_key': 'factory_quality',
        'description': 'Build or upgrade to professional-grade manufacturing facility with quality control',
        'risk_level': 'medium',
        'min_tier': 4,
        'uses_wind_tunnel': False,
        'uses_simulator': False,
        'benefits_from_driver_input': False
    },
    'rd_unlock_wind_tunnel': {
        'name': 'Wind Tunnel Construction',
        'type': 'infrastructure_unlock',
        'cost': 600000,
        'duration_ticks': 50,
        'base_success_rate': 0.75,
        'facility_key': 'wind_tunnel',
        'description': 'Build a dedicated wind tunnel facility for aerodynamic testing',
        'risk_level': 'high',
        'min_tier': 3,
        'uses_wind_tunnel': False,
        'uses_simulator': False,
        'benefits_from_driver_input': False
    },
    'rd_unlock_simulator': {
        'name': 'Simulator Facility Construction',
        'type': 'infrastructure_unlock',
        'cost': 900000,
        'duration_ticks': 70,
        'base_success_rate': 0.70,
        'facility_key': 'simulator',
        'description': 'Build an advanced driver-in-loop simulator for car development',
        'risk_level': 'high',
        'min_tier': 4,
        'uses_wind_tunnel': False,
        'uses_simulator': False,
        'benefits_from_driver_input': True
    },
    
    # Infrastructure upgrade projects (Phase 3 expansion)
    'rd_upgrade_factory_5pt': {
        'name': 'Factory Optimization (Small)',
        'type': 'infrastructure_upgrade',
        'cost': 150000,
        'duration_ticks': 20,
        'base_success_rate': 0.85,
        'facility_key': 'factory_quality',
        'quality_improvement': 5.0,
        'description': 'Incremental improvements to manufacturing processes',
        'risk_level': 'low',
        'min_tier': 2,
        'uses_wind_tunnel': False,
        'uses_simulator': False,
        'benefits_from_driver_input': False
    },
    'rd_upgrade_factory_10pt': {
        'name': 'Factory Modernization (Large)',
        'type': 'infrastructure_upgrade',
        'cost': 350000,
        'duration_ticks': 35,
        'base_success_rate': 0.75,
        'facility_key': 'factory_quality',
        'quality_improvement': 10.0,
        'description': 'Major facility upgrade with new equipment and automation',
        'risk_level': 'medium',
        'min_tier': 3,
        'uses_wind_tunnel': False,
        'uses_simulator': False,
        'benefits_from_driver_input': False
    },
    'rd_upgrade_wind_tunnel_5pt': {
        'name': 'Wind Tunnel Calibration',
        'type': 'infrastructure_upgrade',
        'cost': 200000,
        'duration_ticks': 25,
        'base_success_rate': 0.80,
        'facility_key': 'wind_tunnel',
        'quality_improvement': 5.0,
        'description': 'Improve measurement accuracy and flow quality',
        'risk_level': 'low',
        'min_tier': 3,
        'requires_unlocked': 'wind_tunnel',
        'uses_wind_tunnel': True,
        'uses_simulator': False,
        'benefits_from_driver_input': False
    },
    'rd_upgrade_wind_tunnel_10pt': {
        'name': 'Wind Tunnel Expansion',
        'type': 'infrastructure_upgrade',
        'cost': 500000,
        'duration_ticks': 40,
        'base_success_rate': 0.70,
        'facility_key': 'wind_tunnel',
        'quality_improvement': 10.0,
        'description': 'Expand test section and upgrade measurement systems',
        'risk_level': 'medium',
        'min_tier': 4,
        'requires_unlocked': 'wind_tunnel',
        'uses_wind_tunnel': True,
        'uses_simulator': False,
        'benefits_from_driver_input': False
    },
    'rd_upgrade_simulator_5pt': {
        'name': 'Simulator Software Update',
        'type': 'infrastructure_upgrade',
        'cost': 250000,
        'duration_ticks': 30,
        'base_success_rate': 0.80,
        'facility_key': 'simulator',
        'quality_improvement': 5.0,
        'description': 'Update physics models and correlation algorithms',
        'risk_level': 'low',
        'min_tier': 4,
        'requires_unlocked': 'simulator',
        'uses_wind_tunnel': False,
        'uses_simulator': True,
        'benefits_from_driver_input': True
    },
    'rd_upgrade_simulator_10pt': {
        'name': 'Simulator Hardware Overhaul',
        'type': 'infrastructure_upgrade',
        'cost': 600000,
        'duration_ticks': 45,
        'base_success_rate': 0.70,
        'facility_key': 'simulator',
        'quality_improvement': 10.0,
        'description': 'Replace motion platform and visual systems',
        'risk_level': 'medium',
        'min_tier': 5,
        'requires_unlocked': 'simulator',
        'uses_wind_tunnel': False,
        'uses_simulator': True,
        'benefits_from_driver_input': True
    },
    
    # === NEW INFRASTRUCTURE PROJECTS - FORMULA V (Tier 2) ===
    # Unlock projects
    'rd_unlock_improved_simulator': {
        'name': 'Advanced Simulator Construction',
        'type': 'infrastructure_unlock',
        'cost': 180000,
        'duration_ticks': 25,
        'base_success_rate': 0.85,
        'facility_key': 'improved_simulator',
        'description': 'Upgrade from basic sim to professional-grade physics correlation',
        'risk_level': 'medium',
        'min_tier': 2,
        'uses_wind_tunnel': False,
        'uses_simulator': True,
        'benefits_from_driver_input': True
    },
    'rd_unlock_data_analysis': {
        'name': 'Data Analysis Suite',
        'type': 'infrastructure_unlock',
        'cost': 120000,
        'duration_ticks': 20,
        'base_success_rate': 0.90,
        'facility_key': 'data_analysis',
        'description': 'Implement professional data analysis tools and workflows',
        'risk_level': 'low',
        'min_tier': 2,
        'uses_wind_tunnel': False,
        'uses_simulator': False,
        'benefits_from_driver_input': False
    },
    'rd_unlock_fabrication': {
        'name': 'Fabrication Workshop Setup',
        'type': 'infrastructure_unlock',
        'cost': 200000,
        'duration_ticks': 30,
        'base_success_rate': 0.80,
        'facility_key': 'fabrication',
        'description': 'Build capacity to manufacture simple custom parts',
        'risk_level': 'medium',
        'min_tier': 2,
        'uses_wind_tunnel': False,
        'uses_simulator': False,
        'benefits_from_driver_input': False
    },
    'rd_unlock_maintenance_program': {
        'name': 'Maintenance Program Implementation',
        'type': 'infrastructure_unlock',
        'cost': 90000,
        'duration_ticks': 15,
        'base_success_rate': 0.95,
        'facility_key': 'maintenance_program',
        'description': 'Establish systematic infrastructure upkeep protocols',
        'risk_level': 'low',
        'min_tier': 2,
        'uses_wind_tunnel': False,
        'uses_simulator': False,
        'benefits_from_driver_input': False
    },
    'rd_unlock_engineering_roles': {
        'name': 'Engineering Department Expansion',
        'type': 'infrastructure_unlock',
        'cost': 150000,
        'duration_ticks': 20,
        'base_success_rate': 0.85,
        'facility_key': 'engineering_roles',
        'description': 'Create dedicated race and performance engineer roles',
        'risk_level': 'low',
        'min_tier': 2,
        'uses_wind_tunnel': False,
        'uses_simulator': False,
        'benefits_from_driver_input': False
    },
    'rd_unlock_fitness_program': {
        'name': 'Driver Fitness Program',
        'type': 'infrastructure_unlock',
        'cost': 100000,
        'duration_ticks': 15,
        'base_success_rate': 0.90,
        'facility_key': 'fitness_program',
        'description': 'Professional fitness and recovery protocols for drivers',
        'risk_level': 'low',
        'min_tier': 2,
        'uses_wind_tunnel': False,
        'uses_simulator': False,
        'benefits_from_driver_input': True
    },
    
    # === FORMULA Y (Tier 4) INFRASTRUCTURE ===
    # Unlock projects
    'rd_unlock_factory': {
        'name': 'Professional Manufacturing Facility',
        'type': 'infrastructure_unlock',
        'cost': 600000,
        'duration_ticks': 45,
        'base_success_rate': 0.75,
        'facility_key': 'factory_quality',
        'description': 'Build or upgrade to professional-grade manufacturing facility with quality control',
        'risk_level': 'medium',
        'min_tier': 4,
        'uses_wind_tunnel': False,
        'uses_simulator': False,
        'benefits_from_driver_input': False
    },
    'rd_unlock_wind_tunnel_entry': {
        'name': 'Entry-Level Wind Tunnel',
        'type': 'infrastructure_unlock',
        'cost': 750000,
        'duration_ticks': 60,
        'base_success_rate': 0.70,
        'facility_key': 'wind_tunnel_entry',
        'description': 'Build or lease half-scale wind tunnel for aero development',
        'risk_level': 'high',
        'min_tier': 4,
        'uses_wind_tunnel': False,
        'uses_simulator': False,
        'benefits_from_driver_input': False
    },
    'rd_unlock_cfd_limited': {
        'name': 'CFD Computing Infrastructure',
        'type': 'infrastructure_unlock',
        'cost': 500000,
        'duration_ticks': 40,
        'base_success_rate': 0.75,
        'facility_key': 'cfd_limited',
        'description': 'Deploy compute cluster for aerodynamic simulations',
        'risk_level': 'medium',
        'min_tier': 4,
        'uses_wind_tunnel': False,
        'uses_simulator': False,
        'benefits_from_driver_input': False
    },
    'rd_unlock_reliability_qa': {
        'name': 'Quality Assurance Department',
        'type': 'infrastructure_unlock',
        'cost': 300000,
        'duration_ticks': 35,
        'base_success_rate': 0.80,
        'facility_key': 'reliability_qa',
        'description': 'Implement systematic quality control and testing protocols',
        'risk_level': 'medium',
        'min_tier': 4,
        'uses_wind_tunnel': False,
        'uses_simulator': False,
        'benefits_from_driver_input': False
    },
    'rd_unlock_rd_department': {
        'name': 'R&D Department Formation',
        'type': 'infrastructure_unlock',
        'cost': 650000,
        'duration_ticks': 50,
        'base_success_rate': 0.75,
        'facility_key': 'rd_department',
        'description': 'Establish dedicated research and development capability',
        'risk_level': 'high',
        'min_tier': 4,
        'uses_wind_tunnel': False,
        'uses_simulator': False,
        'benefits_from_driver_input': False
    },
    'rd_unlock_specialized_teams': {
        'name': 'Specialized Engineering Teams',
        'type': 'infrastructure_unlock',
        'cost': 450000,
        'duration_ticks': 40,
        'base_success_rate': 0.80,
        'facility_key': 'specialized_teams',
        'description': 'Create aero, powertrain, and chassis specialist groups',
        'risk_level': 'medium',
        'min_tier': 4,
        'uses_wind_tunnel': False,
        'uses_simulator': False,
        'benefits_from_driver_input': False
    },
    'rd_unlock_driver_development': {
        'name': 'Driver Development Program',
        'type': 'infrastructure_unlock',
        'cost': 400000,
        'duration_ticks': 35,
        'base_success_rate': 0.80,
        'facility_key': 'driver_development',
        'description': 'Junior driver academy and talent pipeline',
        'risk_level': 'medium',
        'min_tier': 4,
        'uses_wind_tunnel': False,
        'uses_simulator': True,
        'benefits_from_driver_input': True
    },
    'rd_unlock_commercial_department': {
        'name': 'Commercial Department',
        'type': 'infrastructure_unlock',
        'cost': 250000,
        'duration_ticks': 25,
        'base_success_rate': 0.85,
        'facility_key': 'commercial_department',
        'description': 'Professional sponsor relations and marketing team',
        'risk_level': 'low',
        'min_tier': 4,
        'uses_wind_tunnel': False,
        'uses_simulator': False,
        'benefits_from_driver_input': False
    },
    
    # === FORMULA Z (Tier 5) INFRASTRUCTURE ===
    # Unlock projects
    'rd_unlock_wind_tunnel_advanced': {
        'name': 'State-of-the-Art Wind Tunnel',
        'type': 'infrastructure_unlock',
        'cost': 2500000,
        'duration_ticks': 120,
        'base_success_rate': 0.60,
        'facility_key': 'wind_tunnel_advanced',
        'description': 'Full-scale, rolling-road wind tunnel with maximum precision',
        'risk_level': 'extreme',
        'min_tier': 5,
        'uses_wind_tunnel': True,
        'uses_simulator': False,
        'benefits_from_driver_input': False
    },
    'rd_unlock_cfd_advanced': {
        'name': 'Advanced CFD Compute Farm',
        'type': 'infrastructure_unlock',
        'cost': 1800000,
        'duration_ticks': 90,
        'base_success_rate': 0.65,
        'facility_key': 'cfd_advanced',
        'description': 'Massive parallel computing for rapid aerodynamic iteration',
        'risk_level': 'high',
        'min_tier': 5,
        'uses_wind_tunnel': False,
        'uses_simulator': False,
        'benefits_from_driver_input': False
    },
    'rd_unlock_regulation_analysis': {
        'name': 'Regulation Analysis Department',
        'type': 'infrastructure_unlock',
        'cost': 1200000,
        'duration_ticks': 70,
        'base_success_rate': 0.70,
        'facility_key': 'regulation_analysis',
        'description': 'Team dedicated to finding gray areas in regulations',
        'risk_level': 'high',
        'min_tier': 5,
        'uses_wind_tunnel': False,
        'uses_simulator': False,
        'benefits_from_driver_input': False
    },
    'rd_unlock_political_capital_infrastructure': {
        'name': 'Political Operations Office',
        'type': 'infrastructure_unlock',
        'cost': 1500000,
        'duration_ticks': 80,
        'base_success_rate': 0.65,
        'facility_key': 'political_capital_infrastructure',
        'description': 'Build influence networks and leverage soft power',
        'risk_level': 'high',
        'min_tier': 5,
        'uses_wind_tunnel': False,
        'uses_simulator': False,
        'benefits_from_driver_input': False
    },
    'rd_unlock_redundant_infrastructure': {
        'name': 'Redundant Infrastructure Systems',
        'type': 'infrastructure_unlock',
        'cost': 2000000,
        'duration_ticks': 100,
        'base_success_rate': 0.70,
        'facility_key': 'redundant_infrastructure',
        'description': 'Backup systems to ensure failures never kill weekends',
        'risk_level': 'high',
        'min_tier': 5,
        'uses_wind_tunnel': False,
        'uses_simulator': False,
        'benefits_from_driver_input': False
    },
    'rd_unlock_talent_pipeline': {
        'name': 'Talent Pipeline Infrastructure',
        'type': 'infrastructure_unlock',
        'cost': 1600000,
        'duration_ticks': 85,
        'base_success_rate': 0.70,
        'facility_key': 'talent_pipeline',
        'description': 'Comprehensive recruitment and retention systems',
        'risk_level': 'high',
        'min_tier': 5,
        'uses_wind_tunnel': False,
        'uses_simulator': False,
        'benefits_from_driver_input': False
    },
    'rd_unlock_media_control': {
        'name': 'Media Operations Center',
        'type': 'infrastructure_unlock',
        'cost': 1300000,
        'duration_ticks': 75,
        'base_success_rate': 0.70,
        'facility_key': 'media_control',
        'description': 'Narrative shaping and reputation management capability',
        'risk_level': 'high',
        'min_tier': 5,
        'uses_wind_tunnel': False,
        'uses_simulator': False,
        'benefits_from_driver_input': False
    },
    
    # === UPGRADE PROJECTS (Small +5, Large +10) ===
    # Grassroots facilities - small upgrades only
    'rd_upgrade_basic_simulator_5pt': {
        'name': 'Basic Simulator Improvement',
        'type': 'infrastructure_upgrade',
        'cost': 80000,
        'duration_ticks': 15,
        'base_success_rate': 0.90,
        'facility_key': 'basic_simulator',
        'quality_improvement': 5.0,
        'description': 'Incremental improvements to basic simulator',
        'risk_level': 'low',
        'min_tier': 1,
        'uses_wind_tunnel': False,
        'uses_simulator': True,
        'benefits_from_driver_input': True
    },
    'rd_upgrade_workshop_5pt': {
        'name': 'Workshop Equipment Upgrade',
        'type': 'infrastructure_upgrade',
        'cost': 100000,
        'duration_ticks': 15,
        'base_success_rate': 0.90,
        'facility_key': 'workshop',
        'quality_improvement': 5.0,
        'description': 'Better tools and equipment for workshop',
        'risk_level': 'low',
        'min_tier': 1,
        'uses_wind_tunnel': False,
        'uses_simulator': False,
        'benefits_from_driver_input': False
    },
    
    # Formula V facilities - small and large upgrades
    'rd_upgrade_improved_simulator_5pt': {
        'name': 'Improved Simulator Tuning',
        'type': 'infrastructure_upgrade',
        'cost': 150000,
        'duration_ticks': 20,
        'base_success_rate': 0.85,
        'facility_key': 'improved_simulator',
        'quality_improvement': 5.0,
        'description': 'Physics model refinement',
        'risk_level': 'low',
        'min_tier': 2,
        'requires_unlocked': 'improved_simulator',
        'uses_wind_tunnel': False,
        'uses_simulator': True,
        'benefits_from_driver_input': True
    },
    'rd_upgrade_improved_simulator_10pt': {
        'name': 'Improved Simulator Overhaul',
        'type': 'infrastructure_upgrade',
        'cost': 350000,
        'duration_ticks': 35,
        'base_success_rate': 0.75,
        'facility_key': 'improved_simulator',
        'quality_improvement': 10.0,
        'description': 'Major simulator hardware and software upgrade',
        'risk_level': 'medium',
        'min_tier': 2,
        'requires_unlocked': 'improved_simulator',
        'uses_wind_tunnel': False,
        'uses_simulator': True,
        'benefits_from_driver_input': True
    },
    'rd_upgrade_fabrication_5pt': {
        'name': 'Fabrication Process Improvement',
        'type': 'infrastructure_upgrade',
        'cost': 180000,
        'duration_ticks': 25,
        'base_success_rate': 0.85,
        'facility_key': 'fabrication',
        'quality_improvement': 5.0,
        'description': 'Better machining and assembly techniques',
        'risk_level': 'low',
        'min_tier': 2,
        'requires_unlocked': 'fabrication',
        'uses_wind_tunnel': False,
        'uses_simulator': False,
        'benefits_from_driver_input': False
    },
    'rd_upgrade_fabrication_10pt': {
        'name': 'Fabrication Equipment Expansion',
        'type': 'infrastructure_upgrade',
        'cost': 400000,
        'duration_ticks': 40,
        'base_success_rate': 0.75,
        'facility_key': 'fabrication',
        'quality_improvement': 10.0,
        'description': 'Advanced manufacturing equipment installation',
        'risk_level': 'medium',
        'min_tier': 2,
        'requires_unlocked': 'fabrication',
        'uses_wind_tunnel': False,
        'uses_simulator': False,
        'benefits_from_driver_input': False
    },
    
    # Formula Y facilities - small and large upgrades
    'rd_upgrade_wind_tunnel_entry_5pt': {
        'name': 'Wind Tunnel Calibration',
        'type': 'infrastructure_upgrade',
        'cost': 300000,
        'duration_ticks': 30,
        'base_success_rate': 0.80,
        'facility_key': 'wind_tunnel_entry',
        'quality_improvement': 5.0,
        'description': 'Improve correlation and measurement precision',
        'risk_level': 'medium',
        'min_tier': 4,
        'requires_unlocked': 'wind_tunnel_entry',
        'uses_wind_tunnel': True,
        'uses_simulator': False,
        'benefits_from_driver_input': False
    },
    'rd_upgrade_wind_tunnel_entry_10pt': {
        'name': 'Wind Tunnel Expansion',
        'type': 'infrastructure_upgrade',
        'cost': 700000,
        'duration_ticks': 50,
        'base_success_rate': 0.70,
        'facility_key': 'wind_tunnel_entry',
        'quality_improvement': 10.0,
        'description': 'Test section enlargement and sensor upgrades',
        'risk_level': 'high',
        'min_tier': 4,
        'requires_unlocked': 'wind_tunnel_entry',
        'uses_wind_tunnel': True,
        'uses_simulator': False,
        'benefits_from_driver_input': False
    },
    'rd_upgrade_cfd_limited_5pt': {
        'name': 'CFD Software Update',
        'type': 'infrastructure_upgrade',
        'cost': 250000,
        'duration_ticks': 25,
        'base_success_rate': 0.85,
        'facility_key': 'cfd_limited',
        'quality_improvement': 5.0,
        'description': 'Better solver algorithms and pre-processing',
        'risk_level': 'low',
        'min_tier': 4,
        'requires_unlocked': 'cfd_limited',
        'uses_wind_tunnel': False,
        'uses_simulator': False,
        'benefits_from_driver_input': False
    },
    'rd_upgrade_cfd_limited_10pt': {
        'name': 'CFD Compute Expansion',
        'type': 'infrastructure_upgrade',
        'cost': 600000,
        'duration_ticks': 45,
        'base_success_rate': 0.75,
        'facility_key': 'cfd_limited',
        'quality_improvement': 10.0,
        'description': 'Additional compute nodes for faster iterations',
        'risk_level': 'medium',
        'min_tier': 4,
        'requires_unlocked': 'cfd_limited',
        'uses_wind_tunnel': False,
        'uses_simulator': False,
        'benefits_from_driver_input': False
    },
    'rd_upgrade_rd_department_5pt': {
        'name': 'R&D Process Optimization',
        'type': 'infrastructure_upgrade',
        'cost': 300000,
        'duration_ticks': 30,
        'base_success_rate': 0.80,
        'facility_key': 'rd_department',
        'quality_improvement': 5.0,
        'description': 'Streamline research workflows',
        'risk_level': 'medium',
        'min_tier': 4,
        'requires_unlocked': 'rd_department',
        'uses_wind_tunnel': False,
        'uses_simulator': False,
        'benefits_from_driver_input': False
    },
    'rd_upgrade_rd_department_10pt': {
        'name': 'R&D Capacity Expansion',
        'type': 'infrastructure_upgrade',
        'cost': 750000,
        'duration_ticks': 55,
        'base_success_rate': 0.70,
        'facility_key': 'rd_department',
        'quality_improvement': 10.0,
        'description': 'Parallel research capability and specialized labs',
        'risk_level': 'high',
        'min_tier': 4,
        'requires_unlocked': 'rd_department',
        'uses_wind_tunnel': False,
        'uses_simulator': False,
        'benefits_from_driver_input': False
    },
    
    # Formula Z facilities - small and large upgrades
    'rd_upgrade_wind_tunnel_advanced_5pt': {
        'name': 'Advanced Wind Tunnel Optimization',
        'type': 'infrastructure_upgrade',
        'cost': 800000,
        'duration_ticks': 50,
        'base_success_rate': 0.75,
        'facility_key': 'wind_tunnel_advanced',
        'quality_improvement': 5.0,
        'description': 'Ultimate precision measurement systems',
        'risk_level': 'high',
        'min_tier': 5,
        'requires_unlocked': 'wind_tunnel_advanced',
        'uses_wind_tunnel': True,
        'uses_simulator': False,
        'benefits_from_driver_input': False
    },
    'rd_upgrade_wind_tunnel_advanced_10pt': {
        'name': 'Advanced Wind Tunnel Mastery',
        'type': 'infrastructure_upgrade',
        'cost': 1800000,
        'duration_ticks': 80,
        'base_success_rate': 0.65,
        'facility_key': 'wind_tunnel_advanced',
        'quality_improvement': 10.0,
        'description': 'Beyond state-of-the-art experimental capabilities',
        'risk_level': 'extreme',
        'min_tier': 5,
        'requires_unlocked': 'wind_tunnel_advanced',
        'uses_wind_tunnel': True,
        'uses_simulator': False,
        'benefits_from_driver_input': False
    },
    'rd_upgrade_cfd_advanced_5pt': {
        'name': 'Advanced CFD Optimization',
        'type': 'infrastructure_upgrade',
        'cost': 650000,
        'duration_ticks': 45,
        'base_success_rate': 0.80,
        'facility_key': 'cfd_advanced',
        'quality_improvement': 5.0,
        'description': 'Cutting-edge simulation algorithms',
        'risk_level': 'medium',
        'min_tier': 5,
        'requires_unlocked': 'cfd_advanced',
        'uses_wind_tunnel': False,
        'uses_simulator': False,
        'benefits_from_driver_input': False
    },
    'rd_upgrade_cfd_advanced_10pt': {
        'name': 'Advanced CFD Supercomputing',
        'type': 'infrastructure_upgrade',
        'cost': 1500000,
        'duration_ticks': 75,
        'base_success_rate': 0.70,
        'facility_key': 'cfd_advanced',
        'quality_improvement': 10.0,
        'description': 'Massive compute capacity for real-time iteration',
        'risk_level': 'high',
        'min_tier': 5,
        'requires_unlocked': 'cfd_advanced',
        'uses_wind_tunnel': False,
        'uses_simulator': False,
        'benefits_from_driver_input': False
    }
}

# Upgrade Package Catalog (Phase 5) - Bundled improvements available per tier
UPGRADE_PACKAGE_CATALOG = {
    # Tier 2+ upgrades (Formula V)
    'basic_aero': {
        'name': 'Basic Aero Package',
        'tier_availability': [2, 3, 4, 5],
        'cost': 75000,
        'stat_improvements': {
            'aero_efficiency': 4.0,
            'downforce_peak': 3.0,
            'drag': -2.0
        },
        'description': 'Entry-level aerodynamic improvements',
        'category': 'performance'
    },
    'basic_engine': {
        'name': 'Basic Engine Tune',
        'tier_availability': [2, 3, 4, 5],
        'cost': 60000,
        'stat_improvements': {
            'power_output': 3.0,
            'power_delivery_smoothness': 2.0
        },
        'description': 'Software and hardware tuning for more power',
        'category': 'performance'
    },
    
    # Tier 3+ upgrades (Formula X)
    'advanced_suspension': {
        'name': 'Advanced Suspension System',
        'tier_availability': [3, 4, 5],
        'cost': 120000,
        'stat_improvements': {
            'mechanical_grip': 5.0,
            'platform_stability': 4.0,
            'driveability': 3.0
        },
        'required_parts': ['suspension'],
        'description': 'High-performance suspension with active damping',
        'category': 'performance'
    },
    'reliability_package': {
        'name': 'Reliability Enhancement Package',
        'tier_availability': [3, 4, 5],
        'cost': 90000,
        'stat_improvements': {
            'reliability': 6.0,
            'thermal_tolerance': 4.0,
            'component_wear_rate': -3.0
        },
        'description': 'Comprehensive reliability improvements',
        'category': 'reliability'
    },
    
    # Tier 4+ upgrades (Formula Y)
    'advanced_aero': {
        'name': 'Advanced Aero Development',
        'tier_availability': [4, 5],
        'cost': 200000,
        'stat_improvements': {
            'aero_efficiency': 7.0,
            'downforce_peak': 6.0,
            'downforce_consistency': 5.0,
            'drag': -4.0
        },
        'required_parts': ['aero_package'],
        'incompatible_upgrades': ['basic_aero'],
        'description': 'Cutting-edge aerodynamic package',
        'category': 'performance'
    },
    'power_unit_upgrade': {
        'name': 'Power Unit Performance Upgrade',
        'tier_availability': [4, 5],
        'cost': 250000,
        'stat_improvements': {
            'power_output': 8.0,
            'power_delivery_smoothness': 6.0,
            'thermal_tolerance': 3.0
        },
        'required_parts': ['engine', 'cooling'],
        'incompatible_upgrades': ['basic_engine'],
        'min_car_stat': {'reliability': 45.0},
        'description': 'Maximum power extraction with thermal management',
        'category': 'performance'
    },
    'driveability_suite': {
        'name': 'Driveability Enhancement Suite',
        'tier_availability': [4, 5],
        'cost': 150000,
        'stat_improvements': {
            'driveability': 6.0,
            'setup_window': 5.0,
            'balance_sensitivity': -3.0,
            'ride_height_sensitivity': -2.0
        },
        'description': 'Make car more predictable and easier to drive',
        'category': 'driveability'
    },
    
    # Tier 5 upgrades (Formula Z only)
    'complete_replatform': {
        'name': 'Complete Platform Replatforming',
        'tier_availability': [5],
        'cost': 1000000,
        'stat_improvements': {
            'aero_efficiency': 10.0,
            'downforce_peak': 8.0,
            'power_output': 9.0,
            'mechanical_grip': 7.0,
            'platform_stability': 8.0,
            'reliability': 6.0,
            'driveability': 5.0
        },
        'required_parts': ['chassis', 'engine', 'aero_package', 'suspension'],
        'incompatible_upgrades': ['basic_aero', 'basic_engine', 'advanced_aero', 'power_unit_upgrade'],
        'min_car_stat': {'reliability': 50.0, 'concept_coherence': 60.0},
        'description': 'Complete car redesign with all-new platform',
        'category': 'complete_replatform'
    },
    'active_aero_system': {
        'name': 'Active Aerodynamics System',
        'tier_availability': [5],
        'cost': 400000,
        'stat_improvements': {
            'aero_efficiency': 9.0,
            'downforce_peak': 7.0,
            'drag': -6.0,
            'setup_window': 4.0
        },
        'required_parts': ['aero_package', 'electronics'],
        'description': 'DRS and active wing elements for adaptive downforce',
        'category': 'performance'
    },
    'hybrid_power_system': {
        'name': 'Hybrid Power Recovery System',
        'tier_availability': [5],
        'cost': 500000,
        'stat_improvements': {
            'power_output': 12.0,
            'efficiency': 8.0,
            'power_delivery_smoothness': 7.0
        },
        'required_parts': ['engine', 'electronics', 'cooling'],
        'min_car_stat': {'reliability': 55.0, 'thermal_tolerance': 50.0},
        'description': 'Energy recovery and deployment system',
        'category': 'performance'
    }
}


# ============================================================
# SECTION 1: Entity System
# ============================================================

STATS_SCHEMAS = {
    "Driver": {
        "pace": 50.0, "qualifying_pace": 50.0, "race_pace": 50.0,
        "low_fuel_performance": 50.0, "high_fuel_performance": 50.0,
        "tire_conservation": 50.0, "tire_warmup": 50.0, "wet_weather_skill": 50.0,
        "consistency": 50.0, "mistake_rate": 50.0, "recovery_from_error": 50.0,
        "stint_stability": 50.0, "fatigue_sensitivity": 50.0,
        "racecraft": 50.0, "overtaking_skill": 50.0, "defensive_skill": 50.0,
        "starts": 50.0, "spatial_awareness": 50.0,
        "adaptability": 50.0, "learning_rate": 50.0, "track_learning_speed": 50.0,
        "regulation_adaptation": 50.0,
        "feedback_quality": 50.0, "technical_language_alignment": 50.0,
        "setup_sensitivity": 50.0,
        "pressure_handling": 50.0, "confidence_volatility": 50.0,
        "aggression": 50.0, "discipline": 50.0, "ego": 50.0, "political_awareness": 50.0,
        "mettle": 55.0
    },
    "Engineer": {
        "technical_depth": 50.0, "systems_thinking": 50.0, "aero_understanding": 50.0,
        "mechanical_understanding": 50.0, "powertrain_understanding": 50.0,
        "innovation_bias": 50.0, "concept_generation_rate": 50.0, "upgrade_effectiveness": 50.0,
        "upgrade_scalability": 50.0, "regulation_interpretation": 50.0,
        "correlation_accuracy": 50.0, "simulation_fidelity": 50.0, "trackside_translation": 50.0,
        "data_noise_tolerance": 50.0,
        "iteration_speed": 50.0, "delivery_discipline": 50.0, "project_management": 50.0,
        "failure_recovery_speed": 50.0, "reliability_focus": 50.0,
        "communication": 50.0, "driver_alignment": 50.0, "cross_department_alignment": 50.0,
        "knowledge_transfer": 50.0,
        "mettle": 55.0
    },
    "Mechanic": {
        "build_quality": 50.0, "assembly_precision": 50.0, "component_handling": 50.0,
        "torque_discipline": 50.0, "pre_race_preparation": 50.0,
        "pit_execution": 50.0, "coordination": 50.0, "reaction_time": 50.0,
        "tool_familiarity": 50.0, "procedure_adherence": 50.0,
        "error_rate": 50.0, "error_detection_speed": 50.0, "error_recovery_quality": 50.0,
        "rework_efficiency": 50.0,
        "fatigue_resistance": 50.0, "stress_handling": 50.0, "burnout_rate": 50.0,
        "focus_retention": 50.0, "weekend_consistency": 50.0, "morale": 50.0,
        "mettle": 55.0
    },
    "Strategist": {
        "race_reading": 50.0, "situational_awareness": 50.0, "traffic_modeling": 50.0,
        "gap_estimation": 50.0, "opponent_intent_reading": 50.0,
        "tire_modeling": 50.0, "degradation_prediction": 50.0, "weather_forecasting": 50.0,
        "safety_car_prediction": 50.0, "virtual_safety_car_modeling": 50.0,
        "risk_calibration": 50.0, "reward_estimation": 50.0, "commitment_threshold": 50.0,
        "plan_flexibility": 50.0, "contingency_depth": 50.0,
        "timing_sense": 50.0, "pit_window_precision": 50.0, "call_latency": 50.0,
        "multi_car_coordination": 50.0, "morale": 50.0,
        "mettle": 55.0
    },
    "AIPrincipal": {
        "aggression": 50.0, "risk_tolerance": 50.0, "patience": 50.0,
        "long_term_orientation": 50.0, "short_term_pressure_response": 50.0,
        "financial_discipline": 50.0, "budget_forecasting_accuracy": 50.0,
        "capital_allocation_balance": 50.0, "cost_cap_management": 50.0, "liquidity_conservatism": 50.0,
        "talent_evaluation_accuracy": 50.0, "talent_strategy": 50.0, "succession_planning": 50.0,
        "staff_loyalty_bias": 50.0, "ruthlessness": 50.0,
        "organizational_cohesion": 50.0, "culture_resilience": 50.0, "burnout_mitigation": 50.0,
        "crisis_management": 50.0,
        "political_instinct": 50.0, "media_management": 50.0, "regulatory_navigation": 50.0,
        "supplier_relationship_management": 50.0,
        "ambition": 50.0, "career_opportunism": 50.0,
        "relationship_management": 50.0, "sponsor_relationship_cultivation": 50.0,
        "negotiation_effectiveness": 50.0,
        "mettle": 55.0
    },
    "Car": {
        "aero_efficiency": 50.0, "downforce_peak": 50.0, "downforce_consistency": 50.0,
        "drag": 50.0, "power_output": 50.0, "power_delivery_smoothness": 50.0,
        "mechanical_grip": 50.0, "platform_stability": 50.0,
        "driveability": 50.0, "setup_window": 50.0, "ride_height_sensitivity": 50.0,
        "balance_sensitivity": 50.0,
        "reliability": 50.0, "thermal_tolerance": 50.0, "component_wear_rate": 50.0,
        "failure_mode_severity": 50.0,
        "upgrade_sensitivity": 50.0, "upgrade_synergy": 50.0, "concept_coherence": 50.0,
        "development_ceiling": 50.0, "regulation_resilience": 50.0
    },
    "Manufacturer": {
        "innovation_rate": 50.0, "build_quality": 50.0, "consistency": 50.0,
        "financial_stability": 50.0, "regulatory_adaptability": 50.0,
        "aero_philosophy": 50.0, "power_philosophy": 50.0, "reliability_philosophy": 50.0,
        "customer_support": 50.0, "supply_chain_resilience": 50.0,
        "technical_heritage": 50.0, "brand_prestige": 50.0, "racing_pedigree": 50.0,
        "risk_appetite": 50.0, "development_cycle_speed": 50.0,
        "quality_control_rigor": 50.0, "material_science_depth": 50.0,
        "cfd_capability": 50.0, "wind_tunnel_access": 50.0, "market_sensitivity": 50.0
    },
    "Part": {
        "peak_performance": 50.0, "reliability": 50.0, "weight": 50.0,
        "efficiency": 50.0, "setup_window": 50.0, "compatibility_band": 50.0,
        "development_cost": 50.0, "maintenance_cost": 50.0,
        "correlation_accuracy": 50.0, "regulatory_exposure": 50.0,
        "upgrade_potential": 50.0, "obsolescence_resistance": 50.0,
        "manufacturing_complexity": 50.0, "supply_lead_time": 50.0,
        "crash_protection": 50.0, "thermal_management": 50.0,
        "aero_sensitivity": 50.0, "mechanical_stress_tolerance": 50.0
    }
}

@dataclass
class Entity:
    """
    Base entity with universal meta-properties.
    Growth/decay mechanics applied uniformly by simulation.
    """
    name: str = ""  # Legacy ID (e.g., "Driver 1-0-0" or generated name)
    display_name: str = ""  # Human-readable name (e.g., "Carlos Antonelli")
    entity_id: int = 0  # Unique identifier for name generation
    age: int = 20
    
    # Universal meta-properties (with defaults)
    potential_ceiling: float = field(default=100.0)  # Max achievable ability
    decay_rate: float = field(default=0.5)  # How quickly ability degrades post-peak
    variance_band: float = field(default=5.0)  # Performance noise
    form_momentum: float = field(default=0.0)  # Short-term streak effect
    
    # Morale system (stabilization)
    morale_baseline: float = field(default=50.0)  # Personality-driven equilibrium point
    morale_last_updated: int = field(default=0)  # Tick when morale last changed
    
    # Current ratings (canonical source of truth)
    current_ratings: Dict[str, float] = field(default_factory=dict)
    
    # Performance history for time-series analysis
    performance_history: List[Tuple[int, Dict[str, float]]] = field(default_factory=list)
    
    def __post_init__(self):
        # Initialize current_ratings from schema if empty
        if not self.current_ratings:
            cls_name = self.__class__.__name__
            if cls_name in STATS_SCHEMAS:
                # Copy defaults
                self.current_ratings = STATS_SCHEMAS[cls_name].copy()
        
        # Calculate personality-driven morale baseline
        if not hasattr(self, '_baseline_calculated'):
            self.morale_baseline = self._calculate_morale_baseline()
            self._baseline_calculated = True
    
    def _calculate_morale_baseline(self) -> float:
        """Calculate personality-driven morale baseline
        
        Factors:
        - Mettle: Higher mettle = higher baseline resilience (primary)
        - Discipline: Self-management ability (secondary)
        - Pressure_handling: Mental fortitude under stress (tertiary)
        
        Returns baseline between 40-60
        """
        mettle = self.current_ratings.get('mettle', 55.0)
        discipline = self.current_ratings.get('discipline', 50.0)
        pressure_handling = self.current_ratings.get('pressure_handling', 50.0)
        
        # Baseline ranges from 40-60 based on personality
        # Mettle is primary factor (weight 0.5)
        # Discipline and pressure_handling secondary (weight 0.25 each)
        baseline = 40.0 + (mettle / 10.0) * 0.5 + (discipline / 20.0) * 0.25 + (pressure_handling / 20.0) * 0.25
        return max(40.0, min(60.0, baseline))

    def __getattr__(self, name: str) -> Any:
        # Proxy access to current_ratings keys
        if "current_ratings" in self.__dict__ and name in self.current_ratings:
            return self.current_ratings[name]
        raise AttributeError(f"'{type(self).__name__}' object has no attribute '{name}'")
        
    def __setattr__(self, name: str, value: Any) -> None:
        # Intercept writes to stats to update current_ratings
        cls_name = self.__class__.__name__
        if cls_name in STATS_SCHEMAS and name in STATS_SCHEMAS[cls_name]:
            if "current_ratings" in self.__dict__:
                self.current_ratings[name] = value
                return
        super().__setattr__(name, value)
    
    def update_growth(self, context: Dict[str, Any], infrastructure_quality: float = 50.0) -> None:
        """Apply potential progression based on context and infrastructure.
        
        Args:
            context: Dict with 'peak_age', 'team_stability', etc.
            infrastructure_quality: Average infrastructure quality (0-100)
        """
        # Peak age curves vary by entity type
        # Use entity-specific peak age range (midpoint for growth calculation)
        peak_age_start, peak_age_end = self.peak_age_range
        peak_age = (peak_age_start + peak_age_end) // 2
        age_factor = 1.0 - abs(self.age - peak_age) / 20.0
        age_factor = max(0.1, min(1.0, age_factor))
        
        # Apply momentum from recent results
        momentum = self.form_momentum
        stability = context.get('team_stability', 0.5)
        
        # Infrastructure modifier for growth rate
        # High infrastructure (>70): +20% growth
        # Medium infrastructure (50): neutral
        # Low infrastructure (<30): -20% growth
        infra_modifier = 1.0 + ((infrastructure_quality - 50.0) / 100.0) * 0.4
        infra_modifier = max(0.8, min(1.2, infra_modifier))
        
        # Growth rate
        base_growth = 0.1 * age_factor * stability * infra_modifier
        momentum_boost = momentum * 0.05
        
        # Update ratings toward potential ceiling
        for stat_name, current_value in self.current_ratings.items():
            if current_value < self.potential_ceiling:
                potential_remaining = (self.potential_ceiling - current_value) / 100.0
                growth = base_growth * potential_remaining + momentum_boost
                new_value = current_value + growth
                self.current_ratings[stat_name] = max(1.0, min(99.0, new_value))
    
    def apply_decay(self, infrastructure_quality: float = 50.0) -> None:
        """Apply decline pressure based on age, decay_rate, and infrastructure.
        
        Args:
            infrastructure_quality: Average infrastructure quality (0-100)
        """
        # Use entity-specific peak age from peak_age_range property
        peak_age_start, peak_age_end = self.peak_age_range
        peak_age = (peak_age_start + peak_age_end) // 2  # Use midpoint of peak range
        if self.age > peak_age_end:
            years_past_peak = self.age - peak_age_end
            
            # Infrastructure modifier for decay rate
            # High infrastructure (>70): -40% decay
            # Medium infrastructure (50): neutral
            # Low infrastructure (<30): +40% decay
            infra_modifier = 1.0 - ((infrastructure_quality - 50.0) / 100.0) * 0.8
            infra_modifier = max(0.6, min(1.4, infra_modifier))
            
            decay_amount = self.decay_rate * (years_past_peak / 10.0) * infra_modifier
            
            for stat_name in self.current_ratings:
                self.current_ratings[stat_name] -= decay_amount
                self.current_ratings[stat_name] = max(1.0, self.current_ratings[stat_name])
    
    def get_expected_performance(self, context: Dict[str, Any], rng: random.Random) -> float:
        """Calculate expected performance from ratings."""
        # Weight relevant stats by context
        # Base implementation: average all ratings
        if not self.current_ratings:
            return 50.0
        
        total = sum(self.current_ratings.values())
        avg = total / len(self.current_ratings)
        
        # Add variance
        variance = rng.uniform(-self.variance_band, self.variance_band)
        
        # Add form momentum
        momentum_effect = self.form_momentum * 5.0
        
        result = avg + variance + momentum_effect
        return max(0.0, min(100.0, result))
    
    # ============================================
    # Derived Metric Aggregation Layer
    # ============================================
    
    @property
    def overall_rating(self) -> float:
        """Average of all current ratings - universal quality metric"""
        if not self.current_ratings:
            return 50.0
        return sum(self.current_ratings.values()) / len(self.current_ratings)
    
    @property
    def potential_rating(self) -> float:
        """Projected rating at peak potential"""
        return min(self.overall_rating + (self.potential_ceiling - self.overall_rating), 100.0)
    
    @property
    def peak_age_range(self) -> Tuple[int, int]:
        """Expected peak age range for this entity type (override in subclasses)"""
        return (27, 32)  # Default for drivers


@dataclass
class Driver(Entity):
    """~26 stats - high-impact human entity"""
    
    # Required base fields (must come first)
    name: str = ""
    age: int = 20
    
    # Stats are defined in STATS_SCHEMAS["Driver"]
    # No local fields needed - Entity canonicalizes them
    
    # Driver-specific derived metrics
    @property
    def raw_pace(self) -> float:
        """Pure speed ability (qualifying + race + overall pace)"""
        return (
            self.current_ratings.get('pace', 50.0) +
            self.current_ratings.get('qualifying_pace', 50.0) +
            self.current_ratings.get('race_pace', 50.0)
        ) / 3.0
    
    @property
    def risk_profile(self) -> float:
        """Tendency toward mistakes and aggression (higher = riskier)"""
        return (
            self.current_ratings.get('aggression', 50.0) +
            self.current_ratings.get('mistake_rate', 50.0) -
            self.current_ratings.get('discipline', 50.0)
        ) / 3.0 + 50.0
    
    @property
    def execution_quality(self) -> float:
        """Consistency and error recovery ability"""
        return (
            self.current_ratings.get('consistency', 50.0) +
            self.current_ratings.get('recovery_from_error', 50.0) +
            self.current_ratings.get('spatial_awareness', 50.0)
        ) / 3.0


@dataclass  
class Engineer(Entity):
    """~24 stats - long-horizon human entity"""
    
    # Required base fields
    name: str = ""
    age: int = 25
    
    # Stats definitions removed - canonicalized in Entity.current_ratings
    
    # Engineer-specific derived metrics
    @property
    def technical_depth_score(self) -> float:
        """Overall technical understanding across domains"""
        return (
            self.current_ratings.get('technical_depth', 50.0) +
            self.current_ratings.get('aero_understanding', 50.0) +
            self.current_ratings.get('mechanical_understanding', 50.0) +
            self.current_ratings.get('systems_thinking', 50.0)
        ) / 4.0
    
    @property
    def development_velocity(self) -> float:
        """Speed and effectiveness of development work"""
        return (
            self.current_ratings.get('iteration_speed', 50.0) +
            self.current_ratings.get('upgrade_effectiveness', 50.0) +
            self.current_ratings.get('delivery_discipline', 50.0)
        ) / 3.0
    
    @property
    def correlation_reliability(self) -> float:
        """Accuracy of simulations to reality"""
        return (
            self.current_ratings.get('correlation_accuracy', 50.0) +
            self.current_ratings.get('simulation_fidelity', 50.0) +
            self.current_ratings.get('trackside_translation', 50.0)
        ) / 3.0
    
    @property
    def peak_age_range(self) -> Tuple[int, int]:
        """Engineers peak later than drivers - brain work, not physical"""
        return (32, 45)  # Peak between 32-45, much longer than drivers


@dataclass
class Mechanic(Entity):
    """~22 stats - execution-focused entity"""
    
    # Required base fields
    name: str = ""
    age: int = 22
    
    # Stats definitions removed - canonicalized in Entity.current_ratings
    
    # Mechanic-specific derived metrics
    @property
    def build_quality_score(self) -> float:
        """Preparation and assembly quality"""
        return (
            self.current_ratings.get('build_quality', 50.0) +
            self.current_ratings.get('assembly_precision', 50.0) +
            self.current_ratings.get('pre_race_preparation', 50.0)
        ) / 3.0
    
    @property
    def pit_execution_score(self) -> float:
        """Live pit stop performance"""
        return (
            self.current_ratings.get('pit_execution', 50.0) +
            self.current_ratings.get('coordination', 50.0) +
            self.current_ratings.get('reaction_time', 50.0)
        ) / 3.0
    
    @property
    def peak_age_range(self) -> Tuple[int, int]:
        """Mechanics peak slightly later than drivers - physical but experienced"""
        return (28, 38)  # Peak between 28-38, moderate longevity


@dataclass
class Strategist(Entity):
    """~23 stats - shapes outcomes without touching car"""
    
    # Required base fields
    name: str = ""
    age: int = 30
    
    # Stats definitions removed - canonicalized in Entity.current_ratings
    
    # Strategist-specific derived metrics
    @property
    def situational_iq(self) -> float:
        """Awareness and race reading ability"""
        return (
            self.current_ratings.get('race_reading', 50.0) +
            self.current_ratings.get('situational_awareness', 50.0) +
            self.current_ratings.get('traffic_modeling', 50.0)
        ) / 3.0
    
    @property
    def decision_speed(self) -> float:
        """Timing and reaction quality"""
        return (
            self.current_ratings.get('timing_sense', 50.0) +
            self.current_ratings.get('call_latency', 50.0) +
            self.current_ratings.get('pit_window_precision', 50.0)
        ) / 3.0
    
    @property
    def peak_age_range(self) -> Tuple[int, int]:
        """Strategists peak with experience - mental work"""
        return (30, 50)  # Peak between 30-50, very long career


@dataclass
class AIPrincipal(Entity):
    """~25 stats - organizational state & tendency vector (NOT intelligence)"""
    
    # Required base fields
    name: str = ""
    age: int = 45
    
    # Stats definitions removed - canonicalized in Entity.current_ratings
    
    @property
    def peak_age_range(self) -> Tuple[int, int]:
        """Principals peak with extensive experience - leadership role"""
        return (40, 60)  # Peak between 40-60, wisdom-based role


@dataclass
class Car(Entity):
    """~24 stats - stateful, season-bound artifact"""
    
    # Required base fields (cars don't age like humans)
    name: str = ""
    age: int = 0
    
    # Versioning
    version: int = 1
    
    # Stats definitions removed - canonicalized in Entity.current_ratings
    
    # Base ratings - tier-specific ratings without parts applied
    # This preserves the car's original performance profile when parts are changed
    base_ratings: Dict[str, float] = field(default_factory=dict)
    
    # Car-specific derived metrics
    @property
    def performance_envelope(self) -> float:
        """Raw speed potential"""
        return (
            self.current_ratings.get('aero_efficiency', 50.0) +
            self.current_ratings.get('downforce_peak', 50.0) +
            self.current_ratings.get('power_output', 50.0) +
            self.current_ratings.get('mechanical_grip', 50.0)
        ) / 4.0
    
    @property
    def usability(self) -> float:
        """Driver friendliness and setup window"""
        return (
            self.current_ratings.get('driveability', 50.0) +
            self.current_ratings.get('setup_window', 50.0) +
            self.current_ratings.get('platform_stability', 50.0)
        ) / 3.0
    
    @property
    def reliability_score(self) -> float:
        """Likelihood of finishing races"""
        return self.current_ratings.get('reliability', 50.0)
    
    @property
    def architecture_tags(self) -> List[str]:
        """Derive architectural characteristics from car stats for parts compatibility"""
        tags = []
        
        # Downforce philosophy
        downforce = self.current_ratings.get('downforce_peak', 50.0)
        if downforce > 65.0:
            tags.append('high_downforce')
        elif downforce < 40.0:
            tags.append('low_downforce')
        
        # Weight distribution
        platform_stability = self.current_ratings.get('platform_stability', 50.0)
        if platform_stability > 65.0:
            tags.append('stable_platform')
        
        # Power delivery
        power_smoothness = self.current_ratings.get('power_delivery_smoothness', 50.0)
        power_output = self.current_ratings.get('power_output', 50.0)
        if power_output > 65.0 and power_smoothness > 60.0:
            tags.append('refined_power')
        elif power_output > 65.0:
            tags.append('aggressive_power')
        
        # Setup sensitivity
        setup_window = self.current_ratings.get('setup_window', 50.0)
        if setup_window > 65.0:
            tags.append('flexible_setup')
        elif setup_window < 40.0:
            tags.append('narrow_setup')
        
        # Aero efficiency
        aero_eff = self.current_ratings.get('aero_efficiency', 50.0)
        drag = self.current_ratings.get('drag', 50.0)
        if aero_eff > 65.0 and drag < 40.0:
            tags.append('low_drag')
        
        # Reliability focus
        reliability = self.current_ratings.get('reliability', 50.0)
        if reliability > 70.0:
            tags.append('reliable')
        
        return tags
    
    def update_ratings(self, base_ratings: Dict[str, float], equipped_parts: Dict[str, 'Part']) -> None:
        """Update car ratings by applying equipped part bonuses to base ratings"""
        # Start with base ratings
        self.current_ratings = base_ratings.copy()
        
        # Get car's architecture tags for compatibility
        arch_tags = self.architecture_tags
        
        # Apply bonuses from each equipped part
        for part_type, part in equipped_parts.items():
            bonuses = part.get_stat_bonuses(arch_tags)
            for car_stat, bonus in bonuses.items():
                if car_stat in self.current_ratings:
                    self.current_ratings[car_stat] += bonus
                    # Clamp to valid range
                    self.current_ratings[car_stat] = max(1.0, min(99.0, self.current_ratings[car_stat]))


@dataclass
class Manufacturer(Entity):
    """~20 stats - procedurally generated from heritage templates"""
    
    # Required base fields 
    name: str = ""
    display_name: str = ""
    age: int = 0
    
    # Manufacturer-specific fields
    manufacturer_id: str = ""
    nationality: str = ""
    heritage_template_id: str = ""
    founded_year: int = 1
    active_tiers: set = field(default_factory=set)  # Which tiers they supply {1, 2, 3}
    current_generation: int = 1  # Latest part generation released
    last_innovation_tick: int = 0  # When they last innovated
    
    # Entity ID tracking
    entity_id: int = 0
    
    @property
    def market_position(self) -> float:
        """Brand strength and market presence"""
        return (
            self.current_ratings.get('brand_prestige', 50.0) * 0.5 +
            self.current_ratings.get('racing_pedigree', 50.0) * 0.3 +
            self.current_ratings.get('financial_stability', 50.0) * 0.2
        )
    
    @property
    def innovation_velocity(self) -> float:
        """Speed of new product development"""
        return (
            self.current_ratings.get('innovation_rate', 50.0) * 0.6 +
            self.current_ratings.get('development_cycle_speed', 50.0) * 0.4
        )


@dataclass
class Part(Entity):
    """~18 stats - physical parts with degradation and obsolescence"""
    
    # Required base fields
    name: str = ""
    display_name: str = ""
    age: int = 0  # Ticks since introduction
    
    # Part-specific fields
    part_id: str = ""
    part_type: str = ""  # "chassis", "engine", "aero_package", etc.
    manufacturer_id: str = ""
    generation: int = 1  # Mk1, Mk2, etc.
    introduction_year: int = 1
    introduction_tick: int = 0
    tier_minimum: int = 1  # Minimum tier to use
    tier_maximum: int = 5  # Maximum tier (complexity gate)
    tier_availability: List[int] = field(default_factory=lambda: [1, 2, 3, 4, 5])  # Which tiers can purchase
    compatibility_tags: List[str] = field(default_factory=list)  # ["high_downforce", "lightweight"]
    regulatory_exposure: Dict[str, float] = field(default_factory=dict)  # Compliance risk vector
    
    # Entity ID tracking
    entity_id: int = 0
    
    # Effectiveness modifier (for obsolescence)
    effectiveness_modifier: float = 1.0
    
    # Installation quality (set when part is equipped - infrastructure-dependent)
    install_quality: float = 100.0  # 0-100, affects effectiveness
    
    def __post_init__(self):
        """Ensure current_ratings is always populated for parts"""
        super().__post_init__()
        # Defensive: ensure current_ratings exists and is populated
        if not self.current_ratings or len(self.current_ratings) == 0:
            if 'Part' in STATS_SCHEMAS:
                self.current_ratings = STATS_SCHEMAS['Part'].copy()
        
        # Defensive: ensure effectiveness_modifier and install_quality are set
        if not hasattr(self, 'effectiveness_modifier') or self.effectiveness_modifier is None:
            self.effectiveness_modifier = 1.0
        if not hasattr(self, 'install_quality') or self.install_quality is None:
            self.install_quality = 100.0
    
    @property
    def performance_score(self) -> float:
        """Effective performance accounting for obsolescence"""
        # Defensive: ensure current_ratings exists
        if not self.current_ratings:
            self.current_ratings = STATS_SCHEMAS.get('Part', {}).copy()
        
        base_performance = self.current_ratings.get('peak_performance', 50.0)
        obsolescence_resistance = self.current_ratings.get('obsolescence_resistance', 50.0)
        
        # Defensive: ensure values are valid floats
        if base_performance is None or not isinstance(base_performance, (int, float)):
            base_performance = 50.0
        if obsolescence_resistance is None or not isinstance(obsolescence_resistance, (int, float)):
            obsolescence_resistance = 50.0
        if self.effectiveness_modifier is None or not isinstance(self.effectiveness_modifier, (int, float)):
            self.effectiveness_modifier = 1.0
            
        obsolescence_penalty = obsolescence_resistance / 100.0
        return base_performance * obsolescence_penalty * self.effectiveness_modifier
    
    @property
    def cost_performance_ratio(self) -> float:
        """Value proposition (performance per maintenance cost)"""
        performance = self.performance_score
        maintenance = max(1.0, self.current_ratings.get('maintenance_cost', 50.0))
        return performance / maintenance
    
    @property
    def is_obsolete(self) -> bool:
        """Check if part is outdated"""
        return self.effectiveness_modifier < 0.7 or self.current_ratings.get('obsolescence_resistance', 50.0) < 30.0
    
    def get_stat_bonuses(self, car_architecture_tags: List[str]) -> Dict[str, float]:
        """Calculate stat bonuses this part provides to car based on compatibility and condition"""
        bonuses = {}
        
        # Base effectiveness from obsolescence and condition
        effectiveness = self.effectiveness_modifier
        
        # Installation quality modifier (infrastructure-dependent)
        # install_quality ranges 0-100, modifies effectiveness by ±10%
        install_modifier = 0.9 + (self.install_quality / 1000.0)  # Range: 0.9 to 1.0
        
        # Compatibility modifier: check if car architecture matches part tags
        compatibility_bonus = 1.0
        if self.compatibility_tags:
            matching_tags = set(self.compatibility_tags) & set(car_architecture_tags)
            compatibility_bonus = 1.0 + (0.05 * len(matching_tags))  # +5% per matching tag
        
        # Calculate final effectiveness
        final_effectiveness = effectiveness * install_modifier * compatibility_bonus
        
        # Map part stats to car stats based on part type
        stat_map = self._get_part_to_car_stat_map()
        
        for part_stat, car_stats in stat_map.items():
            part_value = self.current_ratings.get(part_stat, 50.0)
            # Calculate bonus as deviation from baseline (50.0)
            bonus = (part_value - 50.0) * final_effectiveness * 0.15  # 15% transfer rate
            
            for car_stat in car_stats:
                bonuses[car_stat] = bonuses.get(car_stat, 0.0) + bonus
        
        return bonuses
    
    def _get_part_to_car_stat_map(self) -> Dict[str, List[str]]:
        """Define which part stats affect which car stats"""
        # Default mappings - override for specific part types
        base_map = {
            'peak_performance': ['aero_efficiency', 'power_output', 'mechanical_grip'],
            'reliability': ['reliability'],
            'weight': ['platform_stability'],  # Lower weight improves stability
            'efficiency': ['aero_efficiency', 'power_delivery_smoothness'],
            'setup_window': ['setup_window', 'driveability'],
            'thermal_management': ['thermal_tolerance'],
        }
        
        # Part-type specific additions
        if self.part_type == 'engine':
            base_map['peak_performance'] = ['power_output', 'power_delivery_smoothness']
            base_map['efficiency'] = ['power_delivery_smoothness']
        elif self.part_type == 'aero_package':
            base_map['peak_performance'] = ['aero_efficiency', 'downforce_peak']
            base_map['efficiency'] = ['aero_efficiency', 'drag']
        elif self.part_type == 'chassis':
            base_map['peak_performance'] = ['platform_stability', 'mechanical_grip']
            base_map['weight'] = ['platform_stability', 'driveability']
        elif self.part_type == 'suspension':
            base_map['peak_performance'] = ['mechanical_grip', 'platform_stability']
            base_map['setup_window'] = ['setup_window', 'ride_height_sensitivity']
        elif self.part_type == 'tires':
            base_map['peak_performance'] = ['mechanical_grip', 'downforce_consistency']
        elif self.part_type == 'brakes':
            base_map['peak_performance'] = ['driveability', 'balance_sensitivity']
            base_map['thermal_management'] = ['thermal_tolerance']
        elif self.part_type == 'cooling':
            base_map['thermal_management'] = ['thermal_tolerance', 'reliability']
            base_map['weight'] = ['platform_stability']
        elif self.part_type == 'electronics':
            base_map['peak_performance'] = ['power_delivery_smoothness', 'driveability']
            base_map['reliability'] = ['reliability']
        elif self.part_type == 'transmission':
            base_map['peak_performance'] = ['power_delivery_smoothness', 'mechanical_grip']
            base_map['reliability'] = ['reliability', 'component_wear_rate']
        
        return base_map
    
    def apply_race_degradation(self, race_intensity: float = 1.0) -> None:
        """Apply wear and tear from race usage"""
        # Base degradation rate
        base_degradation = 0.01 * race_intensity  # 1% per race
        
        # Reliability stat affects degradation rate
        reliability_factor = self.current_ratings.get('reliability', 50.0) / 50.0
        degradation_rate = base_degradation / reliability_factor
        
        # Reduce effectiveness modifier
        self.effectiveness_modifier = max(0.0, self.effectiveness_modifier - degradation_rate)
        
        # Age the part
        self.age += 1
        
        # Obsolescence increases with age
        if self.age > 10:  # After 10 races
            obsolescence_decay = (self.age - 10) * 0.5
            obs_resist = self.current_ratings.get('obsolescence_resistance', 50.0)
            self.current_ratings['obsolescence_resistance'] = max(0.0, obs_resist - obsolescence_decay)


# ============================================================
# SECTION 1.5: Contract & Sponsorship System
# ============================================================

@dataclass
class Contract:
    """Contract binding entity to team"""
    entity_id: int
    entity_name: str
    team_name: str
    role: str  # "driver", "engineer", "mechanic", etc.
    start_day: int  # Sim day when contract started
    duration_days: int  # Length in sim days (180-720 typical)
    base_salary: int  # Per-season salary
    performance_clauses: Dict[str, Any] = field(default_factory=dict)  # {"points_bonus": 10000, "wins_bonus": 50000, "constructor_pos_bonus": {1: 100000, 2: 50000}}
    exit_clauses: Dict[str, Any] = field(default_factory=dict)  # {"buyout_cost": 100000, "performance_escape": True, "relegation_escape": True}
    seasons_duration: int = 2  # Contract length in racing seasons (1-5)
    signing_bonus: int = 0  # One-time payment on contract signing
    
    # Negotiation tracking
    negotiation_round: int = 0  # Current negotiation round (0 = initial offer)
    last_offer_rejected: bool = False  # Was the last offer rejected?
    
    # Poaching system fields (Phase 2 upgrade)
    open_to_offers: bool = False  # Set by morale, team performance
    poaching_protection_until: int = 0  # Lock period after signing (in days)
    buyout_clause_fixed: Optional[int] = None  # Explicit buyout amount (overrides calculated)
    loyalty_factor: float = 1.0  # Affects buyout acceptance chance
    
    # Contract expiry notification tracking
    _notification_sent_at: Dict[int, int] = field(default_factory=dict)  # {threshold_days: tick_sent}
    
    @staticmethod
    def seasons_to_days(seasons: int, days_per_season: int = 182) -> int:
        """Convert racing seasons to days (default ~26 weeks per season)"""
        return seasons * days_per_season
    
    @staticmethod
    def days_to_seasons(days: int, days_per_season: int = 182) -> int:
        """Convert days to racing seasons"""
        return max(1, round(days / days_per_season))
    
    def is_expired(self, current_day: int) -> bool:
        """Check if contract has expired"""
        return current_day >= (self.start_day + self.duration_days)
    
    def days_remaining(self, current_day: int) -> int:
        """Days until contract expires"""
        return max(0, (self.start_day + self.duration_days) - current_day)
    
    def seasons_remaining(self, current_day: int, days_per_season: int = 182) -> float:
        """Seasons remaining (fractional)"""
        days_left = self.days_remaining(current_day)
        return days_left / days_per_season
    
    def total_value(self) -> int:
        """Calculate total contract value (salary + signing bonus, excluding performance clauses)"""
        return (self.base_salary * self.seasons_duration) + self.signing_bonus
    
    def annual_average_value(self) -> int:
        """Average annual value of contract"""
        if self.seasons_duration == 0:
            return self.base_salary
        return self.total_value() // self.seasons_duration
    
    def is_poachable(self, current_day: int) -> bool:
        """Check if contract allows poaching attempts"""
        # Protected period still active
        if current_day < self.poaching_protection_until:
            return False
        
        # Contract nearly expired (< 14 days) - just wait it out
        if self.days_remaining(current_day) < 14:
            return False
        
        return True
    
    def calculate_buyout_amount(self, team_tier: int, current_day: int) -> int:
        """Calculate buyout amount for this contract"""
        # Use fixed clause if exists
        if self.buyout_clause_fixed:
            return self.buyout_clause_fixed
        
        # Otherwise use tier-based percentage of remaining contract value
        days_left = self.days_remaining(current_day)
        seasons_left = self.days_to_seasons(days_left)
        remaining_value = self.base_salary * seasons_left
        
        buyout_pct = BUYOUT_PCT_BY_TIER.get(team_tier, 0.3)
        return int(remaining_value * buyout_pct)


@dataclass
class Sponsorship:
    """
    Sponsorship deal providing income with rich behavioral profile.
    Extended with procedural generation support - preserves old fields for compatibility.
    """
    # Core identity (legacy fields)
    sponsor_name: str
    tier: str  # "title", "primary", "associate" OR financial tier string
    base_payment_per_season: int
    performance_multipliers: Dict[str, float] = field(default_factory=dict)  # {"championship_position": 1.5}
    duration_seasons: int = 1
    reputation_threshold: int = 0  # Min team reputation to retain (legacy)
    seasons_active: int = 0  # Track how long sponsor has been active
    warning_issued: bool = False  # Track if underperformance warning sent
    
    # Extended profile fields (new - procedurally generated)
    sponsor_id: Optional[str] = None  # Unique ID for tracking
    industry: Optional[str] = None  # Industry enum value
    sub_industry: Optional[str] = None  # SubIndustry enum value
    financial_tier: Optional[str] = None  # FinancialTier enum value (micro/regional/national/global)
    
    # Behavioral profile (JSON serialized from ftb_sponsors structures)
    brand_profile_json: Optional[str] = None  # BrandProfile: tone, prestige, risk_appetite, ethics
    contract_behavior_json: Optional[str] = None  # ContractBehavior: loyalty, pressure_threshold, perf/rep dependency
    activation_style_json: Optional[str] = None  # ActivationStyle: visibility, demands (podiums/media/driver)
    narrative_hooks_json: Optional[str] = None  # NarrativeHooks: scandal_risk, bailout_savior, hostile_exit, legacy
    
    # Contract lifecycle tracking
    confidence: float = 100.0  # 0-100, current sponsor satisfaction
    performance_history: List[float] = field(default_factory=list)  # Historical confidence scores
    contract_type: str = "season_partnership"  # "fixed_short" (3-10 races) or "season_partnership"
    evaluation_cadence: int = 10  # Ticks between performance evaluations (increased fro 5 to reduce swings)
    signed_tick: int = 0  # When contract was signed
    last_evaluated_tick: int = 0  # Last performance check
    
    # Bailout tracking
    has_bailed_out: bool = False  # Whether this sponsor has ever bailed out this team
    bailout_count: int = 0  # Number of times this sponsor has bailed out (should be max 1)
    
    # Strategic constraints
    exclusivity_clauses: List[str] = field(default_factory=list)  # ["no_competitor_engines", "exclusive_tire_deal"]
    
    # Infrastructure requirements (tier-gated expectations)
    infrastructure_demands: Dict[str, float] = field(default_factory=dict)  # {"factory_quality": 70.0, "data_analysis": 60.0}
    facility_tour_events_required: int = 0  # Number of facility tour events per season
    
    # Payment tracking
    total_paid_this_season: int = 0
    last_payment_tick: int = 0


@dataclass
class RegulationChange:
    """Major regulation change affecting all teams"""
    epoch_day: int  # When it takes effect
    announced_day: int  # When teams were notified
    changes: Dict[str, str] = field(default_factory=dict)  # {"aero_limit": "reduced_by_20pct"}
    stat_resets: List[str] = field(default_factory=list)  # ["aero_efficiency", "downforce_peak"]
    adaptation_difficulty: float = 0.5  # 0-1, affects how much teams lose


@dataclass
class Penalty:
    """Race penalty or steward decision"""
    race_id: int
    team_name: str
    driver_name: str
    penalty_type: str  # "time_penalty", "grid_penalty", "disqualification", "points_deduction", "fine"
    magnitude: int  # Seconds, grid positions, points, or dollars
    reason: str
    issued_by: str = "Stewards"
    appealable: bool = False
    game_day: int = 0  # Track when penalty was issued for repeat offender detection


@dataclass
class RDProject:
    """R&D project with multi-tick resolution (Phase 4)"""
    project_id: str
    project_name: str
    project_type: str  # "part_development", "car_upgrade", "technology_research"
    team_name: str
    
    # Costs and duration
    total_cost: float
    duration_ticks: int  # How many ticks to complete
    
    # Progress tracking
    started_tick: int
    progress_ticks: int = 0  # Current progress
    completed: bool = False
    cancelled: bool = False
    
    # Success probability (influenced by engineers)
    base_success_rate: float = 0.7  # 70% base success
    current_success_rate: float = 0.7  # Modified by engineer stats
    
    # Outcomes
    target_stat: str = ""  # Which Car stat to improve (for upgrades)
    target_improvement: float = 0.0  # How much to improve
    generates_part: bool = False  # If True, generates a custom part on success
    part_type: str = ""  # Type of part to generate
    
    # Metadata
    description: str = ""
    risk_level: str = "medium"  # "low", "medium", "high"
    assigned_engineer_ids: List[str] = field(default_factory=list)  # Engineers assigned to project


@dataclass
class UpgradePackage:
    """Bundled upgrade package (Phase 5)"""
    upgrade_id: str
    upgrade_name: str
    tier_availability: List[int]  # Which tiers can purchase
    
    # Cost
    cost: float
    
    # Stat improvements (applied to Car)
    stat_improvements: Dict[str, float] = field(default_factory=dict)  # {"aero_efficiency": 5.0, "downforce_peak": 4.0}
    
    # Requirements
    required_parts: List[str] = field(default_factory=list)  # Part types that must be equipped
    incompatible_upgrades: List[str] = field(default_factory=list)  # Upgrade IDs that conflict
    min_car_stat: Dict[str, float] = field(default_factory=dict)  # Min car stats required {"reliability": 40.0}
    
    # Metadata
    description: str = ""
    category: str = "performance"  # "performance", "reliability", "driveability", "complete_replatform"


@dataclass
class Track:
    """Racing circuit with characteristics that affect race simulation"""
    track_id: str
    name: str
    prestige_rating: int  # 1-10 (10 = legendary venue)
    length_km: float  # Track length in kilometers
    corner_count: int  # Number of corners
    lap_count: int  # Laps for a race
    
    # Track type and characteristics
    track_type: str = "road"  # "road", "street", "oval"
    characteristics: List[str] = field(default_factory=list)  # ["high_speed", "technical", etc.]
    
    # Track characteristics (impact simulation)
    aero_demand: str = "medium"  # "high", "medium", "low"
    mechanical_grip_emphasis: str = "medium"  # "high", "medium", "low"
    power_sensitivity: str = "medium"  # "high", "medium", "low"
    tire_stress: str = "medium"  # "high", "medium", "low"
    
    # Tier accessibility (which tiers can race here)
    min_tier: int = 1  # Minimum tier (1 = Grassroots)
    max_tier: int = 5  # Maximum tier (5 = Formula Z)
    
    # Lore
    track_character: str = ""  # Brief description
    
    def get_stat_modifiers(self) -> Dict[str, float]:
        """Return stat weight modifiers based on track characteristics"""
        modifiers = {}
        
        # Aero demand affects aero-related stats
        if self.aero_demand == "high":
            modifiers['aero_efficiency_weight'] = 1.3
            modifiers['downforce_peak_weight'] = 1.2
        elif self.aero_demand == "low":
            modifiers['aero_efficiency_weight'] = 0.8
            modifiers['power_output_weight'] = 1.2
        
        # Mechanical grip for handling-focused tracks
        if self.mechanical_grip_emphasis == "high":
            modifiers['driveability_weight'] = 1.2
            modifiers['spatial_awareness_weight'] = 1.2
        
        # Power sensitivity for power circuits
        if self.power_sensitivity == "high":
            modifiers['power_output_weight'] = 1.3
            modifiers['low_fuel_performance_weight'] = 1.2
        
        # Tire stress affects tire management importance
        if self.tire_stress == "high":
            modifiers['tire_management_weight'] = 1.3
            modifiers['tire_modeling_weight'] = 1.2  # Strategist stat
        
        return modifiers


@dataclass
class LapData:
    """Single lap telemetry and position data"""
    lap_number: int
    driver_name: str
    team_name: str
    lap_time: float  # Seconds
    position: int
    tire_compound: str  # "soft", "medium", "hard"
    tire_age: int  # Laps on this set
    gap_to_leader: float  # Seconds behind leader
    gap_to_ahead: float  # Seconds behind car ahead
    sector_1: float  # Sector 1 time
    sector_2: float  # Sector 2 time
    sector_3: float  # Sector 3 time


@dataclass
class RaceEventRecord:
    """Discrete race event (overtake, crash, pit, penalty)"""
    lap_number: int
    event_type: str  # "overtake", "crash", "mechanical_dnf", "pit_stop", "penalty"
    involved_drivers: List[str]  # Driver names
    description: str
    position_change: Dict[str, int] = field(default_factory=dict)  # Driver -> new position
    metadata: Dict[str, Any] = field(default_factory=dict)  # Additional event data


@dataclass
class RaceResult:
    """Complete race result with lap-by-lap data"""
    race_id: str  # Unique race identifier
    league_id: str
    league_name: str
    track_id: str
    track_name: str
    season: int
    round_number: int
    
    # Race data
    laps: List[LapData] = field(default_factory=list)
    race_events: List[RaceEventRecord] = field(default_factory=list)
    
    # Final classification
    final_positions: List[Tuple[str, str, str]] = field(default_factory=list)  # (driver_name, team_name, status)
    fastest_lap: Optional[Tuple[str, float]] = None  # (driver, time)
    
    # Telemetry summary (derived)
    telemetry: Dict[str, Dict[str, float]] = field(default_factory=dict)  # driver -> metrics


@dataclass
class ManagerCareerStats:
    """Track player manager career statistics and history"""
    # Racing Results
    seasons_managed: int = 0
    total_races: int = 0
    wins: int = 0
    podiums: int = 0
    poles: int = 0
    championships: int = 0
    
    # Career History
    teams_managed: List[str] = field(default_factory=list)  # Team names in chronological order
    best_championship_finish: int = 999  # Best position (1st = 1, etc.)
    career_start_year: int = 1
    
    # Financial Management
    total_budget_managed: float = 0.0  # Cumulative cash managed across all teams
    sponsorships_landed: int = 0
    avg_budget_growth_rate: float = 0.0  # % per season
    
    # Personnel Management
    drivers_developed: List[str] = field(default_factory=list)  # Drivers who improved significantly under management
    staff_hired: int = 0
    staff_fired: int = 0
    avg_staff_retention_years: float = 0.0
    
    # Season History (for detailed career tab)
    season_history: List[Dict[str, Any]] = field(default_factory=list)  # [{year, team, pos, wins, podiums}, ...]


# ============================================================
# SECTION 2: Event System
# ============================================================

@dataclass
class SimEvent:
    """Atomic unit of simulation change"""
    event_type: str  # "time", "structural", "outcome", "opportunity", "pressure", "consequence"
    category: str  # "race_result", "contract_expiry", "financial_stress", etc.
    ts: int  # Simulation timestamp
    priority: float  # For audio narration importance
    severity: str = "info"  # Severity level for event routing
    description: str = ""
    data: Dict[str, Any] = field(default_factory=dict)
    event_id: int = 0  # Auto-incrementing unique identifier
    caused_by: Optional[int] = None  # Parent event ID for causality tracking
    seen_by_continuous_narrator: bool = False  # Track if continuous narrator processed this
    seen_by_beat_builder: bool = False  # Track if beat builder processed this


@dataclass
class DecisionOption:
    """Single option within a decision"""
    id: str
    label: str
    cost: float = 0.0
    description: str = ""
    consequence_preview: str = ""


@dataclass
class DecisionEvent:
    """
    Multi-option decision requiring player response.
    Blocks certain actions until resolved.
    """
    decision_id: str
    category: str  # "ownership_ultimatum", "fire_sale", "staff_poaching", etc.
    prompt: str  # Main decision question
    options: List[DecisionOption]
    deadline_tick: int  # Auto-resolve if unresolved by this tick
    auto_resolve_option_id: str  # Which option to pick on timeout
    created_tick: int
    resolved: bool = False
    chosen_option_id: Optional[str] = None


@dataclass
class DelegationFocus:
    """
    Player's current delegation focus intent.
    Translates high-level goals into temporary stat modifiers for the player's manager entity.
    """
    focus_text: str  # Free-form intent e.g., "Stabilize finances", "Develop young talent"
    active_modifiers: Dict[str, float]  # Stat name -> adjustment value (±10-20 typically)
    applied_at: int  # Tick when focus was set
    narrative_summary: str = ""  # Optional: LLM-generated summary of what this focus means


class SimEventBus:
    """Priority queue for simulation events"""
    
    def __init__(self):
        self._queue: List[SimEvent] = []
        self._history: List[SimEvent] = []
    
    def enqueue(self, event: SimEvent) -> None:
        """Add event to queue, sorted by priority"""
        self._queue.append(event)
        self._queue.sort(key=lambda e: e.priority, reverse=True)
        self._history.append(event)
    
    def dequeue(self) -> Optional[SimEvent]:
        """Pop highest priority event"""
        return self._queue.pop(0) if self._queue else None
    
    def peek_next(self) -> Optional[SimEvent]:
        """Look at next event without removing"""
        return self._queue[0] if self._queue else None
    
    def clear(self) -> None:
        """Clear all queued events"""
        self._queue.clear()


# Event taxonomy constants
TIME_EVENTS = ["advance_day", "advance_week", "enter_race_weekend", "exit_race_weekend", 
               "enter_offseason", "regulation_cycle"]

STRUCTURAL_EVENTS = ["new_car", "regulation_change", "team_entry", "team_exit", 
                     "engine_supplier_change"]

OUTCOME_EVENTS = ["race_result", "championship_result", "dev_success", "dev_failure",
                  "financial_gain", "financial_loss", "contract_signed", "contract_break",
                  "sponsor_signed", "sponsor_payment", "sponsor_renewed", "sponsor_departed"]

OPPORTUNITY_EVENTS = ["contract_expiry", "job_listing", "sponsor_offer", 
                     "staff_available", "regulation_loophole", "sponsor_renewal_offer"]

PRESSURE_EVENTS = ["budget_crisis", "morale_low", "reputation_critical", "sponsor_patience_warning"]

CONSEQUENCE_EVENTS = ["relegation", "promotion", "sponsor_terminated", "sponsor_hostile_exit", "sponsor_scandal_exit"]


# ============================================================
# SECTION 3: Economic System
# ============================================================

# Facility tier mapping for sell value calculation
FACILITY_TIER_MAP = {
    # Tier 1 - Grassroots
    'basic_simulator': 1, 'data_logging': 1, 'workshop': 1, 'transport_logistics': 1,
    'engineering_desk': 1, 'driver_fitness': 1, 'scouting_network': 1,
    # Tier 2 - Formula V
    'improved_simulator': 2, 'data_analysis': 2, 'fabrication': 2,
    'maintenance_program': 2, 'engineering_roles': 2, 'fitness_program': 2,
    # Tier 4 - Formula Y
    'wind_tunnel_entry': 4, 'cfd_limited': 4, 'factory_quality': 4, 'reliability_qa': 4,
    'rd_department': 4, 'specialized_teams': 4, 'driver_development': 4, 'commercial_department': 4,
    # Tier 5 - Formula Z
    'wind_tunnel_advanced': 5, 'cfd_advanced': 5, 'regulation_analysis': 5,
    'political_capital_infrastructure': 5, 'redundant_infrastructure': 5,
    'talent_pipeline': 5, 'media_control': 5,
    # Legacy keys
    'wind_tunnel': 4, 'simulator': 2,
}

# Recovery ratios when selling facilities (lower for elite facilities)
FACILITY_SELL_RECOVERY = {
    1: 0.65,  # Grassroots: higher liquidity
    2: 0.55,  # Formula V
    4: 0.45,  # Formula Y
    5: 0.35,  # Formula Z (harder to liquidate elite assets)
}

# Base infrastructure upgrade cost per quality point (tier-aware)
FACILITY_BASE_COST_PER_POINT = {
    1: 300.0,    # Grassroots
    2: 1200.0,   # Formula V
    4: 6500.0,   # Formula Y
    5: 15000.0,  # Formula Z
}


def get_facility_base_cost_per_point(facility: str) -> float:
    facility_tier = FACILITY_TIER_MAP.get(facility, 1)
    return FACILITY_BASE_COST_PER_POINT.get(facility_tier, 1200.0)

# Infrastructure upkeep cost tiers (per tick)
INFRASTRUCTURE_UPKEEP_COST = {
    # === GRASSROOTS BASELINE (Tier 1 - Low upkeep: $5-10/quality point) ===
    'basic_simulator': lambda quality: quality * 6.0,
    'data_logging': lambda quality: quality * 5.0,
    'workshop': lambda quality: quality * 8.0,
    'transport_logistics': lambda quality: quality * 7.0,
    'engineering_desk': lambda quality: quality * 5.0,
    'driver_fitness': lambda quality: quality * 6.0,
    'scouting_network': lambda quality: quality * 5.0,
    
    # === FORMULA V (Tier 2 - Medium upkeep: $10-20/quality point) ===
    'improved_simulator': lambda quality: quality * 12.0,
    'data_analysis': lambda quality: quality * 10.0,
    'fabrication': lambda quality: quality * 15.0,
    'maintenance_program': lambda quality: quality * 8.0,
    'engineering_roles': lambda quality: quality * 12.0,
    'fitness_program': lambda quality: quality * 10.0,
    
    # === FORMULA Y (Tier 4 - High upkeep: $30-60/quality point) ===
    'wind_tunnel_entry': lambda quality: quality * 45.0,
    'cfd_limited': lambda quality: quality * 35.0,
    'factory_quality': lambda quality: quality * 30.0,  # Keep existing key
    'reliability_qa': lambda quality: quality * 25.0,
    'rd_department': lambda quality: quality * 40.0,
    'specialized_teams': lambda quality: quality * 35.0,
    'driver_development': lambda quality: quality * 30.0,
    'commercial_department': lambda quality: quality * 20.0,
    
    # === FORMULA Z (Tier 5 - Extreme upkeep: $80-150/quality point) ===
    'wind_tunnel_advanced': lambda quality: quality * 120.0,
    'cfd_advanced': lambda quality: quality * 100.0,
    'regulation_analysis': lambda quality: quality * 80.0,
    'political_capital_infrastructure': lambda quality: quality * 90.0,
    'redundant_infrastructure': lambda quality: quality * 110.0,
    'talent_pipeline': lambda quality: quality * 95.0,
    'media_control': lambda quality: quality * 85.0,
    
    # Legacy compatibility (old keys)
    'wind_tunnel': lambda quality: quality * 45.0,
    'simulator': lambda quality: quality * 12.0,
}

# Suggested salary ranges per entity type (annual, divided by ~50 ticks/year)
SALARY_BASE = {
    'Driver': 200.0,       # $200/tick base (~$73k/year at rating 50, before tier/ego modifiers)
    'Engineer': 100.0,     # $100/tick base (~$36.5k/year at rating 50, before tier modifier)
    'Mechanic': 80.0,      # $80/tick base (~$29k/year at rating 50, before tier modifier)
    'Strategist': 120.0,   # $120/tick base (~$44k/year at rating 50, before tier modifier)
    'AIPrincipal': 150.0,  # $150/tick base (~$55k/year at rating 50, before tier modifier)
}

# Tier-based salary multipliers (reduce cost pressure at lower tiers)
TIER_SALARY_MULTIPLIER = {
    1: 0.75,   # T1 Grassroots: 25% salary reduction
    2: 0.9,    # T2 Formula V: 10% salary reduction
    3: 0.9,    # T3 Formula X: 10% salary reduction
    4: 1.0,    # T4 Formula Y: Standard rates
    5: 1.0     # T5 Formula Z: Standard rates
}

# Buyout payout percentages by tier (higher tiers -> more protection)
BUYOUT_PCT_BY_TIER = {
    1: 0.10,
    2: 0.20,
    3: 0.30,
    4: 0.45,
    5: 0.60
}

def _clamp(value: float, low: float, high: float) -> float:
    return max(low, min(high, value))

def estimate_salary_expectation(entity: 'Entity', team_tier: Optional[int] = None, fired: bool = False) -> int:
    role = type(entity).__name__
    base = float(SALARY_BASE.get(role, 100.0))
    rating = float(getattr(entity, 'overall_rating', 50.0))
    salary = base * (rating / 50.0)

    if role == "Driver":
        ego = float(getattr(entity, 'ego', 50.0))
        ego_factor = 0.9 + (_clamp(ego, 0.0, 100.0) / 100.0) * 0.4
        salary *= ego_factor

    if team_tier:
        salary *= TIER_SALARY_MULTIPLIER.get(team_tier, 1.0)

    if fired:
        salary *= 1.2

    return max(0, int(salary))

def calculate_contract_buyout(contract: 'Contract', team_tier: int, current_day: int) -> int:
    if not contract:
        return 0

    days_remaining = contract.days_remaining(current_day)
    if days_remaining <= 0:
        return 0

    seasons_remaining = contract.seasons_remaining(current_day)
    remaining_value = contract.base_salary * seasons_remaining
    payout_pct = BUYOUT_PCT_BY_TIER.get(team_tier, 0.2)
    role = str(contract.role).lower()
    role_multiplier = {
        'driver': 1.0,
        'engineer': 0.8,
        'mechanic': 0.7,
        'strategist': 0.9,
        'aiprincipal': 1.0,
        'principal': 1.0
    }.get(role, 0.85)
    buyout = remaining_value * payout_pct * role_multiplier

    clause_buyout = contract.exit_clauses.get('buyout_cost', 0) if contract.exit_clauses else 0
    return int(max(buyout, clause_buyout))

# Infrastructure impact coefficients - tunable for balance
INFRASTRUCTURE_EFFECTS = {
    'entity_growth_multiplier': 0.002,      # +20% at quality 70 (0.002 * 20 = 0.04 per point above 50)
    'entity_decay_reduction': 0.004,        # -40% at quality 70
    'rd_success_bonus': 0.001,              # +10% at quality 100  
    'rd_duration_reduction': 0.002,         # -20% at quality 100
    'part_install_variance': 0.10,          # ±10% effectiveness
    'sponsor_confidence_weight': 0.15,      # ±15% confidence
    'ai_upgrade_budget_pct': 0.20,          # 20% of free cash
    'facility_decay_per_season': 1.5,       # Quality lost per season (slowed by maintenance_program)
    'direct_upgrade_cost_exponent': 1.8,    # Cost scaling: base * (quality/50)^1.8
}

@dataclass
class IncomeSource:
    """Represents an income stream"""
    name: str
    amount: float
    frequency: str  # "per_race", "per_season", "monthly"


class Budget:
    """Money-based constraint system"""
    
    def __init__(self, cash: float = 100000.0):
        self.cash = cash
        self.burn_rate = 0.0  # Per sim-tick (generic expenses)
        self.committed_spend: List[Tuple[int, float]] = []  # (tick_due, amount)
        self.income_streams: List[IncomeSource] = []
        
        # Staff salary tracking (entity: salary_per_tick)
        self.staff_salaries: Dict[str, float] = {}
        
        # Bankruptcy tracking for ML economic realism
        self.consecutive_negative_ticks = 0
        self.bankruptcy_threshold = -50000.0  # $50k debt limit
        self.bankruptcy_tick_limit = 3  # Must maintain negative for 3 ticks to fold
    
    def can_afford(self, cost: float) -> bool:
        """Check if action is financially legal"""
        return self.cash >= cost
    
    def commit(self, amount: float, duration: int) -> None:
        """Commit to future obligation"""
        self.committed_spend.append((duration, amount))
    
    def advance_tick(self, current_tick: int) -> None:
        """Apply burn rate and resolve commitments"""
        self.cash -= self.burn_rate
        
        # Resolve due commitments
        due = [amt for tick, amt in self.committed_spend if tick <= current_tick]
        for amt in due:
            self.cash -= amt
        self.committed_spend = [(t, amt) for t, amt in self.committed_spend 
                               if t > current_tick]
    
    def calculate_staff_payroll(self) -> float:
        """Calculate total staff payroll per tick"""
        return sum(self.staff_salaries.values())
    
    def add_staff_salary(self, entity_name: str, salary: float) -> None:
        """Add or update staff salary"""
        self.staff_salaries[entity_name] = salary
    
    def remove_staff_salary(self, entity_name: str) -> None:
        """Remove staff salary when entity leaves"""
        if entity_name in self.staff_salaries:
            del self.staff_salaries[entity_name]
    
    def check_bankruptcy(self) -> bool:
        """Check if team is bankrupt (ML economic realism)"""
        if self.cash < self.bankruptcy_threshold:
            self.consecutive_negative_ticks += 1
            return self.consecutive_negative_ticks >= self.bankruptcy_tick_limit
        else:
            self.consecutive_negative_ticks = 0
            return False
    
    def forecast_cash_flow(self, ticks_ahead: int = 6, current_tick: int = 0) -> float:
        """Project cash position N ticks into future (ML economic realism)"""
        projected_cash = self.cash
        
        # Project expenses
        for _ in range(ticks_ahead):
            # Burn rate per tick
            projected_cash -= self.burn_rate
            
            # Staff salaries (assume continued employment)
            projected_cash -= self.calculate_staff_payroll()
        
        # Project committed spends
        future_commitments = sum(amt for tick, amt in self.committed_spend 
                                if current_tick < tick <= current_tick + ticks_ahead)
        projected_cash -= future_commitments
        
        # Project income streams (simplified - assume monthly sponsor payments)
        monthly_income = sum(inc.amount / 12 for inc in self.income_streams 
                           if inc.frequency == "monthly")
        months_ahead = ticks_ahead / 30  # Rough approximation
        projected_cash += monthly_income * months_ahead
        
        return projected_cash
    
    def will_cause_bankruptcy(self, additional_cost: float, current_tick: int = 0) -> bool:
        """Check if spending this amount would lead to forecasted bankruptcy"""
        forecast = self.forecast_cash_flow(ticks_ahead=6, current_tick=current_tick)
        return (forecast - additional_cost) < self.bankruptcy_threshold


class Action:
    """Base class for all managerial actions"""
    
    def __init__(self, name: str, cost: float, opportunity_cost: Optional[str] = None, target: Any = None):
        self.name = name
        self.cost = cost
        self.opportunity_cost = opportunity_cost
        self.target = target  # Entity ID, role name, or other action parameter
    
    def is_legal(self, budget: Budget, team_state: Any) -> bool:
        """Check if action is legal given current constraints"""
        return budget.can_afford(self.cost)


# ============================================================
# SECTION 4: State Container
# ============================================================

class Team:
    """Team state container"""
    
    def __init__(self, name: str):
        self.name = name
        self.team_id = f"{name.lower().replace(' ', '_')}_{id(self)}"
        self.budget = Budget()
        self.drivers: List[Driver] = []
        self.engineers: List[Engineer] = []
        self.mechanics: List[Mechanic] = []
        self.strategist: Optional[Strategist] = None
        self.principal: Optional[AIPrincipal] = None  # None if player-controlled
        self.car: Car = Car(name=f"{name} Car")
        
        # Infrastructure system - organized by tier and domain
        # Quality values: 0-100, with RNG-based initialization for baseline facilities
        # All teams start with a limited Grassroots baseline
        # RNG seeded by team name for reproducibility
        infra_rng = random.Random(hash(name))
        
        self.infrastructure: Dict[str, float] = {
            # === GRASSROOTS BASELINE (Tier 1 - everyone starts with these) ===
            # Testing & Development - specialized equipment, starts degraded (0-15)
            'basic_simulator': float(infra_rng.randint(0, 15)),
            'basic_simulator_unlocked': True,
            'data_logging': float(infra_rng.randint(0, 15)),
            'data_logging_unlocked': True,
            
            # Production & Operations - operational facilities (25-45)
            'workshop': float(infra_rng.randint(25, 45)),
            'workshop_unlocked': True,
            'transport_logistics': float(infra_rng.randint(25, 45)),
            'transport_logistics_unlocked': True,
            
            # Personnel & Organization - desk space operational (25-45), specialized systems degraded (0-15)
            'engineering_desk': float(infra_rng.randint(25, 45)),
            'engineering_desk_unlocked': True,
            'driver_fitness': float(infra_rng.randint(0, 15)),
            'driver_fitness_unlocked': True,
            'scouting_network': float(infra_rng.randint(0, 15)),
            'scouting_network_unlocked': True,
            
            # === FORMULA V (Tier 2 unlocks) ===
            # Testing & Development
            'improved_simulator': 0.0,
            'improved_simulator_unlocked': False,
            'data_analysis': 0.0,
            'data_analysis_unlocked': False,
            
            # Production & Operations
            'fabrication': 0.0,
            'fabrication_unlocked': False,
            'maintenance_program': 0.0,
            'maintenance_program_unlocked': False,
            
            # Personnel & Organization  
            'engineering_roles': 0.0,
            'engineering_roles_unlocked': False,
            'fitness_program': 0.0,
            'fitness_program_unlocked': False,
            
            # === FORMULA Y (Tier 4 unlocks - arms race begins) ===
            # Testing & Development
            'wind_tunnel_entry': 0.0,
            'wind_tunnel_entry_unlocked': False,
            'cfd_limited': 0.0,
            'cfd_limited_unlocked': False,
            
            # Production & Operations
            'factory_quality': 0.0,  # Keep existing key for compatibility
            'factory_unlocked': False,  # Must unlock at tier 4
            'reliability_qa': 0.0,
            'reliability_qa_unlocked': False,
            
            # Personnel & Organization
            'rd_department': 0.0,
            'rd_department_unlocked': False,
            'specialized_teams': 0.0,
            'specialized_teams_unlocked': False,
            'driver_development': 0.0,
            'driver_development_unlocked': False,
            'commercial_department': 0.0,
            'commercial_department_unlocked': False,
            
            # === FORMULA Z (Tier 5 unlocks - different mode of existence) ===
            # Testing & Development
            'wind_tunnel_advanced': 0.0,
            'wind_tunnel_advanced_unlocked': False,
            'cfd_advanced': 0.0,
            'cfd_advanced_unlocked': False,
            
            # Strategic & Political
            'regulation_analysis': 0.0,
            'regulation_analysis_unlocked': False,
            'political_capital_infrastructure': 0.0,
            'political_capital_infrastructure_unlocked': False,
            
            # Operational Excellence
            'redundant_infrastructure': 0.0,
            'redundant_infrastructure_unlocked': False,
            'talent_pipeline': 0.0,
            'talent_pipeline_unlocked': False,
            'media_control': 0.0,
            'media_control_unlocked': False,
            
            # Legacy compatibility (keep old keys for backward compat)
            'wind_tunnel': 0.0,
            'wind_tunnel_unlocked': False,
            'simulator': 0.0,
            'simulator_unlocked': False,
        }
        
        # Standing metrics (Time × Results × Role)
        self.standing_metrics: Dict[str, float] = {
            'legitimacy': 50.0,
            'reputation': 50.0,
            'media_standing': 50.0,
            'ownership_confidence': 50.0,
            'political_capital': 50.0,
            'morale': 50.0,
        }
        # Ownership model (for player teams)
        self.ownership_type: str = "hired_manager"  # "hired_manager" or "self_owned"
        
        # Tier membership attributes (Phase 0 fix)
        self.tier: int = 0  # 1-5 (Grassroots to Formula Z)
        self.league_id: str = ""  # References League.league_id
        self.tier_name: str = ""  # Display name: "grassroots", "formula_z", etc.
        
        # Parts & Manufacturer System (Phase 1)
        self.parts_inventory: List[Part] = []  # Owned parts not currently equipped
        self.equipped_parts: Dict[str, Part] = {}  # part_type -> Part (currently on car)
        self.manufacturer_contracts: List[Dict[str, Any]] = []  # Partnership deals
        
        # R&D Projects (Phase 4)
        self.active_rd_projects: List[RDProject] = []  # Currently running R&D projects
        
        # Upgrade Packages (Phase 5)
        self.installed_upgrades: List[str] = []  # Installed upgrade package IDs
    
    def add_entity_with_salary(self, entity: Entity, salary_per_tick: Optional[float] = None) -> None:
        """Add entity to team and calculate salary based on overall rating"""
        if entity is None:
            return

        if self._roster_contains(entity):
            return

        entity_type = type(entity).__name__
        
        # Calculate salary: base + bonus for rating above 50
        if salary_per_tick is None:
            base_salary = SALARY_BASE.get(entity_type, 100.0)
            
            # Apply tier-based salary multiplier (reduces costs at lower tiers)
            tier_multiplier = TIER_SALARY_MULTIPLIER.get(self.tier, 1.0)
            
            rating_multiplier = entity.overall_rating / 50.0  # 50 rating = 1x, 75 rating = 1.5x
            salary_per_tick = base_salary * tier_multiplier * rating_multiplier
        
        # Add to appropriate roster
        if isinstance(entity, Driver):
            self.drivers.append(entity)
        elif isinstance(entity, Engineer):
            self.engineers.append(entity)
        elif isinstance(entity, Mechanic):
            self.mechanics.append(entity)
        elif isinstance(entity, Strategist):
            self.strategist = entity
        elif isinstance(entity, AIPrincipal):
            self.principal = entity
        
        # Register salary
        self.budget.add_staff_salary(entity.name, salary_per_tick)
    
    def remove_entity(self, entity: Entity) -> None:
        """Remove entity from team and cancel salary"""
        if entity is None:
            return

        # Remove from roster
        if isinstance(entity, Driver) and entity in self.drivers:
            self.drivers.remove(entity)
        elif isinstance(entity, Engineer) and entity in self.engineers:
            self.engineers.remove(entity)
        elif isinstance(entity, Mechanic) and entity in self.mechanics:
            self.mechanics.remove(entity)
        elif isinstance(entity, Strategist) and entity == self.strategist:
            self.strategist = None
        elif isinstance(entity, AIPrincipal) and entity == self.principal:
            self.principal = None
        
        # Cancel salary
        self.budget.remove_staff_salary(entity.name)

    def _roster_contains(self, entity: Entity) -> bool:
        if entity is None:
            return False
        
        candidates = self.drivers + self.engineers + self.mechanics
        candidates += [self.strategist] if self.strategist else []
        candidates += [self.principal] if self.principal else []
        
        for member in candidates:
            if member is entity:
                return True
            if hasattr(member, 'entity_id') and hasattr(entity, 'entity_id'):
                if member.entity_id == entity.entity_id:
                    return True
            if getattr(member, 'name', None) == getattr(entity, 'name', None):
                return True
        return False

    def normalize_roster(self) -> None:
        """Remove invalid entries and duplicates from roster lists."""
        def dedupe(entries: List[Entity]) -> List[Entity]:
            seen_ids = set()
            seen_names = set()
            cleaned = []
            for entry in entries:
                if entry is None:
                    continue
                entity_id = getattr(entry, 'entity_id', None)
                name = getattr(entry, 'name', None)
                if entity_id is not None and entity_id in seen_ids:
                    continue
                if name and name in seen_names:
                    continue
                if entity_id is not None:
                    seen_ids.add(entity_id)
                if name:
                    seen_names.add(name)
                cleaned.append(entry)
            return cleaned

        self.drivers = dedupe(self.drivers)
        self.engineers = dedupe(self.engineers)
        self.mechanics = dedupe(self.mechanics)
        if self.strategist and (self.strategist not in dedupe([self.strategist])):
            self.strategist = None
        if self.principal and (self.principal not in dedupe([self.principal])):
            self.principal = None

    def ensure_staff_salaries(self) -> None:
        """
        Rebuild staff salaries dict from current roster.
        Always rebuilds to stay in sync with roster changes.
        """
        # Clear existing to ensure we're in sync with current roster
        self.budget.staff_salaries.clear()

        def calc_salary(target: Entity) -> float:
            base_salary = SALARY_BASE.get(type(target).__name__, 100.0)
            tier_multiplier = TIER_SALARY_MULTIPLIER.get(self.tier, 1.0)
            rating_multiplier = target.overall_rating / 50.0
            # Note: per-tick salary, season has ~182 ticks (26 weeks * 7 days/week)
            return base_salary * tier_multiplier * rating_multiplier

        # Add all current roster members
        for driver in self.drivers:
            if driver:
                self.budget.add_staff_salary(driver.name, calc_salary(driver))
        for engineer in self.engineers:
            if engineer:
                self.budget.add_staff_salary(engineer.name, calc_salary(engineer))
        for mechanic in self.mechanics:
            if mechanic:
                self.budget.add_staff_salary(mechanic.name, calc_salary(mechanic))
        if self.strategist:
            self.budget.add_staff_salary(self.strategist.name, calc_salary(self.strategist))
        if self.principal:
            self.budget.add_staff_salary(self.principal.name, calc_salary(self.principal))
    
    def direct_upgrade_facility(self, facility: str, amount: float) -> Dict[str, Any]:
        """
        Direct purchase infrastructure upgrade (bypass R&D).
        Available to tier 1-3 teams or for baseline facilities.
        Instant application, but expensive.
        
        Returns: dict with 'success': bool, 'cost': float, 'message': str
        """
        # Check if facility exists
        if facility not in self.infrastructure:
            return {'success': False, 'cost': 0, 'message': f"Unknown facility: {facility}"}
        
        # Check if facility is unlocked
        unlock_key = f"{facility}_unlocked"
        if unlock_key in self.infrastructure and not self.infrastructure[unlock_key]:
            return {'success': False, 'cost': 0, 'message': f"{facility} is not unlocked"}
        
        # Get current quality
        current_quality = self.infrastructure[facility]
        
        # Check if at max (100)
        if current_quality >= 100.0:
            return {'success': False, 'cost': 0, 'message': f"{facility} already at maximum quality"}
        
        # Cap amount to not exceed 100
        actual_amount = min(amount, 100.0 - current_quality)
        
        # Calculate cost using exponential formula
        # base_cost * ((quality_for_cost / 50) ** exponent) * amount
        # More expensive as quality gets higher; avoid free upgrades from 0
        base_cost_per_point = get_facility_base_cost_per_point(facility)
        exponent = INFRASTRUCTURE_EFFECTS['direct_upgrade_cost_exponent']
        quality_for_cost = max(50.0, current_quality)
        cost = base_cost_per_point * ((quality_for_cost / 50.0) ** exponent) * actual_amount
        
        # Check if affordable
        if not self.budget.can_afford(cost):
            return {'success': False, 'cost': cost, 'message': f"Insufficient funds (need ${cost:,.0f})"}
        
        # Apply upgrade
        self.budget.cash -= cost
        self.infrastructure[facility] += actual_amount
        self.infrastructure[facility] = min(100.0, self.infrastructure[facility])
        
        return {
            'success': True,
            'cost': cost,
            'old_quality': current_quality,
            'new_quality': self.infrastructure[facility],
            'amount': actual_amount,
            'message': f"Upgraded {facility} by {actual_amount:.1f} points for ${cost:,.0f}"
        }
    
    def sell_facility(self, facility: str) -> Dict[str, Any]:
        """
        Sell/liquidate infrastructure facility for emergency cash.
        Returns dict with 'success', 'recovery_cash', 'old_quality', 'tier', 'message'.
        
        Recovery calculation:
        - Estimate rebuild cost from current quality
        - Apply tier-based recovery ratio (Grassroots higher, Z-tier lower)
        - Elite facilities are harder to liquidate at fair value
        - Sets quality to 0 but keeps unlocked flag (can rebuild later)
        """
        # Check if facility exists
        if facility not in self.infrastructure:
            return {'success': False, 'recovery_cash': 0, 'message': f"Unknown facility: {facility}"}
        
        # Check if facility is unlocked
        unlock_key = f"{facility}_unlocked"
        if unlock_key in self.infrastructure and not self.infrastructure[unlock_key]:
            return {'success': False, 'recovery_cash': 0, 'message': f"{facility} is not unlocked"}
        
        # Get current quality
        current_quality = self.infrastructure[facility]
        
        # Check if already at zero
        if current_quality <= 0:
            return {'success': False, 'recovery_cash': 0, 'message': f"{facility} already sold/degraded to zero"}
        
        # Determine facility tier
        facility_tier = FACILITY_TIER_MAP.get(facility, 1)
        recovery_ratio = FACILITY_SELL_RECOVERY.get(facility_tier, 0.35)
        
        # Estimate rebuild cost
        # Use simplified formula: assume average upgrade cost from 0 to current quality
        # Real cost is exponential, but for sale we use average
        base_cost_per_point = get_facility_base_cost_per_point(facility)
        avg_quality_factor = (current_quality / 50.0) ** 1.4  # Lower exponent than actual upgrade
        estimated_rebuild_cost = base_cost_per_point * avg_quality_factor * current_quality
        
        # Apply recovery ratio
        recovery_cash = estimated_rebuild_cost * recovery_ratio
        
        # Additional penalty for elite facilities (market has fewer buyers)
        if facility_tier == 5:
            recovery_cash *= 0.85  # Extra 15% reduction for Formula Z facilities
        
        # Execute sale
        old_quality = current_quality
        self.infrastructure[facility] = 0.0
        self.budget.cash += recovery_cash
        
        # Log transaction (if history tracking exists)
        tier_name = TIER_DISPLAY_NAMES.get(facility_tier, "unknown")
        
        return {
            'success': True,
            'recovery_cash': recovery_cash,
            'old_quality': old_quality,
            'new_quality': 0.0,
            'tier': facility_tier,
            'tier_name': tier_name,
            'recovery_ratio': recovery_ratio,
            'message': f"Sold {facility} (Q{old_quality:.0f}, {tier_name}) for ${recovery_cash:,.0f}"
        }


class League:
    """League structure"""
    
    def __init__(self, name: str, tier: int, tier_name: str = "grassroots", league_id: str = "", league_index: int = 0):
        self.name = name
        self.tier = tier  # 1-5 (1=Grassroots, 5=Formula Z)
        self.tier_name = tier_name
        self.league_id = league_id  # Unique identifier for this league
        self.league_index = league_index  # Integer index within tier (for name generation)
        self.teams: List[Team] = []
        self.schedule: List[Union[int, Tuple[int, str]]] = [] # List of tick numbers (or (tick, track_id) tuples) when races occur
        self.standings: Dict[str, float] = {} # TeamID -> Points (legacy, use championship_table)
        self.championship_table: Dict[str, float] = {}  # Team name -> season points
        self.driver_championship: Dict[str, float] = {}  # Driver name -> season points
        self.races_this_season: int = 0  # Counter for season end detection
        self.hype: float = 1.0  # Media hype multiplier (baseline 1.0, affected by exciting events)
        self.hype_events_this_season: int = 0  # Track hype-generating events


class JobListing:
    """Job board entry"""
    
    def __init__(
        self,
        team: Optional[Team] = None,
        role: str = "Driver",
        expectation_band: str = "mid",
        patience_profile: float = 0.5,
        risk_profile: float = 0.5,
        team_name: str = "",
        tier: str = "",
        salary: Optional[int] = None,
        visibility_threshold: float = 0.0,
        created_tick: Optional[int] = None
    ):
        self.team = team
        self.team_name = team.name if team else team_name
        self.role = role
        self.expectation_band = expectation_band
        self.patience_profile = patience_profile
        self.risk_profile = risk_profile
        self.tier = tier or (team.tier_name if team and hasattr(team, 'tier_name') else "grassroots")
        self.salary = salary if salary is not None else self._estimate_salary(role, self.tier)
        self.visibility_threshold = visibility_threshold
        self.created_tick = created_tick

    @staticmethod
    def _estimate_salary(role: str, tier: str) -> int:
        role_key = role.strip().lower().replace(" ", "_")
        role_map = {
            "driver": "Driver",
            "engineer": "Engineer",
            "mechanic": "Mechanic",
            "strategist": "Strategist",
            "team_principal": "AIPrincipal",
            "principal": "AIPrincipal"
        }
        base_key = role_map.get(role_key, "Driver")
        base = SALARY_BASE.get(base_key, 100.0)
        tier_multiplier = TIER_SALARY_MULTIPLIER.get({
            "grassroots": 1,
            "formula_v": 2,
            "formula_x": 3,
            "formula_y": 4,
            "formula_z": 5
        }.get(tier, 1), 1.0)
        return int(base * tier_multiplier * 365)


class JobBoard:
    """Labor market primitive"""
    
    def __init__(self):
        self.vacancies: List[JobListing] = []
    
    def add_vacancy(self, listing: JobListing) -> None:
        self.vacancies.append(listing)
    
    def remove_vacancy(self, listing: JobListing) -> None:
        if listing in self.vacancies:
            self.vacancies.remove(listing)
    
    def filter_visible_to_player(self, player_metrics: Dict[str, float]) -> List[JobListing]:
        """Filter vacancies based on player standing"""
        legitimacy = player_metrics.get('legitimacy', 50.0)
        reputation = player_metrics.get('reputation', 50.0)
        
        visible = []
        for listing in self.vacancies:
            required_legitimacy = self._required_legitimacy(listing.expectation_band)
            if legitimacy >= required_legitimacy and reputation >= listing.visibility_threshold:
                visible.append(listing)
        
        return visible

    def get_acceptance_chance(self, player_metrics: Dict[str, float], listing: JobListing) -> float:
        """Calculate acceptance probability for a listing"""
        legitimacy = player_metrics.get('legitimacy', 50.0)
        reputation = player_metrics.get('reputation', 50.0)
        
        base_chance = {
            "low": 0.6,
            "mid": 0.5,
            "high": 0.4
        }.get(str(listing.expectation_band).lower(), 0.5)
        legitimacy_modifier = (legitimacy - 50.0) / 100.0
        reputation_modifier = (reputation - 50.0) / 100.0
        
        acceptance_chance = base_chance + legitimacy_modifier + reputation_modifier
        return max(0.1, min(0.9, acceptance_chance))
    
    def apply_for_job(self, state: 'SimState', player_metrics: Dict[str, float], listing: JobListing) -> bool:
        """Apply for job - probabilistic acceptance with competing candidates"""
        acceptance_chance = self.get_acceptance_chance(player_metrics, listing)
        rng = state.get_rng("jobs", f"application_{state.tick}")
        return rng.random() < acceptance_chance

    @staticmethod
    def _required_legitimacy(expectation_band: Any) -> float:
        if isinstance(expectation_band, (tuple, list)) and expectation_band:
            return float(expectation_band[0])
        band = str(expectation_band).lower()
        if band == "low":
            return 30.0
        if band == "high":
            return 70.0
        return 50.0
    
    def get_free_agents_by_role(self, free_agents: List['FreeAgent'], role: str) -> List['FreeAgent']:
        """Filter free agents by role type
        
        Args:
            free_agents: List of FreeAgent objects
            role: Role name ("Driver", "Engineer", "Mechanic", "Strategist")
        
        Returns:
            Filtered list of free agents matching role
        """
        return [fa for fa in free_agents if fa.entity_type == role]
    
    def get_free_agents_sorted(self, free_agents: List['FreeAgent'], role: Optional[str] = None) -> List['FreeAgent']:
        """Get free agents sorted by overall rating (descending)
        
        Args:
            free_agents: List of FreeAgent objects
            role: Optional role filter
        
        Returns:
            Sorted list of free agents
        """
        filtered = self.get_free_agents_by_role(free_agents, role) if role else free_agents
        return sorted(filtered, key=lambda fa: fa.overall_rating, reverse=True)



@dataclass
class FreeAgent:
    """Wrapper for entities in the free agent pool"""
    entity: Entity  # The actual driver, engineer, mechanic, or strategist
    asking_salary: int  # Annual salary expectation
    time_in_pool_days: int = 0  # Days since entering free agency
    exit_reason: str = ""  # "fired", "contract_expired", "world_generation", etc.
    
    # Additional attributes for serialization compatibility
    contract_length_preference: int = 2  # Preferred contract length in seasons
    entered_market_tick: int = 0  # Tick when entered free agency
    entered_market_day: int = 0  # Day of year when entered free agency
    interested_in_tier: int = 1  # Tier they're interested in
    reputation_threshold: float = 0.0  # Minimum team reputation they'll accept
    
    @property
    def entity_type(self) -> str:
        """Return entity type name"""
        return type(self.entity).__name__
    
    @property
    def overall_rating(self) -> float:
        """Return entity's overall rating"""
        return self.entity.overall_rating


class SimState:
    """Unified simulation state"""
    
    def __init__(self):
        self.tick: int = 0
        self.phase: str = "development"  # offseason, race_weekend, development
        
        # Calendar tracking
        self.sim_year: int = 1
        self.sim_day_of_year: int = 1
        self.days_per_tick: int = 1  # Daily ticks (ZenGM style)
        self.days_per_year: int = 365
        
        # Season tracking
        self.races_completed_this_season: int = 0
        self.season_number: int = 1
        self.in_offseason: bool = False
        self.offseason_ticks_remaining: int = 0
        self.pending_race_day: bool = False
        self.pending_race_info: Optional[Dict[str, Any]] = None
        self.pending_race_tick: Optional[int] = None
        self._live_pbp_mode: bool = False
        self._live_pbp_interval: Optional[float] = None
        self.race_day_active: bool = False
        self.race_day_started_ts: Optional[float] = None
        self.race_day_duration_sec: int = 300
        self._last_race_result: Optional['RaceResult'] = None
        self._last_race_context: Optional[Dict[str, Any]] = None
        self._last_race_results: Dict[str, 'RaceResult'] = {}
        self._last_race_contexts: Dict[str, Dict[str, Any]] = {}
        self.completed_race_ticks: Set[Tuple[str, int]] = set()
        self.prompted_race_ticks: Set[Tuple[str, int]] = set()  # Tracks which (league_id, race_tick) have already shown pre-race prompt
        
        # NEW: Interactive race day state machine
        # CRITICAL: Always create a race_day_state, even if ftb_race_day isn't imported
        # This prevents races from being blocked
        if ftb_race_day:
            self.race_day_state = ftb_race_day.RaceDayState()
        else:
            # Create minimal stub that won't block races
            class _MinimalPhase:
                value = "idle"
                name = "IDLE"
            
            class _MinimalRaceDayState:
                def __init__(self):
                    self.phase = _MinimalPhase()
                    self.race_tick = None
                    self.league_id = None
                    self.track_id = None
            
            self.race_day_state = _MinimalRaceDayState()
        
        # Live race viewing prompt state (NEW)
        self.watch_race_live_response: Optional[bool] = None  # None = waiting for answer, True = watch live, False = skip
        
        self.player_team: Optional[Team] = None
        self.player_identity: List[str] = []  # 5 typed answers from "who are you?"
        self.player_focus: Optional[str] = None  # "what to focus on?"
        self.player_age: int = 32  # Manager age (cosmetic/narrative)
        self.manager_first_name: str = ""  # Manager's first name
        self.manager_last_name: str = ""  # Manager's last name
        self.manager_career_stats: ManagerCareerStats = ManagerCareerStats()
        self.time_mode: str = "paused" # "paused", "auto", "manual"
        self.control_mode: str = "human"  # "human" or "delegated"
        self.delegation_settings: Dict[str, bool] = {
            'racing': False,
            'development': False,
            'contracts': False,
            'finance': False
        }
        self.audio_settings: Dict[str, float] = {
            'master_volume': 0.8,
            'music_volume': 0.15,
            'voice_volume': 1.1,
            'narrator_volume': 1.2,
            'world_volume': 0.5,
            'ui_volume': 0.1
        }
        self.delegation_focus: Optional[DelegationFocus] = None  # Active delegation focus with modifiers
        self.save_mode: str = "replayable"  # "replayable" or "permanent"
        self.seed: int = 42  # RNG seed for deterministic replay
        self.game_id: str = ""  # Unique identifier for this game session (UUID)
        
        # RNG Streams for determinism
        self.rngs: Dict[str, random.Random] = {
            "master": random.Random(42),
            "race": random.Random(42),
            "dev": random.Random(42),
            "contracts": random.Random(42),
            "world": random.Random(42)
        }
        
        self.ai_teams: List[Team] = []
        self.leagues: Dict[str, League] = {}
        self.tracks: Dict[str, Track] = {}  # track_id -> Track
        self.job_board = JobBoard()
        self.event_history: List[SimEvent] = []
        self.world_state: Dict[str, Any] = {}
        self.pending_developments: List[Dict[str, Any]] = []  # List of {team_name, resolve_tick, cost, engineer_bonus}
        self.pending_decisions: List[DecisionEvent] = []  # Active decisions awaiting player response
        self._next_event_id: int = 1  # Auto-incrementing event ID counter
        
        # New systems
        self.contracts: Dict[int, Contract] = {}  # entity_id -> Contract
        self.sponsorships: Dict[str, List[Sponsorship]] = {}  # team_name -> List[Sponsorship]
        self.pending_sponsor_offers: Dict[str, List[Sponsorship]] = {}  # team_name -> List[offers not yet accepted]
        self._next_sponsor_id: int = 1  # Sponsor ID counter for generation
        self.regulations: List[RegulationChange] = []  # Active and past regulation changes
        self.penalties: List[Penalty] = []  # All issued penalties
        self.rivalries: List[Tuple[str, str, int]] = []  # (team1, team2, intensity 0-100)
        self._next_entity_id: int = 1  # Entity ID counter for name generation
        
        # Free Agent System
        self.free_agents: List[FreeAgent] = []  # Pool of available drivers, engineers, mechanics, strategists
        self.team_name_registry: set = set()  # Track all team names to prevent duplicates
        
        # Salary System
        self.last_salary_payout_tick: int = 0  # Track when salaries were last deducted
        
        # Manufacturer & Parts System (Phase 1)
        self.manufacturers: Dict[str, Manufacturer] = {}  # manufacturer_id -> Manufacturer
        self.parts_catalog: Dict[str, Part] = {}  # part_id -> Part
        self.parts_generation_counter: Dict[str, int] = {}  # part_type -> latest generation number
        self.current_meta: Dict[str, float] = {
            'aero_era': 0.5,
            'power_era': 0.3,
            'reliability_era': 0.2
        }  # Meta weights for parts arms race
        
        # Dirty flags for UI optimization
        self._contracts_dirty: bool = True
        self._stats_dirty: bool = True
        self._team_dirty: bool = True
        self._finance_dirty: bool = True
        self._development_dirty: bool = True
        self._sponsors_dirty: bool = True
        self._car_dirty: bool = True
        self._manager_career_dirty: bool = True
        self._audio_settings_dirty: bool = True
        
        # State database path for narrator/delegate interface
        self.state_db_path: Optional[str] = None
        
        # League economic state system
        self.economic_state: Dict[str, Any] = {
            'sponsor_market_multiplier': 1.0,  # 1.0 = normal, < 1.0 = downturn, > 1.0 = boom
            'recent_folds_count': 0,
            'tier_stability': 1.0,
            'last_downturn_tick': -1000,  # Track when last downturn happened
            'downturn_active': False,
            'downturn_end_tick': 0
        }

    def mark_dirty(self, domain: str):
        """Mark a data domain as dirty to trigger UI refresh"""
        if domain == 'contracts':
            self._contracts_dirty = True
        elif domain == 'stats':
            self._stats_dirty = True
        elif domain == 'team':
            self._team_dirty = True
        elif domain == 'finance':
            self._finance_dirty = True
        elif domain == 'development':
            self._development_dirty = True
        elif domain == 'sponsors':
            self._sponsors_dirty = True
        elif domain == 'car':
            self._car_dirty = True
        elif domain == 'manager_career':
            self._manager_career_dirty = True
        elif domain == 'audio_settings':
            self._audio_settings_dirty = True
        elif domain == 'all':
            self._contracts_dirty = True
            self._stats_dirty = True
            self._team_dirty = True
            self._finance_dirty = True
            self._development_dirty = True
            self._sponsors_dirty = True
            self._car_dirty = True
            self._manager_career_dirty = True
            self._audio_settings_dirty = True
    
    def is_dirty(self) -> bool:
        """Check if any domain is marked as dirty"""
        return (self._contracts_dirty or self._stats_dirty or self._team_dirty or 
                self._finance_dirty or self._development_dirty or self._sponsors_dirty or 
                self._car_dirty or self._manager_career_dirty or self._audio_settings_dirty)
    
    def clear_dirty_flags(self):
        """Clear all dirty flags after UI refresh"""
        self._contracts_dirty = False
        self._stats_dirty = False
        self._team_dirty = False
        self._finance_dirty = False
        self._development_dirty = False
        self._sponsors_dirty = False
        self._car_dirty = False
        self._manager_career_dirty = False
        self._audio_settings_dirty = False
    
    def log_transaction(self, type: str, category: str, amount: float, description: str, 
                       balance_after: float, related_entity: str = None, metadata: Dict = None):
        """Log a financial transaction to the state database.
        
        Args:
            type: "income" or "expense"
            category: Transaction category (e.g., "salary", "prize_money", "sponsor_payment")
            amount: Transaction amount (positive number)
            description: Human-readable description
            balance_after: Team budget balance after transaction
            related_entity: Optional related entity name (driver, sponsor, etc.)
            metadata: Optional additional metadata as dict
        """
        if not self.state_db_path:
            return  # No database configured
        
        try:
            import json
            from plugins import ftb_state_db
            
            transaction = {
                'tick': self.tick,
                'season': self.season_number,
                'game_day': self.sim_day_of_year,
                'type': type,
                'category': category,
                'amount': amount,
                'balance_after': balance_after,
                'description': description,
                'related_entity': related_entity,
                'metadata_json': json.dumps(metadata) if metadata else None
            }
            
            ftb_state_db.write_financial_transaction(self.state_db_path, transaction)
        except Exception as e:
            _dbg(f"[FTB] Warning: Could not log transaction: {e}")
    
    def get_rng(self, stream: str, context: Any = None) -> random.Random:
        """Get a deterministic RNG seeded by (master_seed + tick + stream + context)."""
        import hashlib
        input_str = f"{self.seed}:{self.tick}:{stream}:{str(context)}"
        # Stable seed generation
        seed_int = int(hashlib.md5(input_str.encode()).hexdigest(), 16)
        return random.Random(seed_int)
    
    def current_date_str(self) -> str:
        """Return formatted calendar date"""
        return f"Year {self.sim_year}, Day {self.sim_day_of_year}"
    
    def advance_calendar(self) -> List[SimEvent]:
        """Advance calendar and return birthday events when entities age"""
        events = []
        
        # Increment calendar
        self.sim_day_of_year += self.days_per_tick
        
        # Check for year rollover
        if self.sim_day_of_year > self.days_per_year:
            self.sim_day_of_year = 1
            self.sim_year += 1
            
            # Age all human entities (not cars) when year rolls over
            all_teams = [self.player_team] + self.ai_teams if self.player_team else self.ai_teams
            
            for team in all_teams:
                if team is None:
                    continue
                
                # Process human entities only (drivers, engineers, mechanics, strategists, principals)
                entities_to_age = (
                    team.drivers + 
                    team.engineers + 
                    team.mechanics + 
                    ([team.strategist] if team.strategist else []) +
                    ([team.principal] if team.principal else [])
                )
                
                for entity in entities_to_age:
                    if entity is None or isinstance(entity, Car):
                        continue
                    
                    # Increment age
                    entity.age += 1
                    
                    # Generate birthday event
                    events.append(SimEvent(
                        event_type="time",
                        category="entity_birthday",
                        ts=self.tick,
                        priority=10.0,
                        severity="info",
                        data={
                            'entity_name': entity.name,
                            'entity_type': type(entity).__name__,
                            'new_age': entity.age,
                            'team': team.name if team else 'Unknown'
                        }
                    ))
        
        # Check for contract expiries (check every 7 ticks / 1 week)
        if self.tick % 7 == 0:
            expiry_events = self._check_contract_expiries()
            events.extend(expiry_events)
            
            # Check for driver retirements (age/performance pressure)
            retirement_events = self._check_driver_retirements()
            events.extend(retirement_events)
        
        return events
    
    def _check_contract_expiries(self) -> List[SimEvent]:
        """Check all contracts and generate warning/expiry events"""
        events = []
        
        # Check all contracts
        expired_ids = []
        for entity_id, contract in self.contracts.items():
            days_remaining = contract.days_remaining(self.sim_day_of_year)
            
            # Contract expired
            if contract.is_expired(self.sim_day_of_year):
                # Find the entity
                entity = self._find_entity_by_id(entity_id)
                if entity:
                    # Create notification for player team contract expiration
                    if contract.team_name == self.player_team.name if self.player_team else "":
                        try:
                            import plugins.ftb_notifications as ftb_notif
                            entity_name = entity.display_name if hasattr(entity, 'display_name') else entity.name
                            ftb_notif.create_notification(
                                category='contract',
                                title=f"📄 Contract Expired: {entity_name}",
                                message=f"{entity_name}'s contract with {contract.team_name} has expired.",
                                priority=80,
                                metadata={'entity_id': entity_id, 'entity_type': type(entity).__name__},
                                db_path=self.state_db_path if hasattr(self, 'state_db_path') else None
                            )
                        except Exception as e:
                            _dbg(f"[FTB] Failed to create contract expiration notification: {e}")
                    
                    events.append(SimEvent(
                        event_type="structural",
                        category="contract_expired",
                        ts=self.tick,
                        priority=70.0,
                        severity="warning",
                        data={
                            'entity_name': entity.display_name if hasattr(entity, 'display_name') else entity.name,
                            'entity_type': type(entity).__name__,
                            'team': contract.team_name,
                            'salary': contract.base_salary
                        }
                    ))
                expired_ids.append(entity_id)
            
            # Contract expiring soon warnings
            elif 0 < days_remaining <= 30:
                entity = self._find_entity_by_id(entity_id)
                if entity:
                    # Only create notification at specific thresholds to avoid spam
                    # Initialize tracking dict if not exists
                    if not hasattr(contract, '_notification_sent_at'):
                        contract._notification_sent_at = {}
                    
                    # Determine severity and urgency
                    notify_thresholds = [30, 14, 7]
                    should_notify = False
                    threshold_hit = None
                    
                    for threshold in notify_thresholds:
                        if days_remaining <= threshold:
                            # Check if we already notified at this threshold
                            threshold_key = f"warning_{threshold}d"
                            if threshold_key not in contract._notification_sent_at:
                                should_notify = True
                                threshold_hit = threshold
                                contract._notification_sent_at[threshold_key] = self.tick
                                break  # Only notify once per threshold
                    
                    # Create event and notification if at threshold
                    if should_notify and contract.team_name == (self.player_team.name if self.player_team else ""):
                        severity = "critical" if threshold_hit <= 7 else "warning" if threshold_hit <= 14 else "info"
                        priority = 90.0 if threshold_hit <= 7 else 70.0 if threshold_hit <= 14 else 50.0
                        
                        entity_name = entity.display_name if hasattr(entity, 'display_name') else entity.name
                        
                        events.append(SimEvent(
                            event_type="opportunity",
                            category="contract_expiry_warning",
                            ts=self.tick,
                            priority=priority,
                            severity=severity,
                            data={
                                'entity_name': entity_name,
                                'entity_type': type(entity).__name__,
                                'team': contract.team_name,
                                'days_remaining': days_remaining,
                                'threshold': threshold_hit,
                                'salary': contract.base_salary
                            }
                        ))
                        
                        # Create notification for player awareness
                        try:
                            import plugins.ftb_notifications as ftb_notif
                            urgency_emoji = "🔴" if threshold_hit <= 7 else "🟡" if threshold_hit <= 14 else "🟢"
                            ftb_notif.create_notification(
                                category='contract_warning',
                                title=f"{urgency_emoji} Contract Expiring: {entity_name}",
                                message=f"{entity_name}'s contract expires in {days_remaining} days. Consider renewal or replacement.",
                                priority=priority,
                                metadata={
                                    'entity_id': entity_id,
                                    'entity_type': type(entity).__name__,
                                    'days_remaining': days_remaining,
                                    'threshold': threshold_hit,
                                    'salary': contract.base_salary
                                },
                                db_path=self.state_db_path if hasattr(self, 'state_db_path') else None
                            )
                        except Exception as e:
                            _dbg(f"[FTB] Failed to create contract warning notification: {e}")
        
        # Remove expired contracts
        for entity_id in expired_ids:
            entity = self._find_entity_by_id(entity_id)
            entity_name = entity.display_name if entity and hasattr(entity, 'display_name') else (entity.name if entity else "Unknown")
            contract = self.contracts.get(entity_id)
            team_name = contract.team_name if contract else "Unknown"
            _dbg(f"[FTB CONTRACT_EXPIRY] Removing expired contract: {entity_name} from team '{team_name}' (entity stays on roster)")
            del self.contracts[entity_id]
        
        return events
    
    def _find_entity_by_id(self, entity_id: int):
        """Find entity by entity_id across all teams"""
        all_teams = [self.player_team] + self.ai_teams if self.player_team else self.ai_teams
        
        for team in all_teams:
            if team is None:
                continue

            team.ensure_staff_salaries()
            
            # Check all entity lists
            for entity in (team.drivers + team.engineers + team.mechanics + 
                          ([team.strategist] if team.strategist else []) +
                          ([team.principal] if team.principal else [])):
                if entity and hasattr(entity, 'entity_id') and entity.entity_id == entity_id:
                    return entity

        for free_agent in getattr(self, 'free_agents', []):
            entity = free_agent.entity if hasattr(free_agent, 'entity') else free_agent
            if entity and hasattr(entity, 'entity_id') and entity.entity_id == entity_id:
                return entity
        
        return None
    
    def _check_driver_retirements(self) -> List[SimEvent]:
        """Check for driver retirements based on age and performance pressure"""
        events = []
        all_teams = [self.player_team] + self.ai_teams if self.player_team else self.ai_teams
        rng = random.Random(self.seed + self.tick + 999)  # Separate seed for retirement checks
        
        for team in all_teams:
            if team is None:
                continue
            
            # Check all drivers on teams
            for driver in team.drivers:
                if driver is None or not hasattr(driver, 'age'):
                    continue
                
                # Calculate retirement probability based on age and performance
                retirement_prob = 0.0
                retirement_reason = ""
                
                # Age-based pressure
                if driver.age >= 40:
                    retirement_prob += 0.15  # 15% base chance at 40+
                    retirement_prob += (driver.age - 40) * 0.05  # +5% per year over 40
                    retirement_reason = "age"
                elif driver.age >= 35:
                    retirement_prob += 0.02  # 2% base chance at 35-39
                    retirement_prob += (driver.age - 35) * 0.01  # +1% per year over 35
                    retirement_reason = "age"
                
                # Performance decay pressure (compare current to peak)
                if hasattr(driver, 'overall_rating') and hasattr(driver, 'peak_age'):
                    current_rating = driver.overall_rating
                    # Check if past peak and declining
                    if driver.age > driver.peak_age + 2:
                        # Get key stats to check decline
                        key_stats = ['pace', 'racecraft', 'consistency'] if hasattr(driver, 'pace') else []
                        avg_key_stat = 50.0
                        if key_stats:
                            stat_values = [getattr(driver, stat, 50.0) for stat in key_stats]
                            avg_key_stat = sum(stat_values) / len(stat_values)
                        
                        # If key stats have dropped significantly
                        if avg_key_stat < 60 and driver.age > 32:
                            retirement_prob += 0.08
                            retirement_reason = "performance_decline"
                        
                        # If overall rating is low for age
                        if current_rating < 55 and driver.age > 30:
                            retirement_prob += 0.05
                            if not retirement_reason:
                                retirement_reason = "performance_decline"
                
                # Cap probability at 25% per week (before silly season modifier)
                retirement_prob = min(retirement_prob, 0.25)
                
                # Silly Season modifier: 3x retirement probability for Formula Z during offseason
                is_silly_season = False
                if self.in_offseason and team.tier == 5:  # Formula Z only
                    retirement_prob *= 3.0
                    is_silly_season = True
                    retirement_prob = min(retirement_prob, 0.75)  # Cap at 75% during silly season
                
                # Check if retirement happens this week
                if retirement_prob > 0 and rng.random() < retirement_prob:
                    # Generate retirement announcement event
                    announcement_day = self.sim_day_of_year + 14  # Announce 2 weeks in advance
                    if announcement_day > 365:
                        announcement_day -= 365
                    
                    retirement_day = announcement_day + 14  # Retire 2 weeks after announcement
                    if retirement_day > 365:
                        retirement_day -= 365
                    
                    events.append(SimEvent(
                        event_type="structural",
                        category="driver_retirement_announcement",
                        ts=self.tick,
                        priority=85.0,
                        severity="info",
                        data={
                            'entity_id': driver.entity_id if hasattr(driver, 'entity_id') else None,
                            'entity_name': driver.name,
                            'age': driver.age,
                            'team': team.name,
                            'reason': retirement_reason,
                            'announcement_day': announcement_day,
                            'retirement_day': retirement_day,
                            'overall_rating': driver.overall_rating if hasattr(driver, 'overall_rating') else 50.0
                        },
                        description=f"{driver.name} announces retirement from racing (age {driver.age})"
                    ))
                    
                    # Mark driver for retirement (will be processed later)
                    if not hasattr(driver, 'retiring'):
                        driver.retiring = True
                        driver.retirement_day = retirement_day
        
        return events
    
    def convert_retired_driver_to_staff(self, driver: 'Driver', staff_role: str) -> Optional[Union['Engineer', 'Strategist', 'Mechanic', 'AIPrincipal']]:
        """Convert a retiring driver into a staff member with intelligently mapped stats.
        
        Args:
            driver: The retiring driver entity
            staff_role: Target role - "Engineer", "Strategist", "Mechanic", or "Principal"
        
        Returns:
            New staff entity with converted stats, or None if conversion fails
        """
        if staff_role not in ["Engineer", "Strategist", "Mechanic", "AIPrincipal"]:
            return None
        
        # Create new entity based on role
        if staff_role == "Engineer":
            staff_entity = Engineer(name=driver.name, display_name=driver.display_name, entity_id=driver.entity_id)
        elif staff_role == "Strategist":
            staff_entity = Strategist(name=driver.name, display_name=driver.display_name, entity_id=driver.entity_id)
        elif staff_role == "Mechanic":
            staff_entity = Mechanic(name=driver.name, display_name=driver.display_name, entity_id=driver.entity_id)
        elif staff_role == "AIPrincipal":
            staff_entity = AIPrincipal(name=driver.name, display_name=driver.display_name, entity_id=driver.entity_id)
        else:
            return None
        
        # Copy basic attributes
        staff_entity.age = driver.age
        staff_entity.peak_age = driver.peak_age  # Adjusted below for staff role
        staff_entity.decay_rate = 0.8  # Slower decay for staff roles
        
        # Stat mapping: Driver → Staff
        # These mappings reflect logical skill transfers
        stat_mappings = {
            "Engineer": {
                # Technical understanding from driving experience
                "technical_depth": lambda d: (d.feedback_quality * 0.5 + d.adaptability * 0.3 + d.setup_sensitivity * 0.2),
                "aero_understanding": lambda d: (d.adaptability * 0.4 + d.feedback_quality * 0.3 + d.learning_rate * 0.3),
                "mechanical_understanding": lambda d: (d.feedback_quality * 0.5 + d.consistency * 0.3 + d.adaptability * 0.2),
                "correlation_accuracy": lambda d: (d.feedback_quality * 0.6 + d.consistency * 0.4),
                "driver_alignment": lambda d: (d.feedback_quality * 0.4 + d.technical_language_alignment * 0.6),
                "communication": lambda d: (d.technical_language_alignment * 0.5 + d.political_awareness * 0.3 + d.pressure_handling * 0.2),
                "innovation_bias": lambda d: (d.adaptability * 0.5 + d.learning_rate * 0.5),
                "regulation_interpretation": lambda d: (d.regulation_adaptation * 0.7 + d.adaptability * 0.3),
                "trackside_translation": lambda d: (d.racecraft * 0.4 + d.spatial_awareness * 0.3 + d.feedback_quality * 0.3),
                # Other stats get modest baseline
                "systems_thinking": lambda d: 50.0 + (d.learning_rate - 50.0) * 0.3,
                "powertrain_understanding": lambda d: 50.0 + (d.adaptability - 50.0) * 0.3,
                "concept_generation_rate": lambda d: 50.0 + (d.adaptability - 50.0) * 0.2,
                "upgrade_effectiveness": lambda d: 50.0,
                "upgrade_scalability": lambda d: 50.0,
                "simulation_fidelity": lambda d: 50.0 + (d.feedback_quality - 50.0) * 0.2,
                "data_noise_tolerance": lambda d: 50.0 + (d.consistency - 50.0) * 0.3,
                "iteration_speed": lambda d: 50.0 + (d.learning_rate - 50.0) * 0.3,
                "delivery_discipline": lambda d: 50.0 + (d.discipline - 50.0) * 0.4,
                "project_management": lambda d: 50.0 + (d.discipline - 50.0) * 0.3,
                "failure_recovery_speed": lambda d: (d.recovery_from_error * 0.6 + d.adaptability * 0.4),
                "reliability_focus": lambda d: (d.consistency * 0.5 + d.discipline * 0.5),
                "cross_department_alignment": lambda d: 50.0 + (d.political_awareness - 50.0) * 0.3,
                "knowledge_transfer": lambda d: 50.0 + (d.feedback_quality - 50.0) * 0.3
            },
            "Strategist": {
                # Race intelligence translates directly
                "race_reading": lambda d: (d.racecraft * 0.4 + d.spatial_awareness * 0.3 + d.adaptability * 0.3),
                "situational_awareness": lambda d: (d.spatial_awareness * 0.5 + d.racecraft * 0.3 + d.pressure_handling * 0.2),
                "traffic_modeling": lambda d: (d.spatial_awareness * 0.5 + d.racecraft * 0.4 + d.overtaking_skill * 0.1),
                "gap_estimation": lambda d: (d.spatial_awareness * 0.5 + d.consistency * 0.3 + d.pace * 0.2),
                "opponent_intent_reading": lambda d: (d.racecraft * 0.5 + d.defensive_skill * 0.3 + d.political_awareness * 0.2),
                "tire_modeling": lambda d: (d.tire_conservation * 0.5 + d.tire_warmup * 0.3 + d.feedback_quality * 0.2),
                "degradation_prediction": lambda d: (d.tire_conservation * 0.6 + d.consistency * 0.4),
                "weather_forecasting": lambda d: (d.wet_weather_skill * 0.5 + d.adaptability * 0.5),
                "timing_sense": lambda d: (d.starts * 0.4 + d.racecraft * 0.3 + d.consistency * 0.3),
                "risk_calibration": lambda d: (d.racecraft * 0.3 + d.discipline * 0.4 + d.aggression * 0.3),
                "commitment_threshold": lambda d: (d.aggression * 0.4 + d.discipline * 0.3 + d.pressure_handling * 0.3),
                "plan_flexibility": lambda d: (d.adaptability * 0.6 + d.track_learning_speed * 0.4),
                "safety_car_prediction": lambda d: 50.0 + (d.racecraft - 50.0) * 0.3,
                "virtual_safety_car_modeling": lambda d: 50.0 + (d.racecraft - 50.0) * 0.2,
                "reward_estimation": lambda d: 50.0 + (d.racecraft - 50.0) * 0.3,
                "contingency_depth": lambda d: 50.0 + (d.adaptability - 50.0) * 0.4,
                "pit_window_precision": lambda d: 50.0 + (d.consistency - 50.0) * 0.3,
                "call_latency": lambda d: (d.racecraft * 0.4 + d.pressure_handling * 0.4 + d.recovery_from_error * 0.2),
                "multi_car_coordination": lambda d: 50.0 + (d.spatial_awareness - 50.0) * 0.4,
                "morale": lambda d: 50.0
            },
            "Mechanic": {
                # Consistency and discipline translate well
                "build_quality": lambda d: (d.consistency * 0.6 + d.discipline * 0.4),
                "assembly_precision": lambda d: (d.consistency * 0.5 + d.discipline * 0.5),
                "procedure_adherence": lambda d: (d.discipline * 0.7 + d.consistency * 0.3),
                "error_rate": lambda d: (d.mistake_rate * 0.6 + d.consistency * 0.4),  # Note: inverted scale
                "error_detection_speed": lambda d: (d.recovery_from_error * 0.6 + d.spatial_awareness * 0.4),
                "error_recovery_quality": lambda d: (d.recovery_from_error * 0.7 + d.adaptability * 0.3),
                "pit_execution": lambda d: (d.starts * 0.3 + d.consistency * 0.4 + d.pressure_handling * 0.3),
                "reaction_time": lambda d: (d.starts * 0.5 + d.racecraft * 0.3 + d.spatial_awareness * 0.2),
                "coordination": lambda d: (d.spatial_awareness * 0.5 + d.racecraft * 0.3 + d.discipline * 0.2),
                "fatigue_resistance": lambda d: (d.fatigue_sensitivity * 0.6 + d.stint_stability * 0.4),  # Note: inverted scale
                "stress_handling": lambda d: (d.pressure_handling * 0.7 + d.consistency * 0.3),
                "focus_retention": lambda d: (d.consistency * 0.5 + d.mistake_rate * 0.3 + d.fatigue_sensitivity * 0.2),
                "weekend_consistency": lambda d: (d.consistency * 0.6 + d.stint_stability * 0.4),
                "component_handling": lambda d: 50.0 + (d.consistency - 50.0) * 0.3,
                "torque_discipline": lambda d: 50.0 + (d.discipline - 50.0) * 0.4,
                "pre_race_preparation": lambda d: 50.0 + (d.discipline - 50.0) * 0.3,
                "tool_familiarity": lambda d: 50.0,
                "rework_efficiency": lambda d: 50.0 + (d.recovery_from_error - 50.0) * 0.3,
                "burnout_rate": lambda d: 50.0,
                "morale": lambda d: 50.0
            },
            "AIPrincipal": {
                # Leadership and strategic thinking
                "aggression": lambda d: d.aggression,
                "risk_tolerance": lambda d: (d.aggression * 0.5 + d.racecraft * 0.3 + d.discipline * 0.2),
                "patience": lambda d: (d.discipline * 0.6 + d.consistency * 0.4),
                "long_term_orientation": lambda d: (d.discipline * 0.5 + d.learning_rate * 0.3 + d.adaptability * 0.2),
                "talent_evaluation_accuracy": lambda d: (d.feedback_quality * 0.4 + d.political_awareness * 0.4 + d.racecraft * 0.2),
                "political_instinct": lambda d: (d.political_awareness * 0.8 + d.ego * 0.2),
                "media_management": lambda d: (d.political_awareness * 0.6 + d.pressure_handling * 0.4),
                "crisis_management": lambda d: (d.pressure_handling * 0.5 + d.recovery_from_error * 0.3 + d.adaptability * 0.2),
                "talent_strategy": lambda d: 50.0 + (d.political_awareness - 50.0) * 0.3,
                "ruthlessness": lambda d: (d.aggression * 0.5 + d.ego * 0.3 + d.discipline * 0.2),
                "staff_loyalty_bias": lambda d: 50.0 + (d.political_awareness - 50.0) * (-0.2),  # Lower political savvy = more loyal
                "organizational_cohesion": lambda d: 50.0 + (d.discipline - 50.0) * 0.3,
                "financial_discipline": lambda d: 50.0 + (d.discipline - 50.0) * 0.4,
                "short_term_pressure_response": lambda d: (d.pressure_handling * 0.6 + d.aggression * 0.4),
                "budget_forecasting_accuracy": lambda d: 50.0,
                "capital_allocation_balance": lambda d: 50.0,
                "cost_cap_management": lambda d: 50.0 + (d.discipline - 50.0) * 0.3,
                "liquidity_conservatism": lambda d: 50.0 + (d.discipline - 50.0) * 0.2,
                "succession_planning": lambda d: 50.0,
                "culture_resilience": lambda d: 50.0 + (d.pressure_handling - 50.0) * 0.3,
                "burnout_mitigation": lambda d: 50.0,
                "regulatory_navigation": lambda d: 50.0 + (d.regulation_adaptation - 50.0) * 0.4,
                "supplier_relationship_management": lambda d: 50.0 + (d.political_awareness - 50.0) * 0.3
            }
        }
        
        # Apply mappings to create staff stats
        if staff_role in stat_mappings:
            for stat_name, mapping_func in stat_mappings[staff_role].items():
                try:
                    # Calculate stat value from driver stats
                    new_value = mapping_func(driver)
                    # Clamp to valid range
                    new_value = max(1.0, min(99.0, new_value))
                    # Apply to staff entity
                    setattr(staff_entity, stat_name, new_value)
                except Exception as e:
                    # Fallback to baseline 50.0 if mapping fails
                    setattr(staff_entity, stat_name, 50.0)
        
        # Apply overall rating penalty (10-20% reduction)
        # Racing skill doesn't translate 1:1 to staff capability
        penalty = 0.85  # 15% reduction
        staff_entity.overall_rating = driver.overall_rating * penalty
        
        # Adjust peak age for staff role (staff can work longer)
        staff_entity.peak_age = driver.peak_age + 5  # Staff peak 5 years later
        
        return staff_entity
    
    def evaluate_contract_offer(self, entity_id: int, offer_terms: Dict[str, Any], rng: random.Random = None) -> Dict[str, Any]:
        """
        Evaluate a contract offer and determine if entity accepts or makes counter-offer.
        
        Returns dict with:
            - 'accepted': bool - whether offer is accepted
            - 'counter_offer': dict (optional) - counter-offer terms if rejected
            - 'message': str - explanation of decision
        """
        entity = self._find_entity_by_id(entity_id)
        if not entity:
            return {'accepted': False, 'message': 'Entity not found'}
        
        # Use deterministic RNG if in replayable mode
        if rng is None:
            if self.save_mode == "replayable":
                rng = self.get_rng("contracts", entity_id)
            else:
                rng = random.Random()
        
        # Get existing contract if extending
        existing_contract = self.contracts.get(entity_id)
        
        # Extract offer terms
        seasons = offer_terms.get('seasons_duration', 2)
        base_salary = offer_terms.get('base_salary', 100000)
        signing_bonus = offer_terms.get('signing_bonus', 0)
        performance_clauses = offer_terms.get('performance_clauses', {})
        exit_clauses = offer_terms.get('exit_clauses', {})
        negotiation_round = offer_terms.get('negotiation_round', 0)
        
        # Calculate entity's market value based on ratings
        avg_rating = sum(entity.current_ratings.values()) / len(entity.current_ratings) if entity.current_ratings else 50.0
        
        # Market value estimation (rough formula)
        # Base: 50000 to 500000 depending on rating (50-100 scale)
        market_base = 50000 + (avg_rating - 50) * 10000
        market_value_per_season = int(market_base)
        
        # Adjust for role
        role = existing_contract.role if existing_contract else offer_terms.get('role', type(entity).__name__.lower())
        role = str(role).lower()
        if role == 'driver':
            market_value_per_season *= 2  # Drivers cost more
        elif role == 'engineer':
            market_value_per_season *= 1.3
        
        # Calculate offer value per season (including signing bonus amortized)
        offer_value_per_season = base_salary + (signing_bonus / max(1, seasons))
        
        # Determine acceptance threshold
        # Entity wants at least 85% of market value, prefers 100%+
        min_acceptable = market_value_per_season * 0.85
        preferred = market_value_per_season * 1.0
        
        # Check if offer is acceptable
        if offer_value_per_season >= preferred:
            # Great offer - accept immediately
            return {
                'accepted': True,
                'message': f"{entity.display_name if hasattr(entity, 'display_name') else entity.name} accepts the offer! The terms are very fair."
            }
        elif offer_value_per_season >= min_acceptable:
            # Acceptable offer - may negotiate slightly or accept
            if negotiation_round == 0:
                # First offer - try to negotiate up a bit
                if rng.random() < 0.6:  # 60% chance to counter
                    counter_salary = int(base_salary * 1.15)  # Ask for 15% more
                    counter_bonus = int(signing_bonus * 1.2) if signing_bonus > 0 else int(market_value_per_season * 0.1)
                    
                    return {
                        'accepted': False,
                        'counter_offer': {
                            'seasons_duration': seasons,
                            'base_salary': counter_salary,
                            'signing_bonus': counter_bonus,
                            'performance_clauses': performance_clauses,
                            'exit_clauses': exit_clauses,
                            'negotiation_round': 1
                        },
                        'message': f"{entity.display_name if hasattr(entity, 'display_name') else entity.name} appreciates the offer but would like improved terms. Counter-offer proposed."
                    }
                else:
                    return {
                        'accepted': True,
                        'message': f"{entity.display_name if hasattr(entity, 'display_name') else entity.name} accepts the offer!"
                    }
            else:
                # Second+ round - more likely to accept
                if offer_value_per_season >= min_acceptable * 1.05 or negotiation_round >= 2:
                    return {
                        'accepted': True,
                        'message': f"{entity.display_name if hasattr(entity, 'display_name') else entity.name} accepts the revised offer!"
                    }
                else:
                    # One more counter-offer
                    counter_salary = int((base_salary + market_value_per_season) / 2)  # Meet in middle
                    counter_bonus = signing_bonus
                    
                    return {
                        'accepted': False,
                        'counter_offer': {
                            'seasons_duration': seasons,
                            'base_salary': counter_salary,
                            'signing_bonus': counter_bonus,
                            'performance_clauses': performance_clauses,
                            'exit_clauses': exit_clauses,
                            'negotiation_round': negotiation_round + 1
                        },
                        'message': f"{entity.display_name if hasattr(entity, 'display_name') else entity.name} is close to agreement. One more adjustment needed."
                    }
        else:
            # Offer too low
            if negotiation_round >= 3:
                # Too many rounds - reject
                return {
                    'accepted': False,
                    'message': f"{entity.display_name if hasattr(entity, 'display_name') else entity.name} rejects the offer. Unable to reach agreement."
                }
            
            # Make counter-offer at market value
            counter_salary = market_value_per_season
            counter_bonus = int(market_value_per_season * 0.15)
            
            return {
                'accepted': False,
                'counter_offer': {
                    'seasons_duration': seasons,
                    'base_salary': counter_salary,
                    'signing_bonus': counter_bonus,
                    'performance_clauses': performance_clauses,
                    'exit_clauses': exit_clauses,
                    'negotiation_round': negotiation_round + 1
                },
                'message': f"{entity.display_name if hasattr(entity, 'display_name') else entity.name} feels the offer is below market value. Counter-offer proposed."
            }
    
    def finalize_contract(self, entity_id: int, contract_terms: Dict[str, Any]) -> bool:
        """
        Create or update a contract with agreed terms.
        
        Returns True if successful, False otherwise.
        """
        entity = self._find_entity_by_id(entity_id)
        if not entity:
            return False
        
        # Get existing contract info
        existing_contract = self.contracts.get(entity_id)
        team_name = existing_contract.team_name if existing_contract else contract_terms.get('team_name')
        if not team_name:
            team_name = self.player_team.name if self.player_team else ""
        role = existing_contract.role if existing_contract else contract_terms.get('role', type(entity).__name__)
        
        # Create new contract
        seasons = contract_terms.get('seasons_duration', 2)
        duration_days = Contract.seasons_to_days(seasons)
        
        new_contract = Contract(
            entity_id=entity_id,
            entity_name=entity.display_name if hasattr(entity, 'display_name') else entity.name,
            team_name=team_name,
            role=role,
            start_day=self.sim_day_of_year,
            duration_days=duration_days,
            base_salary=contract_terms.get('base_salary', 100000),
            performance_clauses=contract_terms.get('performance_clauses', {}),
            exit_clauses=contract_terms.get('exit_clauses', {}),
            seasons_duration=seasons,
            signing_bonus=contract_terms.get('signing_bonus', 0),
            negotiation_round=0,
            last_offer_rejected=False,
            poaching_protection_until=self.sim_day_of_year + 30  # 30-day protection for all new contracts
        )
        
        # Update contracts dictionary
        self.contracts[entity_id] = new_contract

        # Add entity to team roster if needed
        team = None
        if team_name and self.player_team and self.player_team.name == team_name:
            team = self.player_team
        elif team_name:
            team = next((t for t in self.ai_teams if t.name == team_name), None)

        if team and not team._roster_contains(entity):
            # base_salary is already per-tick from contract negotiation
            salary_per_tick = max(0, int(new_contract.base_salary))
            team.add_entity_with_salary(entity, salary_per_tick=salary_per_tick)
            team.normalize_roster()

        # Remove from free agent pool if present
        if hasattr(self, 'free_agents'):
            for fa in list(self.free_agents):
                if fa.entity == entity:
                    self.free_agents.remove(fa)
                    break
        
        # Deduct signing bonus from budget
        if new_contract.signing_bonus > 0 and self.player_team:
            self.player_team.budget.cash -= new_contract.signing_bonus
            
            # Log transaction
            self.log_transaction(
                type="expense",
                category="signing_bonus",
                amount=new_contract.signing_bonus,
                description=f"Signing bonus for {new_contract.entity_name}",
                balance_after=self.player_team.budget.cash,
                related_entity=new_contract.entity_name
            )
        
        return True

    def apply_contract_buyout(self, team: 'Team', contract: 'Contract', entity_name: str) -> int:
        if not team or not contract:
            return 0

        payout = calculate_contract_buyout(contract, getattr(team, 'tier', 1), self.sim_day_of_year)
        if payout <= 0:
            return 0

        team.budget.cash -= payout

        if team == self.player_team:
            self.log_transaction(
                type="expense",
                category="buyout",
                amount=payout,
                description=f"Contract buyout for {entity_name}",
                balance_after=team.budget.cash,
                related_entity=entity_name
            )

        return payout
    
    # ============================================================================
    # MORALE SYSTEM (Phase 1 - Stabilization)
    # ============================================================================
    
    def apply_morale_mean_reversion(self, team: 'Team') -> List[SimEvent]:
        """Apply daily morale regression toward baseline for all team entities
        
        This prevents runaway morale drift by creating elastic pull toward
        a personality-driven equilibrium point.
        
        Called daily for all entities during non-race ticks.
        
        Args:
            team: Team whose entities' morale should regress
        
        Returns:
            List of SimEvents for significant morale changes
        """
        if not MORALE_CONFIG['reversion_enabled']:
            return []
        
        events = []
        current_day = self.sim_day_of_year
        reversion_factor = MORALE_CONFIG['daily_reversion_factor']
        
        all_entities = []
        if hasattr(team, 'drivers'):
            all_entities.extend([d for d in team.drivers if d])
        if hasattr(team, 'engineers'):
            all_entities.extend([e for e in team.engineers if e])
        if hasattr(team, 'mechanics'):
            all_entities.extend([m for m in team.mechanics if m])
        if hasattr(team, 'strategist') and team.strategist:
            all_entities.append(team.strategist)
        
        for entity in all_entities:
            if not hasattr(entity, 'morale'):
                continue
            
            # Ensure baseline exists (backward compatibility)
            if not hasattr(entity, 'morale_baseline'):
                entity.morale_baseline = 50.0
                if hasattr(entity, '_calculate_morale_baseline'):
                    entity.morale_baseline = entity._calculate_morale_baseline()
            
            current_morale = entity.morale
            baseline = entity.morale_baseline
            
            # Calculate regression amount
            morale_delta = baseline - current_morale
            reversion_amount = morale_delta * reversion_factor
            
            # Apply reversion
            entity.morale += reversion_amount
            
            # Clamp to valid range
            entity.morale = max(0.0, min(100.0, entity.morale))
            
            # Update last modified timestamp
            if hasattr(entity, 'morale_last_updated'):
                entity.morale_last_updated = self.tick
            
            # Log significant changes (for debugging and narrative)
            if abs(reversion_amount) > 1.0:
                events.append(SimEvent(
                    event_type="internal",
                    category="morale_reversion",
                    ts=self.tick,
                    priority=20.0,
                    severity="debug",
                    data={
                        'entity': entity.name,
                        'team': team.name,
                        'old_morale': current_morale,
                        'new_morale': entity.morale,
                        'baseline': baseline,
                        'reversion': reversion_amount,
                        'days_from_baseline': abs(current_morale - baseline) / reversion_factor
                    }
                ))
        
        return events
    
    # ============================================================================
    # DRIVER POACHING SYSTEM (Phase 2)
    # ============================================================================
    
    def update_contract_openness_flags(self) -> None:
        """Update whether contracted personnel are open to offers
        
        Driven by:
        - Low morale
        - Team underperformance
        - Financial instability
        - Talent underutilization
        
        Called daily during tick processing.
        """
        all_teams = ([self.player_team] if self.player_team else []) + self.ai_teams
        
        for team in all_teams:
            # Get all entities with contracts
            all_entities = (
                team.drivers + 
                team.engineers + 
                team.mechanics + 
                ([team.strategist] if team.strategist else [])
            )
            
            for entity in all_entities:
                if not entity:
                    continue
                
                # Get contract from central registry
                entity_id = getattr(entity, 'entity_id', None)
                if not entity_id or entity_id not in self.contracts:
                    continue
                
                contract = self.contracts[entity_id]
                
                # Calculate "openness" score based on multiple factors
                openness_factors = []
                
                # Factor 1: Personal morale
                if hasattr(entity, 'morale'):
                    morale = entity.morale
                    if morale < 35:
                        openness_factors.append(('very_low_morale', 0.9))
                    elif morale < 45:
                        openness_factors.append(('low_morale', 0.6))
                    elif morale < 55:
                        openness_factors.append(('below_avg_morale', 0.3))
                
                # Factor 2: Team performance (standing in league)
                if hasattr(team, 'championship_position') and hasattr(team, 'league_id'):
                    # Find league size
                    league_size = 10  # default
                    for league in self.leagues:
                        if league.league_id == team.league_id:
                            league_size = len(league.teams)
                            break
                    
                    position = team.championship_position
                    if position > league_size * 0.75:  # Bottom 25%
                        openness_factors.append(('backmarker_team', 0.5))
                    elif position > league_size * 0.5:  # Bottom 50%
                        openness_factors.append(('midfield_team', 0.2))
                
                # Factor 3: Financial instability
                if hasattr(team.budget, 'cash') and hasattr(team.budget, 'bankruptcy_threshold'):
                    cash = team.budget.cash
                    threshold = team.budget.bankruptcy_threshold
                    
                    if cash < threshold * 2:
                        openness_factors.append(('financial_distress', 0.7))
                    elif cash < threshold * 3:
                        openness_factors.append(('financial_concern', 0.4))
                
                # Factor 4: Talent underutilization (high skill, low tier)
                entity_rating = getattr(entity, 'overall_rating', 50.0)
                if entity_rating > 75 and team.tier <= 2:
                    openness_factors.append(('underutilized_talent', 0.6))
                elif entity_rating > 70 and team.tier == 1:
                    openness_factors.append(('grassroots_ceiling', 0.4))
                
                # Calculate aggregate openness
                if openness_factors:
                    # Average all factors
                    openness_score = sum(weight for _, weight in openness_factors) / len(openness_factors)
                    contract.open_to_offers = openness_score > 0.4
                else:
                    contract.open_to_offers = False
    
    def process_ai_poaching_attempts(self) -> List[SimEvent]:
        """AI teams attempt to poach drivers from other teams
        
        Runs monthly (every 30 ticks) to simulate AI transfer activity.
        AI teams with:
        - High budget surplus
        - Weak driver lineup
        - High tier (more aggressive)
        
        Will attempt to poach high-rated drivers who are open to offers.
        
        Returns:
            List of SimEvents for successful poaching transactions
        """
        events = []
        current_day = self.sim_day_of_year
        
        # Only process monthly to avoid spam
        if self.tick % 30 != 0:
            return events
        
        # Shuffle AI teams for fairness
        import random
        ai_teams = list(self.ai_teams)
        random.shuffle(ai_teams)
        
        for acquiring_team in ai_teams:
            # Check if team should attempt poaching
            if not self._should_ai_team_poach(acquiring_team):
                continue
            
            # Find best available poachable driver
            target = self._find_best_poachable_driver_for_ai(acquiring_team, current_day)
            
            if not target:
                continue
            
            driver = target['entity']
            original_team = target['team']
            contract = target['contract']
            buyout = target['buyout']
            
            # Check if acquiring team can afford
            total_cost = buyout + (contract.base_salary * 1.2)  # Buyout + first year salary
            
            if acquiring_team.budget.cash < total_cost * 1.5:  # Need 50% buffer
                continue
            
            # AI decision: probability based on driver quality vs cost
            driver_value = driver.overall_rating
            cost_ratio = buyout / acquiring_team.budget.cash
            
            # Higher rated drivers are more attractive
            # But expensive buyouts reduce appeal
            poach_probability = (driver_value / 100.0) * (1.0 - cost_ratio)
            
            # Boost probability if acquiring team is desperate for talent
            avg_driver_rating = sum(d.overall_rating for d in acquiring_team.drivers if d) / max(1, len([d for d in acquiring_team.drivers if d]))
            if driver_value > avg_driver_rating + 10:
                poach_probability *= 1.5  # 50% boost for significant upgrade
            
            # Roll the dice
            if random.random() > poach_probability:
                continue
            
            # Execute AI poaching transaction
            _dbg(f"[FTB AI POACH] {acquiring_team.name} attempting to poach {driver.name} from {original_team.name} for ${buyout:,}")
            
            # 1. Pay buyout
            acquiring_team.budget.cash -= buyout
            original_team.budget.cash += buyout
            
            # 2. Remove from original team
            original_team.drivers = [d for d in original_team.drivers if d != driver]
            original_team.budget.remove_staff_salary(driver.name)
            
            # 3. Terminate old contract
            entity_id = driver.entity_id
            if entity_id in self.contracts:
                del self.contracts[entity_id]
            
            # 4. Reset morale (fresh start)
            if hasattr(driver, 'morale'):
                driver.morale = 65.0  # AI teams start with good morale
            
            # 5. Create new contract (AI offers better terms to attract)
            new_salary = int(contract.base_salary * 1.25)  # 25% raise
            new_contract = Contract(
                entity_id=entity_id,
                entity_name=driver.name,
                team_name=acquiring_team.name,
                role="Driver",
                start_day=current_day,
                duration_days=Contract.seasons_to_days(2),  # 2 seasons
                base_salary=new_salary,
                seasons_duration=2,
                signing_bonus=int(new_salary * 0.3),
                poaching_protection_until=current_day + 30  # 30-day protection
            )
            
            self.contracts[entity_id] = new_contract
            
            # 6. Add to acquiring team
            acquiring_team.drivers.append(driver)
            acquiring_team.budget.add_staff_salary(driver.name, new_salary)
            
            # Pay signing bonus
            acquiring_team.budget.cash -= new_contract.signing_bonus
            
            # 7. Generate event
            events.append(SimEvent(
                event_type="transaction",
                category="ai_driver_poached",
                ts=self.tick,
                priority=75.0,  # High priority for player awareness
                severity="major",
                data={
                    'driver': driver.name,
                    'from_team': original_team.name,
                    'to_team': acquiring_team.name,
                    'buyout': buyout,
                    'new_salary': new_salary,
                    'rating': driver.overall_rating,
                    'message': f'{acquiring_team.name} poached {driver.name} from {original_team.name}'
                }
            ))
            
            _dbg(f"[FTB AI POACH] ✅ Success: {driver.name} -> {acquiring_team.name}")
            
            # Only one poaching per team per month to avoid chaos
            break
        
        return events
    
    def _should_ai_team_poach(self, team: 'Team') -> bool:
        """Check if AI team should attempt poaching this tick"""
        # Need sufficient budget
        if team.budget.cash < 500000:  # $500k minimum
            return False
        
        # Check if team needs driver upgrades
        if not team.drivers:
            return False
        
        avg_driver_rating = sum(d.overall_rating for d in team.drivers if d) / max(1, len([d for d in team.drivers if d]))
        
        # Higher tier teams are more aggressive
        tier_aggression = {
            1: 0.05,  # 5% chance per month for Grassroots
            2: 0.10,  # 10% for Formula V
            3: 0.15,  # 15% for Formula X
            4: 0.25,  # 25% for Formula Y
            5: 0.35   # 35% for Formula Z
        }
        
        base_chance = tier_aggression.get(team.tier, 0.10)
        
        # Boost if drivers are weak for tier
        tier_expected_rating = {1: 45, 2: 55, 3: 65, 4: 75, 5: 85}
        expected = tier_expected_rating.get(team.tier, 60)
        
        if avg_driver_rating < expected - 10:
            base_chance *= 2.0  # Double chance if drivers are weak
        
        import random
        return random.random() < base_chance
    
    def _find_best_poachable_driver_for_ai(self, acquiring_team: 'Team', current_day: int) -> Optional[Dict]:
        """Find the best available poachable driver for an AI team"""
        candidates = []
        
        # Search all leagues
        for league in self.leagues:
            for team in league.teams:
                # Don't poach from own team
                if team == acquiring_team:
                    continue
                
                # Don't poach from player team (player should control their roster)
                if team == self.player_team:
                    continue
                
                for driver in team.drivers:
                    if not driver:
                        continue
                    
                    entity_id = getattr(driver, 'entity_id', None)
                    if not entity_id or entity_id not in self.contracts:
                        continue
                    
                    contract = self.contracts[entity_id]
                    
                    # Check if poachable
                    if not contract.is_poachable(current_day) or not contract.open_to_offers:
                        continue
                    
                    buyout = contract.calculate_buyout_amount(team.tier, current_day)
                    
                    candidates.append({
                        'entity': driver,
                        'team': team,
                        'contract': contract,
                        'buyout': buyout,
                        'rating': driver.overall_rating
                    })
        
        if not candidates:
            return None
        
        # Sort by rating (best first)
        candidates.sort(key=lambda x: x['rating'], reverse=True)
        
        # Return best affordable option
        for candidate in candidates:
            total_cost = candidate['buyout'] + (candidate['contract'].base_salary * 1.2)
            if acquiring_team.budget.cash >= total_cost * 1.5:  # Need 50% buffer
                return candidate
        
        return None
    
    # ============================================================================
    # TEAM NAME VALIDATION & FREE AGENT MANAGEMENT
    # ============================================================================
    
    def validate_team_name(self, team_name: str, exclude_team: Optional[str] = None) -> bool:
        """Check if team name is unique (not used by any existing team)
        
        Args:
            team_name: Name to validate
            exclude_team: Optional team name to exclude from check (for renames)
        
        Returns:
            True if name is available, False if duplicate exists
        """
        # Check team name registry
        if team_name in self.team_name_registry:
            if exclude_team and team_name == exclude_team:
                return True  # Allow team to keep its own name
            return False
        
        return True
    
    def register_team_name(self, team_name: str) -> None:
        """Register a team name as taken"""
        self.team_name_registry.add(team_name)
    
    def unregister_team_name(self, team_name: str) -> None:
        """Unregister a team name (when team is disbanded/renamed)"""
        self.team_name_registry.discard(team_name)
    
    def add_to_free_agent_pool(self, entity: Entity, exit_reason: str, asking_salary: int) -> None:
        """Add an entity to the free agent pool
        
        Args:
            entity: Driver, Engineer, Mechanic, or Strategist
            exit_reason: Why they entered free agency (\"fired\", \"contract_expired\", etc.)
            asking_salary: Annual salary they're asking for
        """
        if entity is None:
            return

        for fa in self.free_agents:
            if fa.entity == entity:
                return
            if hasattr(fa.entity, 'entity_id') and hasattr(entity, 'entity_id'):
                if fa.entity.entity_id == entity.entity_id:
                    return

        free_agent = FreeAgent(
            entity=entity,
            asking_salary=asking_salary,
            time_in_pool_days=0,
            exit_reason=exit_reason
        )
        self.free_agents.append(free_agent)
    
    def remove_from_free_agent_pool(self, entity: Entity) -> bool:
        """Remove an entity from free agent pool (hired or retired)
        
        Returns:
            True if removed, False if not found
        """
        for i, fa in enumerate(self.free_agents):
            if fa.entity == entity:
                self.free_agents.pop(i)
                return True
        return False
    
    def age_free_agents(self) -> List[SimEvent]:
        """Increment time_in_pool_days for all free agents, remove expired ones
        
        Returns:
            List of retirement events for expired free agents
        """
        events = []
        expired_agents = []
        
        for fa in self.free_agents:
            fa.time_in_pool_days += self.days_per_tick
            
            # After 180 days (half-year), free agents retire or find non-racing work
            if fa.time_in_pool_days >= 180:
                expired_agents.append(fa)
                events.append(SimEvent(
                    event_type="structural",
                    category="free_agent_retired",
                    ts=self.tick,
                    priority=20.0,
                    severity="info",
                    data={
                        'entity_name': fa.entity.display_name if hasattr(fa.entity, 'display_name') else fa.entity.name,
                        'entity_type': fa.entity_type,
                        'time_in_pool_days': fa.time_in_pool_days,
                        'reason': 'No offers after 6 months'
                    }
                ))
        
        # Remove expired agents
        for fa in expired_agents:
            self.free_agents.remove(fa)
        
        return events
    
    def process_salary_payouts(self) -> List[SimEvent]:
        """Process bi-weekly salary payments for all teams (every 14 ticks)
        
        Uses the budget.staff_salaries system for accurate per-tick payroll.
        
        Returns:
            List of salary payout events
        """
        events = []
        
        all_teams = [self.player_team] + self.ai_teams if self.player_team else self.ai_teams
        
        for team in all_teams:
            if team is None:
                continue
            
            # Ensure staff salaries are up-to-date with roster
            team.ensure_staff_salaries()
            
            # Calculate 14-tick payroll (bi-weekly period)
            per_tick_payroll = team.budget.calculate_staff_payroll()
            bi_weekly_total = per_tick_payroll * 14
            
            # Deduct from team budget
            if bi_weekly_total > 0:
                team.budget.cash -= bi_weekly_total
                
                # Log transaction (only for player team)
                if team == self.player_team:
                    self.log_transaction(
                        type="expense",
                        category="payroll",
                        amount=bi_weekly_total,
                        description=f"Bi-weekly payroll (14 ticks × ${per_tick_payroll:,.0f}/tick)",
                        balance_after=team.budget.cash
                    )
                    
                    # Emit visible payout event for player team
                    events.append(SimEvent(
                        event_type="structural",
                        category="salary_payout",
                        ts=self.tick,
                        priority=60.0,
                        severity="info",
                        data={
                            'team': team.name,
                            'amount': bi_weekly_total,
                            'per_tick_payroll': per_tick_payroll,
                            'remaining_budget': team.budget.cash,
                            'period': 'bi-weekly',
                            'staff_count': len(team.budget.staff_salaries),
                            'message': f"Payroll: ${bi_weekly_total:,.0f} for {len(team.budget.staff_salaries)} staff members"
                        }
                    ))
                else:
                    # AI team: background event
                    events.append(SimEvent(
                        event_type="structural",
                        category="salary_payout",
                        ts=self.tick,
                        priority=20.0,
                        severity="background",
                        data={
                            'team': team.name,
                            'amount': bi_weekly_total,
                            'remaining_budget': team.budget.cash
                        }
                    ))
        
        return events
    
    # ============================================================================
    # CALENDAR PROJECTION SYSTEM - Forward-Looking Planning Layer
    # ============================================================================
    
    def get_calendar_projection(self, days_ahead: int = 60) -> List[Dict[str, Any]]:
        """
        Get comprehensive calendar projection showing all upcoming events.
        Returns sorted list of calendar entries for strategic planning.
        """
        entries = []
        current_day = self.sim_day_of_year
        end_day = current_day + days_ahead
        
        # Competition layer: races and season events
        race_entries = self._project_races(days_ahead)
        entries.extend(race_entries)
        
        # Personnel layer: contracts, negotiations
        personnel_entries = self._project_personnel_events(days_ahead)
        entries.extend(personnel_entries)
        
        # Financial layer: sponsor payments, salaries, upkeep
        financial_entries = self._project_financial_events(days_ahead)
        entries.extend(financial_entries)
        
        # Pressure layer: morale decay, sponsor patience
        pressure_entries = self._project_pressure_events(days_ahead)
        entries.extend(pressure_entries)
        
        # Sort by day, then priority
        entries.sort(key=lambda e: (e['entry_day'], -e.get('priority', 50)))
        
        return entries
    
    def _project_races(self, days_ahead: int) -> List[Dict[str, Any]]:
        """Project upcoming races and race-related events"""
        entries = []
        current_day = self.sim_day_of_year
        
        # Find player's league (only show travel for player's races)
        player_league = None
        if self.player_team:
            for league in self.leagues.values():
                if self.player_team in league.teams:
                    player_league = league
                    break
            if not player_league:
                _dbg(f"[FTB] CALENDAR_DEBUG: Player team '{self.player_team.name}' exists but is not in any league!")
                _dbg(f"[FTB] CALENDAR_DEBUG: Available leagues: {list(self.leagues.keys())}")
        else:
            _dbg(f"[FTB] CALENDAR_DEBUG: No player_team set! Cannot show calendar events.")
            _dbg(f"[FTB] CALENDAR_DEBUG: Available leagues: {list(self.leagues.keys())}")
        
        for league_id, league in self.leagues.items():
            # Check if this is the player's league (for travel events)
            is_player_league = (league == player_league)
            
            for entry in league.schedule:
                # Handle both old format (int) and new format (tuple/list)
                # Note: JSON serialization converts tuples to lists, so we check for both
                if isinstance(entry, (tuple, list)) and len(entry) == 2:
                    race_tick, track_id = entry
                else:
                    race_tick = entry
                    track_id = None
                
                # Ensure race_tick is an integer to prevent type errors
                race_tick = int(race_tick) if not isinstance(race_tick, int) else race_tick
                
                race_day = race_tick * self.days_per_tick
                days_until = race_day - current_day
                
                # Get track info
                track = self.tracks.get(track_id) if track_id else None
                track_name = track.name if track else "TBA"
                
                if 0 <= days_until <= days_ahead:
                    # Main race event - only for player's league
                    if is_player_league:
                        entries.append({
                            'entry_day': race_day,
                            'entry_type': 'race',
                            'category': 'competition',
                            'title': f"{league.name} Race #{league.races_this_season + 1}",
                            'description': f"Race weekend at {track_name}",
                            'priority': 80,
                            'action_required': False,
                            'metadata': {
                                'league_id': league_id,
                                'league_name': league.name,
                                'tier': league.tier,
                                'race_number': league.races_this_season + 1,
                                'track_id': track_id,
                                'track_name': track_name
                            }
                        })
                    
                    # Travel window (7 days before) - only for player's league
                    if is_player_league:
                        travel_day = race_day - 7
                        if travel_day >= current_day:
                            entries.append({
                                'entry_day': travel_day,
                                'entry_type': 'travel_window',
                                'category': 'competition',
                                'title': f"Travel to {track_name}",
                                'description': f"Team travels to circuit for {league.name} race",
                                'priority': 40,
                                'action_required': False,
                                'metadata': {
                                    'league_id': league_id,
                                    'for_race_day': race_day,
                                    'track_name': track_name
                                }
                            })
        
        return entries
    
    def _project_personnel_events(self, days_ahead: int) -> List[Dict[str, Any]]:
        """Project contract expiries, negotiations, development milestones"""
        entries = []
        current_day = self.sim_day_of_year
        
        for entity_id, contract in self.contracts.items():
            days_remaining = contract.days_remaining(current_day)
            expiry_day = current_day + days_remaining
            is_player_team = contract.team_name == (self.player_team.name if self.player_team else "")
            
            # Only show player team contracts in calendar
            if not is_player_team:
                continue
            
            if 0 <= days_remaining <= days_ahead:
                entity = self._find_entity_by_id(entity_id)
                entity_name = entity.display_name if (entity and hasattr(entity, 'display_name')) else entity.name if entity else f"Entity {entity_id}"
                
                # Contract expiry event
                entries.append({
                    'entry_day': expiry_day,
                    'entry_type': 'contract_expiry',
                    'category': 'personnel',
                    'title': f"{entity_name} contract expires ({contract.role})",
                    'description': f"Last day of contract. Decide: extend, renegotiate, or release.",
                    'priority': 70,
                    'action_required': True,
                    'metadata': {
                        'entity_id': entity_id,
                        'entity_name': entity_name,
                        'role': contract.role,
                        'salary': contract.base_salary,
                        'team': contract.team_name
                    }
                })
                
                # Negotiation window (30 days before expiry)
                negotiation_day = expiry_day - 30
                if negotiation_day >= current_day:
                    entries.append({
                        'entry_day': negotiation_day,
                        'entry_type': 'negotiation_window',
                        'category': 'personnel',
                        'title': f"{entity_name} negotiation window opens",
                        'description': f"Can renegotiate contract with {entity_name} starting today",
                        'priority': 50,
                        'action_required': False,
                        'metadata': {
                            'entity_id': entity_id,
                            'expiry_day': expiry_day,
                            'team': contract.team_name
                        }
                    })
        
        return entries
    
    def _project_financial_events(self, days_ahead: int) -> List[Dict[str, Any]]:
        """Project sponsor payments, salaries, upkeep costs"""
        entries = []
        current_day = self.sim_day_of_year
        
        if not self.player_team:
            return entries
        
        # Salary payouts (every 7 days)
        next_salary_day = ((current_day // 7) + 1) * 7
        while next_salary_day <= current_day + days_ahead:
            total_salaries = sum(c.base_salary // 52 for c in self.contracts.values() 
                               if c.team_name == self.player_team.name)  # Weekly portion
            
            entries.append({
                'entry_day': next_salary_day,
                'entry_type': 'salary_payout',
                'category': 'financial',
                'title': f"Weekly salary payout (~${total_salaries:,})",
                'description': "Team salary obligations due",
                'priority': 60,
                'action_required': False,
                'metadata': {'amount': total_salaries}
            })
            next_salary_day += 7
        
        # Sponsor payments and events (monthly - every 30 d ticks)
        if hasattr(self, 'sponsorships') and self.player_team and self.player_team.name in self.sponsorships:
            for sponsor in self.sponsorships.get(self.player_team.name, []):
                # Calculate monthly payment projections
                months_ahead = days_ahead // 30
                for month in range(1, months_ahead + 1):
                    payment_day = current_day + (month * 30)
                    
                    # Color-code by confidence
                    if sponsor.confidence >= 60:
                        icon = "✓"
                        priority = 50
                    elif sponsor.confidence >= 40:
                        icon = "⚠"
                        priority = 55
                    else:
                        icon = "✗"
                        priority = 65
                    
                    payment_amount = sponsor.base_payment_per_season // 12  # Monthly portion
                    entries.append({
                        'entry_day': payment_day,
                        'entry_type': 'sponsor_payment',
                        'category': 'financial',
                        'title': f"{icon} {sponsor.sponsor_name} payment (+${payment_amount:,})",
                        'description': f"Sponsor income (confidence: {sponsor.confidence:.0f}%)",
                        'priority': priority,
                        'action_required': False,
                        'metadata': {'sponsor': sponsor.sponsor_name, 'amount': payment_amount, 'confidence': sponsor.confidence}
                    })
                
                # Evaluation milestones
                next_eval_day = current_day + sponsor.evaluation_cadence
                while next_eval_day <= current_day + days_ahead:
                    entries.append({
                        'entry_day': next_eval_day,
                        'entry_type': 'sponsor_evaluation',
                        'category': 'pressure',
                        'title': f"⚖ {sponsor.sponsor_name} evaluates performance",
                        'description': f"Performance review (current: {sponsor.confidence:.0f}%)",
                        'priority': 60,
                        'action_required': False,
                        'metadata': {'sponsor': sponsor.sponsor_name, 'confidence': sponsor.confidence}
                    })
                    next_eval_day += sponsor.evaluation_cadence
                
                # Contract expiration warning
                seasons_left = sponsor.duration_seasons - sponsor.seasons_active
                if seasons_left <= 1:
                    contract_end_day = current_day + (seasons_left * 365)
                    if contract_end_day <= current_day + days_ahead:
                        entries.append({
                            'entry_day': contract_end_day,
                            'entry_type': 'sponsor_contract_end',
                            'category': 'opportunity',
                            'title': f"🔔 {sponsor.sponsor_name} contract ends",
                            'description': "Renewal negotiation available",
                            'priority': 70,
                            'action_required': True,
                            'metadata': {'sponsor': sponsor.sponsor_name}
                        })
                
                # Low confidence warning projection
                if sponsor.confidence < 50 and not sponsor.warning_issued:
                    entries.append({
                        'entry_day': current_day + 7,  # Urgent warning
                        'entry_type': 'sponsor_warning',
                        'category': 'pressure',
                        'title': f"⚠ {sponsor.sponsor_name} patience warning",
                        'description': f"Confidence low ({sponsor.confidence:.0f}%) - improve performance!",
                        'priority': 75,
                        'action_required': True,
                        'metadata': {'sponsor': sponsor.sponsor_name, 'confidence': sponsor.confidence}
                    })
        
        # Facility upkeep (monthly)
        next_upkeep_day = ((current_day // 30) + 1) * 30
        if next_upkeep_day <= current_day + days_ahead:
            upkeep_cost = getattr(self.player_team, 'facility_upkeep_cost', 5000)
            entries.append({
                'entry_day': next_upkeep_day,
                'entry_type': 'facility_upkeep',
                'category': 'financial',
                'title': f"Facility upkeep due (-${upkeep_cost:,})",
                'description': "Monthly facility maintenance costs",
                'priority': 55,
                'action_required': False,
                'metadata': {'amount': upkeep_cost}
            })
        
        # Cash runway warning (if burning cash)
        if hasattr(self.player_team, 'budget'):
            current_cash = self.player_team.budget.cash
            # Estimate daily burn: (salaries + upkeep) / days
            total_salaries = sum(c.base_salary for c in self.contracts.values() 
                               if c.team_name == self.player_team.name)
            upkeep_cost = getattr(self.player_team, 'facility_upkeep_cost', 5000)
            daily_burn = (total_salaries / 365) + (upkeep_cost / 30)
            days_of_cash = current_cash / daily_burn if daily_burn > 0 else 999
            
            if days_of_cash < 30:  # Less than 30 days of cash
                warning_day = current_day + int(days_of_cash * 0.8)  # Warn at 80% of runway
                if warning_day <= current_day + days_ahead:
                    entries.append({
                        'entry_day': warning_day,
                        'entry_type': 'cash_runway_warning',
                        'category': 'financial',
                        'title': f"Cash runway critical ({int(days_of_cash)} days remaining)",
                        'description': f"At current burn rate (${daily_burn:.0f}/day), cash depletes in {int(days_of_cash)} days",
                        'priority': 90,
                        'action_required': True,
                        'metadata': {'days_remaining': int(days_of_cash), 'daily_burn': daily_burn, 'current_cash': current_cash}
                    })
        
        return entries
    
    def _project_pressure_events(self, days_ahead: int) -> List[Dict[str, Any]]:
        """Project morale decay, sponsor patience, board ultimatums"""
        entries = []
        current_day = self.sim_day_of_year
        
        if not self.player_team:
            return entries
        
        # Morale decay warnings
        current_morale = self.player_team.standing_metrics.get('morale', 50.0)
        if current_morale < 50:
            # Estimate decay rate (rough heuristic: -1 per week if below 50)
            decay_rate = -1.0 / 7  # per day
            critical_threshold = 30
            days_until_critical = (current_morale - critical_threshold) / abs(decay_rate)
            
            if days_until_critical > 0 and days_until_critical <= days_ahead:
                warning_day = current_day + int(days_until_critical)
                entries.append({
                    'entry_day': warning_day,
                    'entry_type': 'morale_warning',
                    'category': 'pressure',
                    'title': f"Team morale approaching critical ({critical_threshold})",
                    'description': f"Current morale {current_morale:.1f}, trending toward crisis threshold",
                    'priority': 75,
                    'action_required': False,
                    'metadata': {'current_morale': current_morale, 'threshold': critical_threshold, 'days_until': int(days_until_critical)}
                })
        
        # Sponsor patience (if confidence < 50)
        for sponsor in self.sponsorships.get(self.player_team.name, []):
            if sponsor.confidence < 50:
                # Estimate patience window: confidence / 2 days (rough)
                days_until_exit = int(sponsor.confidence / 2)
                if days_until_exit <= days_ahead:
                    warning_day = current_day + days_until_exit
                    entries.append({
                        'entry_day': warning_day,
                        'entry_type': 'sponsor_patience_warning',
                        'category': 'pressure',
                        'title': f"{sponsor.sponsor_name} patience expiring",
                        'description': f"Sponsor confidence at {sponsor.confidence:.0f}%, may terminate soon",
                        'priority': 80,
                        'action_required': True,
                        'metadata': {'sponsor': sponsor.sponsor_name, 'confidence': sponsor.confidence, 'days_until': days_until_exit}
                    })
        
        return entries
    
    def get_decision_inbox(self) -> List[Dict[str, Any]]:
        """Get filtered calendar entries requiring player action"""
        projection = self.get_calendar_projection(days_ahead=30)
        return [e for e in projection if e.get('action_required', False)]

    def _normalize_ratings(self, ratings: Any, schema_key: str) -> Dict[str, float]:
        """Coerce rating values to floats and fill missing schema defaults."""
        schema = STATS_SCHEMAS.get(schema_key, {})
        normalized = schema.copy() if isinstance(schema, dict) else {}

        if isinstance(ratings, dict):
            for key, value in ratings.items():
                value_num = _coerce_float(value, None)
                if value_num is None:
                    continue
                normalized[key] = value_num

        if not normalized and isinstance(schema, dict):
            normalized = schema.copy()

        return normalized
    
    def _serialize_entity(self, entity: Optional[Entity]) -> Optional[Dict[str, Any]]:
        """Helper to serialize any entity"""
        if entity is None:
            return None
        return {
            'name': entity.name,
            'display_name': entity.display_name,
            'entity_id': entity.entity_id,
            'age': entity.age,
            'potential_ceiling': entity.potential_ceiling,
            'decay_rate': entity.decay_rate,
            'variance_band': entity.variance_band,
            'form_momentum': entity.form_momentum,
            'current_ratings': entity.current_ratings,
            'performance_history': entity.performance_history,
        }
    
    def _deserialize_entity(self, data: Dict[str, Any], entity_class) -> Entity:
        """Helper to deserialize any entity"""
        entity = entity_class(name=data.get('name', 'Unknown'), age=data.get('age', 20))
        entity.display_name = data.get('display_name', '')
        entity.entity_id = data.get('entity_id', 0)
        entity.potential_ceiling = data.get('potential_ceiling', 100.0)
        entity.decay_rate = data.get('decay_rate', 0.5)
        entity.variance_band = data.get('variance_band', 5.0)
        entity.form_momentum = data.get('form_momentum', 0.0)
        entity.current_ratings = self._normalize_ratings(data.get('current_ratings', {}), entity_class.__name__)
        entity.performance_history = data.get('performance_history', [])
        return entity
    
    def _serialize_manufacturer(self, mfr: Manufacturer) -> Dict[str, Any]:
        """Serialize a manufacturer with heritage and tier data"""
        base = self._serialize_entity(mfr)
        base.update({
            'heritage_nationality': mfr.nationality,
            'active_tiers': list(mfr.active_tiers),  # Convert set to list for JSON
            'foundation_year': mfr.founded_year,
        })
        return base
    
    def _deserialize_manufacturer(self, data: Dict[str, Any]) -> Manufacturer:
        """Deserialize a manufacturer"""
        mfr = Manufacturer(
            name=data.get('name', 'Unknown Mfr'),
            age=data.get('age', 0),
            nationality=data.get('heritage_nationality', 'International')
        )
        mfr.potential_ceiling = data.get('potential_ceiling', 100.0)
        mfr.decay_rate = data.get('decay_rate', 0.5)
        mfr.variance_band = data.get('variance_band', 5.0)
        mfr.form_momentum = data.get('form_momentum', 0.0)
        mfr.current_ratings = self._normalize_ratings(data.get('current_ratings', {}), 'Manufacturer')
        mfr.performance_history = data.get('performance_history', [])
        mfr.active_tiers = set(data.get('active_tiers', []))  # Convert list back to set
        mfr.founded_year = data.get('foundation_year', 1)
        return mfr
    
    def _serialize_part(self, part: Part) -> Dict[str, Any]:
        """Serialize a part with metadata"""
        base = self._serialize_entity(part)
        base.update({
            'part_id': part.part_id,
            'part_type': part.part_type,
            'manufacturer_id': part.manufacturer_id,
            'tier_availability': part.tier_availability,
            'generation': part.generation,
            'release_year': part.introduction_year,
            'compatibility_tags': part.compatibility_tags,
            'regulatory_exposure': part.regulatory_exposure,
            'effectiveness_modifier': part.effectiveness_modifier,
            'install_quality': part.install_quality,
        })
        return base
    
    def _deserialize_part(self, data: Dict[str, Any]) -> Part:
        """Deserialize a part"""
        part = Part(
            name=data.get('name', 'Unknown Part'),
            age=data.get('age', 0),
            part_id=data.get('part_id', 'part_0'),
            part_type=data.get('part_type', 'engine'),
            manufacturer_id=data.get('manufacturer_id', 'mfr_0'),
            tier_availability=data.get('tier_availability', [1])
        )
        part.potential_ceiling = data.get('potential_ceiling', 100.0)
        part.decay_rate = data.get('decay_rate', 0.5)
        part.variance_band = data.get('variance_band', 5.0)
        part.form_momentum = data.get('form_momentum', 0.0)
        # Fix: Initialize from schema if current_ratings is missing or empty
        loaded_ratings = data.get('current_ratings', {})
        part.current_ratings = self._normalize_ratings(loaded_ratings, 'Part')
        part.performance_history = data.get('performance_history', [])
        part.generation = data.get('generation', 1)
        part.introduction_year = data.get('release_year', 1)
        part.compatibility_tags = data.get('compatibility_tags', set())
        part.regulatory_exposure = data.get('regulatory_exposure', {})
        
        # Restore effectiveness_modifier and install_quality (default to full effectiveness if not present)
        part.effectiveness_modifier = data.get('effectiveness_modifier', 1.0)
        part.install_quality = data.get('install_quality', 100.0)
        
        # Migration fix: Add regulatory exposure for legacy parts that don't have it
        if not part.regulatory_exposure:
            import random
            part.regulatory_exposure = {
                'structural_margin': random.uniform(0.0, 1.0),
                'aero_freedom': random.uniform(0.0, 1.0),
                'power_ceiling': random.uniform(0.0, 1.0),
                'reliability_mandate': random.uniform(0.0, 1.0),
                'cost_cap_friendly': random.uniform(0.0, 1.0)
            }
        
        return part
    
    def _serialize_free_agent(self, fa: 'FreeAgent') -> Dict[str, Any]:
        """Serialize a free agent"""
        return {
            'entity': self._serialize_entity(fa.entity),
            'entity_type': fa.entity_type,
            'asking_salary': fa.asking_salary,
            'contract_length_preference': fa.contract_length_preference,
            'entered_market_tick': fa.entered_market_tick,
            'entered_market_day': fa.entered_market_day,
            'interested_in_tier': fa.interested_in_tier,
            'reputation_threshold': fa.reputation_threshold,
        }
    
    def _deserialize_free_agent(self, data: Dict[str, Any]) -> 'FreeAgent':
        """Deserialize a free agent"""
        entity_data = data.get('entity', {})
        entity_type = data.get('entity_type', 'driver')
        
        # Map entity_type to entity class
        entity_class_map = {
            'driver': Driver,
            'engineer': Engineer,
            'mechanic': Mechanic,
            'strategist': Strategist
        }
        entity_class = entity_class_map.get(entity_type, Driver)
        entity = self._deserialize_entity(entity_data, entity_class)
        
        fa = FreeAgent(
            entity=entity,
            entity_type=entity_type,
            asking_salary=data.get('asking_salary', 50000.0),
            contract_length_preference=data.get('contract_length_preference', 2)
        )
        fa.entered_market_tick = data.get('entered_market_tick', 0)
        fa.entered_market_day = data.get('entered_market_day', 0)
        fa.interested_in_tier = data.get('interested_in_tier', 1)
        fa.reputation_threshold = data.get('reputation_threshold', 0.0)
        return fa
    
    def _serialize_job_listing(self, listing: JobListing) -> Dict[str, Any]:
        """Serialize a job listing"""
        return {
            'team_name': listing.team_name,
            'role': listing.role,
            'expectation_band': listing.expectation_band,
            'salary_offer': listing.salary_offer,
            'contract_duration_seasons': listing.contract_duration_seasons,
            'created_tick': listing.created_tick,
            'visibility_threshold': listing.visibility_threshold,
        }
    
    def _deserialize_job_listing(self, data: Dict[str, Any]) -> JobListing:
        """Deserialize a job listing"""
        return JobListing(
            team_name=data.get('team_name', 'Unknown Team'),
            role=data.get('role', 'driver'),
            expectation_band=data.get('expectation_band', (50.0, 70.0)),
            salary_offer=data.get('salary_offer', 50000.0),
            contract_duration_seasons=data.get('contract_duration_seasons', 2),
            created_tick=data.get('created_tick', 0),
            visibility_threshold=data.get('visibility_threshold', 0.0)
        )
    
    def _serialize_race_result(self, result: 'RaceResult') -> Dict[str, Any]:
        """Serialize a race result with full lap data"""
        return {
            'race_id': result.race_id,
            'league_id': result.league_id,
            'league_name': result.league_name,
            'track_id': result.track_id,
            'track_name': result.track_name,
            'season': result.season,
            'round_number': result.round_number,
            'laps': [
                {
                    'lap_number': lap.lap_number,
                    'driver_name': lap.driver_name,
                    'team_name': lap.team_name,
                    'lap_time': lap.lap_time,
                    'position': lap.position,
                    'tire_compound': lap.tire_compound,
                    'tire_age': lap.tire_age,
                    'gap_to_leader': lap.gap_to_leader,
                    'gap_to_ahead': lap.gap_to_ahead,
                    'sector_1': lap.sector_1,
                    'sector_2': lap.sector_2,
                    'sector_3': lap.sector_3,
                }
                for lap in result.laps
            ],
            'race_events': [
                {
                    'lap_number': evt.lap_number,
                    'event_type': evt.event_type,
                    'involved_drivers': evt.involved_drivers,
                    'description': evt.description,
                    'position_change': evt.position_change,
                    'metadata': evt.metadata,
                }
                for evt in result.race_events
            ],
            'final_positions': result.final_positions,
            'fastest_lap': result.fastest_lap,
            'telemetry': result.telemetry,
        }
    
    def _deserialize_race_result(self, data: Dict[str, Any]) -> 'RaceResult':
        """Deserialize a race result"""
        laps = [
            LapData(
                lap_number=lap['lap_number'],
                driver_name=lap['driver_name'],
                team_name=lap['team_name'],
                lap_time=lap['lap_time'],
                position=lap['position'],
                tire_compound=lap['tire_compound'],
                tire_age=lap['tire_age'],
                gap_to_leader=lap['gap_to_leader'],
                gap_to_ahead=lap['gap_to_ahead'],
                sector_1=lap['sector_1'],
                sector_2=lap['sector_2'],
                sector_3=lap['sector_3'],
            )
            for lap in data.get('laps', [])
        ]
        
        race_events = [
            RaceEventRecord(
                lap_number=evt['lap_number'],
                event_type=evt['event_type'],
                involved_drivers=evt['involved_drivers'],
                description=evt['description'],
                position_change=evt.get('position_change', {}),
                metadata=evt.get('metadata', {}),
            )
            for evt in data.get('race_events', [])
        ]
        
        return RaceResult(
            race_id=data.get('race_id', ''),
            league_id=data.get('league_id', ''),
            league_name=data.get('league_name', ''),
            track_id=data.get('track_id', ''),
            track_name=data.get('track_name', ''),
            season=data.get('season', 1),
            round_number=data.get('round_number', 1),
            laps=laps,
            race_events=race_events,
            final_positions=[tuple(pos) for pos in data.get('final_positions', [])],
            fastest_lap=tuple(data['fastest_lap']) if data.get('fastest_lap') else None,
            telemetry=data.get('telemetry', {}),
        )
    
    def save_to_json(self, path: str) -> None:
        """Serialize state to JSON with full entity persistence"""
        def serialize_team(team: Team) -> Dict[str, Any]:
            return {
                'name': team.name,
                'budget': {
                    'cash': team.budget.cash,
                    'burn_rate': team.budget.burn_rate,
                    'committed_spend': team.budget.committed_spend,
                    'income_streams': [(inc.name, inc.amount, inc.frequency) for inc in team.budget.income_streams],
                    'staff_salaries': team.budget.staff_salaries,
                },
                'drivers': [self._serialize_entity(d) for d in team.drivers],
                'engineers': [self._serialize_entity(e) for e in team.engineers],
                'mechanics': [self._serialize_entity(m) for m in team.mechanics],
                'strategist': self._serialize_entity(team.strategist),
                'principal': self._serialize_entity(team.principal),
                'car': self._serialize_entity(team.car),
                'infrastructure': team.infrastructure,
                'standing_metrics': team.standing_metrics,
                'tier': team.tier,
                'league_id': team.league_id,
                'tier_name': team.tier_name,
                'parts_inventory': [part.part_id for part in team.parts_inventory],
                'equipped_parts': {slot: part.part_id for slot, part in team.equipped_parts.items()},
                'manufacturer_contracts': team.manufacturer_contracts,
                'active_rd_projects': [
                    {
                        'project_id': p.project_id,
                        'project_name': p.project_name,
                        'project_type': p.project_type,
                        'team_name': p.team_name,
                        'total_cost': p.total_cost,
                        'duration_ticks': p.duration_ticks,
                        'started_tick': p.started_tick,
                        'progress_ticks': p.progress_ticks,
                        'completed': p.completed,
                        'cancelled': p.cancelled,
                        'base_success_rate': p.base_success_rate,
                        'current_success_rate': p.current_success_rate,
                        'target_stat': p.target_stat,
                        'target_improvement': p.target_improvement,
                        'generates_part': p.generates_part,
                        'part_type': p.part_type,
                        'description': p.description,
                        'risk_level': p.risk_level,
                        'assigned_engineer_ids': p.assigned_engineer_ids
                    }
                    for p in team.active_rd_projects
                ],
                'installed_upgrades': team.installed_upgrades,
            }
        
        data = {
            'save_version': 3,  # BUMPED TO v3 for AI Delegate System (player principal always exists)
            'tick': self.tick,
            'phase': self.phase,
            'sim_year': self.sim_year,
            'sim_day_of_year': self.sim_day_of_year,
            'days_per_tick': self.days_per_tick,
            'days_per_year': self.days_per_year,
            'races_completed_this_season': self.races_completed_this_season,
            'season_number': self.season_number,
            'in_offseason': self.in_offseason,
            'offseason_ticks_remaining': self.offseason_ticks_remaining,
            'race_day_active': self.race_day_active,
            'race_day_duration_sec': self.race_day_duration_sec,
            'completed_race_ticks': list(self.completed_race_ticks),
            'prompted_race_ticks': list(self.prompted_race_ticks),
            'time_mode': self.time_mode,
            'control_mode': self.control_mode,
            'delegation_settings': self.delegation_settings,
            'audio_settings': self.audio_settings,
            'delegation_focus': {
                'focus_text': self.delegation_focus.focus_text,
                'active_modifiers': self.delegation_focus.active_modifiers,
                'applied_at': self.delegation_focus.applied_at,
                'narrative_summary': self.delegation_focus.narrative_summary
            } if self.delegation_focus else None,
            'save_mode': self.save_mode,
            'seed': self.seed,
            'game_id': self.game_id,
            'player_identity': self.player_identity,
            'player_focus': self.player_focus,
            'player_age': self.player_age,
            'manager_first_name': self.manager_first_name,
            'manager_last_name': self.manager_last_name,
            'player_team': serialize_team(self.player_team) if self.player_team else None,
            'ai_teams': [serialize_team(t) for t in self.ai_teams],
            'leagues': {
                name: {
                    'name': lg.name,
                    'tier': lg.tier,
                    'tier_name': lg.tier_name,
                    'team_names': [t.name for t in lg.teams],
                    'schedule': lg.schedule,
                    'championship_table': lg.championship_table,
                    'driver_championship': lg.driver_championship,
                    'races_this_season': lg.races_this_season,
                    'hype': getattr(lg, 'hype', 1.0),
                    'hype_events_this_season': getattr(lg, 'hype_events_this_season', 0)
                } 
                for name, lg in self.leagues.items()
            },
            'world_state': self.world_state,
            'pending_developments': self.pending_developments,
            'pending_decisions': [
                {
                    'decision_id': d.decision_id,
                    'category': d.category,
                    'prompt': d.prompt,
                    'options': [{'id': opt.id, 'label': opt.label, 'cost': opt.cost, 
                                'description': opt.description, 'consequence_preview': opt.consequence_preview}
                               for opt in d.options],
                    'deadline_tick': d.deadline_tick,
                    'auto_resolve_option_id': d.auto_resolve_option_id,
                    'created_tick': d.created_tick,
                    'resolved': d.resolved,
                    'chosen_option_id': d.chosen_option_id
                }
                for d in self.pending_decisions
            ],
            'event_history': [
                {
                    'event_type': e.event_type,
                    'category': e.category,
                    'ts': e.ts,
                    'priority': e.priority,
                    'severity': e.severity,
                    'data': e.data,
                    'event_id': e.event_id,
                    'caused_by': e.caused_by
                }
                for e in self.event_history[-100:]  # Save last 100 events
            ],
            '_next_event_id': self._next_event_id,
            'rng_state': random.getstate() if hasattr(self, 'rng') else None,
            'manufacturers': {mfr_id: self._serialize_manufacturer(mfr) for mfr_id, mfr in self.manufacturers.items()},
            'parts_catalog': {part_id: self._serialize_part(part) for part_id, part in self.parts_catalog.items()},
            'parts_generation_counter': self.parts_generation_counter,
            'current_meta': self.current_meta,
            'contracts': {
                str(entity_id): {
                    'entity_id': c.entity_id,
                    'entity_name': c.entity_name,
                    'team_name': c.team_name,
                    'role': c.role,
                    'start_day': c.start_day,
                    'duration_days': c.duration_days,
                    'base_salary': c.base_salary,
                    'performance_clauses': c.performance_clauses,
                    'exit_clauses': c.exit_clauses,
                    'seasons_duration': c.seasons_duration,
                    'signing_bonus': c.signing_bonus,
                    'negotiation_round': c.negotiation_round,
                    'last_offer_rejected': c.last_offer_rejected
                }
                for entity_id, c in self.contracts.items()
            },
            'sponsorships': {
                team_name: [
                    {
                        'sponsor_name': s.sponsor_name,
                        'tier': s.tier,
                        'base_payment_per_season': s.base_payment_per_season,
                        'performance_multipliers': s.performance_multipliers,
                        'duration_seasons': s.duration_seasons,
                        'reputation_threshold': s.reputation_threshold,
                        'seasons_active': s.seasons_active,
                        'warning_issued': s.warning_issued,
                        # Extended fields
                        'sponsor_id': s.sponsor_id,
                        'industry': s.industry,
                        'sub_industry': s.sub_industry,
                        'financial_tier': s.financial_tier,
                        'brand_profile_json': s.brand_profile_json,
                        'contract_behavior_json': s.contract_behavior_json,
                        'activation_style_json': s.activation_style_json,
                        'narrative_hooks_json': s.narrative_hooks_json,
                        'confidence': s.confidence,
                        'performance_history': s.performance_history,
                        'contract_type': s.contract_type,
                        'evaluation_cadence': s.evaluation_cadence,
                        'signed_tick': s.signed_tick,
                        'last_evaluated_tick': s.last_evaluated_tick,
                        'exclusivity_clauses': s.exclusivity_clauses,
                        'total_paid_this_season': s.total_paid_this_season,
                        'last_payment_tick': s.last_payment_tick
                    }
                    for s in sponsors
                ]
                for team_name, sponsors in self.sponsorships.items()
            },
            'pending_sponsor_offers': {
                team_name: [
                    {
                        'sponsor_name': s.sponsor_name,
                        'tier': s.tier,
                        'base_payment_per_season': s.base_payment_per_season,
                        'performance_multipliers': s.performance_multipliers,
                        'duration_seasons': s.duration_seasons,
                        'sponsor_id': s.sponsor_id,
                        'industry': s.industry,
                        'sub_industry': s.sub_industry,
                        'financial_tier': s.financial_tier,
                        'brand_profile_json': s.brand_profile_json,
                        'contract_behavior_json': s.contract_behavior_json,
                        'activation_style_json': s.activation_style_json,
                        'narrative_hooks_json': s.narrative_hooks_json,
                        'contract_type': s.contract_type,
                        'evaluation_cadence': s.evaluation_cadence,
                        'exclusivity_clauses': s.exclusivity_clauses
                    }
                    for s in offers
                ]
                for team_name, offers in self.pending_sponsor_offers.items()
            },
            # CRITICAL FIX: Save free agents and job board
            'free_agents': [self._serialize_free_agent(fa) for fa in self.free_agents],
            'job_board': {
                'vacancies': [self._serialize_job_listing(v) for v in self.job_board.vacancies]
            },
            # CRITICAL FIX: Save race results for quali/race result display
            '_last_race_results': {
                league_id: self._serialize_race_result(result)
                for league_id, result in self._last_race_results.items()
            },
            '_last_race_contexts': self._last_race_contexts,
        }
        # Ensure parent directory exists
        os.makedirs(os.path.dirname(os.path.abspath(path)), exist_ok=True)
        with open(path, 'w') as f:
            json.dump(data, f, indent=2)
    
    @staticmethod
    def load_from_json(path: str) -> 'SimState':
        """Deserialize state from JSON with full entity restoration"""
        state = SimState()
        if not os.path.exists(path):
            return state
        
        with open(path, 'r') as f:
            data = json.load(f)
            
        # Version check and migration
        version = data.get('save_version', 0)
        if version < 2:
            raise ValueError(f"Save file version {version} is too old (v2+ required). "
                           "This is an alpha refactor - please start a new game.")
        
        # V2 → V3 migration: player team now has principal
        if version == 2:
            _dbg("[FTB] Migrating save from v2 to v3 (AI Delegate System)...")
            # Migration happens during team deserialization:
            # - If player team has no principal, create one from player_identity
            # - If delegation_focus is missing, set to None (already default)
        
        state.tick = data.get('tick', 0)
        state.phase = data.get('phase', 'offseason')
        state.sim_year = data.get('sim_year', 1)
        state.sim_day_of_year = data.get('sim_day_of_year', 1)
        state.days_per_tick = data.get('days_per_tick', 1)
        state.days_per_year = data.get('days_per_year', 365)
        state.races_completed_this_season = data.get('races_completed_this_season', 0)
        state.season_number = data.get('season_number', 1)
        state.in_offseason = data.get('in_offseason', False)
        state.offseason_ticks_remaining = data.get('offseason_ticks_remaining', 0)
        state.race_day_active = bool(data.get('race_day_active', False))
        state.race_day_duration_sec = int(data.get('race_day_duration_sec', 300))
        state.race_day_started_ts = None
        state._live_pbp_interval = None
        
        # CRITICAL FIX: Always reset race_day_active on load to prevent stale state
        if state.race_day_active:
            state.race_day_active = False
        
        # Load race tracking sets (handle old saves that don't have these)
        state.completed_race_ticks = set(tuple(entry) for entry in data.get('completed_race_ticks', []))
        state.prompted_race_ticks = set(tuple(entry) for entry in data.get('prompted_race_ticks', []))
        
        # CRITICAL FIX: Ensure race_day_state exists and is properly reset
        # Old saves won't have this field, so we need to initialize it
        # ALWAYS create race_day_state even if ftb_race_day import failed
        if ftb_race_day:
            from plugins.ftb_race_day import RaceDayState, RaceDayPhase
            
            # Try to load from save data
            if 'race_day_state' in data and data['race_day_state']:
                # Has race day state in save - but always reset to IDLE on load
                # to prevent stale "RACE_RUNNING" or other active states
                state.race_day_state = RaceDayState()
                state.race_day_state.phase = RaceDayPhase.IDLE
                # Preserve completed/prompted tracking from loaded state if present
                # (These fields are loaded separately above)
            else:
                # Old save without race_day_state - create fresh
                state.race_day_state = RaceDayState()
                state.race_day_state.phase = RaceDayPhase.IDLE
        else:
            # ftb_race_day module not available - create minimal stub
            # This prevents races from being blocked
            class _MinimalPhase:
                value = "idle"
                name = "IDLE"
            
            class _MinimalRaceDayState:
                def __init__(self):
                    self.phase = _MinimalPhase()
                    self.race_tick = None
                    self.league_id = None
                    self.track_id = None
            
            state.race_day_state = _MinimalRaceDayState()
            _dbg(f"[FTB LOAD] ⚠️  ftb_race_day not available - using minimal stub")
        
        _dbg(f"[FTB LOAD] ✅ Race day state reset to IDLE (completed_races={len(state.completed_race_ticks)}, prompted={len(state.prompted_race_ticks)})")
        
        # CRITICAL FIX: For old saves, infer completed races from league race counters
        # This prevents re-running already completed races
        if len(state.completed_race_ticks) == 0 and state.leagues:
            _dbg(f"[FTB LOAD] 🔧 Old save detected - reconstructing race history...")
            for league_id, league in state.leagues.items():
                # If league has completed races but no completed_race_ticks,
                # mark those early race ticks as completed
                if league.races_this_season > 0 and league.schedule:
                    for i in range(min(league.races_this_season, len(league.schedule))):
                        entry = league.schedule[i]
                        if isinstance(entry, (tuple, list)) and len(entry) >= 1:
                            race_tick = entry[0]
                        else:
                            race_tick = entry
                        
                        state.completed_race_ticks.add((league_id, int(race_tick)))
            
            if state.completed_race_ticks:
                _dbg(f"[FTB LOAD] ✅ Reconstructed {len(state.completed_race_ticks)} completed races from league history")
        
        state.time_mode = data.get('time_mode', 'paused')
        state.control_mode = data.get('control_mode', 'human')
        state.delegation_settings = data.get('delegation_settings', {
            'racing': False,
            'development': False,
            'contracts': False,
            'finance': False
        })
        state.audio_settings = data.get('audio_settings', {
            'master_volume': 0.8,
            'music_volume': 0.15,
            'voice_volume': 1.1,
            'narrator_volume': 1.2,
            'world_volume': 0.5,
            'ui_volume': 0.1
        })
        
        # Load delegation focus if present
        delegation_focus_data = data.get('delegation_focus')
        if delegation_focus_data:
            state.delegation_focus = DelegationFocus(
                focus_text=delegation_focus_data['focus_text'],
                active_modifiers=delegation_focus_data['active_modifiers'],
                applied_at=delegation_focus_data['applied_at'],
                narrative_summary=delegation_focus_data.get('narrative_summary', '')
            )
        else:
            state.delegation_focus = None
        
        state.save_mode = data.get('save_mode', 'replayable')
        state.seed = data.get('seed', 42)
        state.game_id = data.get('game_id', '')  # May be empty for old saves
        state.player_identity = data.get('player_identity', [])
        state.player_focus = data.get('player_focus')
        state.player_age = data.get('player_age', 32)
        state.manager_first_name = data.get('manager_first_name', '')
        state.manager_last_name = data.get('manager_last_name', '')
        state.world_state = data.get('world_state', {})
        state.pending_developments = data.get('pending_developments', [])
        state._next_event_id = data.get('_next_event_id', 1)
        
        # Restore event history
        event_history_data = data.get('event_history', [])
        state.event_history = [
            SimEvent(
                event_type=e['event_type'],
                category=e['category'],
                ts=e['ts'],
                priority=e['priority'],
                severity=e.get('severity', 'info'),
                data=e.get('data', {}),
                event_id=e.get('event_id', 0),
                caused_by=e.get('caused_by')
            )
            for e in event_history_data
        ]
        
        # Restore pending decisions
        decision_data = data.get('pending_decisions', [])
        state.pending_decisions = [
            DecisionEvent(
                decision_id=d['decision_id'],
                category=d['category'],
                prompt=d['prompt'],
                options=[
                    DecisionOption(
                        id=opt['id'],
                        label=opt['label'],
                        cost=opt.get('cost', 0.0),
                        description=opt.get('description', ''),
                        consequence_preview=opt.get('consequence_preview', '')
                    )
                    for opt in d.get('options', [])
                ],
                deadline_tick=d['deadline_tick'],
                auto_resolve_option_id=d['auto_resolve_option_id'],
                created_tick=d['created_tick'],
                resolved=d.get('resolved', False),
                chosen_option_id=d.get('chosen_option_id')
            )
            for d in decision_data
        ]
        
        # Restore RNG for deterministic replay
        rng_state = data.get('rng_state')
        if state.save_mode == "replayable" and rng_state:
            random.setstate(rng_state)
        elif state.save_mode == "replayable":
            # Fallback if no RNG state saved
            state.rngs['master'] = random.Random(state.seed)
        else:
            state.rngs['master'] = random.Random()
        
        # Deserialize teams
        def deserialize_team(team_data: Dict[str, Any]) -> Team:
            team = Team(name=team_data['name'])
            
            # Budget
            budget_data = team_data.get('budget', {})
            team.budget.cash = budget_data.get('cash', 100000.0)
            team.budget.burn_rate = budget_data.get('burn_rate', 0.0)
            team.budget.committed_spend = budget_data.get('committed_spend', [])
            team.budget.income_streams = [
                IncomeSource(name=name, amount=amt, frequency=freq) 
                for name, amt, freq in budget_data.get('income_streams', [])
            ]
            team.budget.staff_salaries = budget_data.get('staff_salaries', {})
            
            # Entities
            team.drivers = [state._deserialize_entity(d, Driver) for d in team_data.get('drivers', [])]
            team.engineers = [state._deserialize_entity(e, Engineer) for e in team_data.get('engineers', [])]
            team.mechanics = [state._deserialize_entity(m, Mechanic) for m in team_data.get('mechanics', [])]
            
            strategist_data = team_data.get('strategist')
            team.strategist = state._deserialize_entity(strategist_data, Strategist) if strategist_data else None
            
            principal_data = team_data.get('principal')
            team.principal = state._deserialize_entity(principal_data, AIPrincipal) if principal_data else None
            
            car_data = team_data.get('car')
            team.car = state._deserialize_entity(car_data, Car) if car_data else Car(name=f"{team.name} Car")
            
            # Backward compatibility: Initialize base_ratings if missing (old saves)
            if team.car and (not hasattr(team.car, 'base_ratings') or not team.car.base_ratings):
                # For old saves, use current_ratings as base (best approximation)
                # This prevents jumping to schema defaults (50s) when equipping parts
                team.car.base_ratings = team.car.current_ratings.copy()
                _dbg(f"[FTB LOAD] Migrated car base_ratings for {team.name}")
            
            team.infrastructure = team_data.get('infrastructure', {})
            team.standing_metrics = team_data.get('standing_metrics', {})
            
            # Load tier attributes with backward compatibility (Phase 0 fix)
            team.tier = team_data.get('tier', 0)
            team.league_id = team_data.get('league_id', '')
            team.tier_name = team_data.get('tier_name', '')
            
            # Store part IDs for restoration after parts_catalog is loaded
            team._parts_inventory_ids = team_data.get('parts_inventory', [])
            team._equipped_parts_ids = team_data.get('equipped_parts', {})
            team.manufacturer_contracts = team_data.get('manufacturer_contracts', [])
            
            # Restore active R&D projects (Phase 4.10)
            rd_projects_data = team_data.get('active_rd_projects', [])
            team.active_rd_projects = [
                RDProject(
                    project_id=p['project_id'],
                    project_name=p['project_name'],
                    description=p.get('description', ''),
                    project_type=p.get('project_type', 'car_upgrade'),
                    team_name=p.get('team_name', team.name),
                    total_cost=p.get('total_cost', p.get('base_cost', 10000.0)),  # backward compat
                    started_tick=p.get('started_tick', p.get('start_tick', 0)),  # backward compat
                    duration_ticks=p['duration_ticks'],
                    progress_ticks=p.get('progress_ticks', p.get('current_progress', 0)),  # backward compat
                    completed=p.get('completed', False),
                    cancelled=p.get('cancelled', False),
                    base_success_rate=p.get('base_success_rate', 0.7),
                    current_success_rate=p.get('current_success_rate', p.get('success_chance', 0.7)),  # backward compat
                    target_stat=p.get('target_stat', ''),
                    target_improvement=p.get('target_improvement', p.get('improvement_amount', 0.0)),  # backward compat
                    generates_part=p.get('generates_part', False),
                    part_type=p.get('part_type', ''),
                    risk_level=p.get('risk_level', 'medium'),
                    assigned_engineer_ids=p.get('assigned_engineer_ids', [])
                )
                for p in rd_projects_data
            ]
            
            # Restore installed upgrades (Phase 5.10)
            team.installed_upgrades = team_data.get('installed_upgrades', [])
            
            return team
        
        player_team_data = data.get('player_team')
        state.player_team = deserialize_team(player_team_data) if player_team_data else None
        
        # V2 → V3 MIGRATION: Create player principal if missing
        if version == 2 and state.player_team and not state.player_team.principal:
            _dbg("[FTB] Migrating: Creating player manager principal from identity...")
            
            # Create principal from player_identity or use neutral stats
            player_manager_stats = translate_player_identity_to_stats(state.player_identity)
            
            player_principal_id = state._next_entity_id
            state._next_entity_id += 1
            
            manager_display_name = f"{state.manager_first_name} {state.manager_last_name}".strip() or "Your Manager"
            player_principal = AIPrincipal(name=manager_display_name)
            player_principal.entity_id = player_principal_id
            player_principal.display_name = manager_display_name
            player_principal.age = state.player_age
            player_principal.current_ratings = player_manager_stats
            
            state.player_team.principal = player_principal
            _dbg(f"[FTB]   - Created: {manager_display_name} (avg rating: {player_principal.overall_rating:.1f})")
        
        state.ai_teams = [deserialize_team(t) for t in data.get('ai_teams', [])]
        
        # SAFETY CHECK: Ensure player team is never in ai_teams after load
        # This prevents AI from controlling the player team on regular ticks
        if state.player_team:
            before_count = len(state.ai_teams)
            state.ai_teams = [t for t in state.ai_teams if t.name != state.player_team.name]
            after_count = len(state.ai_teams)
            _dbg(f"[FTB LOAD] Player team: '{state.player_team.name}', AI teams: {after_count} (filtered: {before_count - after_count})")
            # Verify player team is not in ai_teams
            player_in_ai = any(t.name == state.player_team.name for t in state.ai_teams)
            if player_in_ai:
                _dbg(f"[FTB LOAD] ❌ ERROR: Player team '{state.player_team.name}' is STILL in ai_teams after filtering!")
            else:
                _dbg(f"[FTB LOAD] ✓ Verified: Player team NOT in ai_teams")
        
        # MIGRATION: Convert old pending_developments to active_rd_projects (after teams loaded!)
        if state.pending_developments and state.player_team:
            for old_dev in state.pending_developments:
                if old_dev.get('team_name') == state.player_team.name:
                    # Convert old development to RDProject
                    subsystem = old_dev.get('subsystem', 'general')
                    subsystem_map = {
                        'Aerodynamics': 'rd_aero_efficiency',
                        'Power Unit': 'rd_power_output',
                        'Suspension': 'rd_mechanical_grip',
                        'Reliability': 'rd_reliability',
                        'Driveability': 'rd_driveability',
                        'Strategy Tools': 'rd_setup_window'
                    }
                    project_id = subsystem_map.get(subsystem, 'rd_driveability')
                    
                    if project_id in RD_PROJECT_CATALOG:
                        template = RD_PROJECT_CATALOG[project_id]
                        duration = old_dev.get('resolve_tick', state.tick + 14) - old_dev.get('initiated_tick', state.tick)
                        progress = state.tick - old_dev.get('initiated_tick', state.tick)
                        
                        migrated_project = RDProject(
                            project_id=project_id,
                            project_name=template['name'],
                            project_type=template['type'],
                            team_name=state.player_team.name,
                            total_cost=old_dev.get('cost', template['cost']),
                            duration_ticks=duration,
                            started_tick=old_dev.get('initiated_tick', state.tick),
                            progress_ticks=progress,
                            base_success_rate=template['base_success_rate'],
                            current_success_rate=template['base_success_rate'],
                            target_stat=template.get('target_stat', ''),
                            target_improvement=template.get('target_improvement', 0.0),
                            generates_part=template.get('generates_part', False),
                            part_type=template.get('part_type', ''),
                            description=template['description'],
                            risk_level=old_dev.get('risk_level', template.get('risk_level', 'medium'))
                        )
                        state.player_team.active_rd_projects.append(migrated_project)
            
            # Clear old pending_developments for player team
            state.pending_developments = [d for d in state.pending_developments if d.get('team_name') != state.player_team.name]
        
        # Deserialize leagues and restore team references
        leagues_data = data.get('leagues', {})
        all_teams = ([state.player_team] if state.player_team else []) + state.ai_teams
        
        # MIGRATION: Ensure all teams have infrastructure unlock flags and active_rd_projects
        for team in all_teams:
            if 'factory_unlocked' not in team.infrastructure:
                team.infrastructure['factory_unlocked'] = True  # Existing saves: factory already unlocked
            if 'wind_tunnel_unlocked' not in team.infrastructure:
                team.infrastructure['wind_tunnel_unlocked'] = team.infrastructure.get('wind_tunnel', 50.0) > 50.0
            if 'simulator_unlocked' not in team.infrastructure:
                team.infrastructure['simulator_unlocked'] = team.infrastructure.get('simulator', 50.0) > 50.0
            
            # Ensure active_rd_projects list exists
            if not hasattr(team, 'active_rd_projects'):
                team.active_rd_projects = []
            
            # MIGRATION: Initialize morale baseline system for existing entities
            for entity in (team.drivers + team.engineers + team.mechanics + 
                          ([team.strategist] if team.strategist else []) +
                          ([team.principal] if team.principal else [])):
                if not hasattr(entity, 'morale_baseline') or entity.morale_baseline is None:
                    entity.morale_baseline = entity._calculate_morale_baseline()
                if not hasattr(entity, 'morale_last_updated') or entity.morale_last_updated is None:
                    entity.morale_last_updated = state.tick
        
        for name, lg_data in leagues_data.items():
            league = League(
                name=lg_data['name'],
                tier=lg_data['tier'],
                tier_name=lg_data.get('tier_name', 'grassroots')
            )
            league.schedule = lg_data.get('schedule', [])
            league.championship_table = lg_data.get('championship_table', {})
            league.driver_championship = lg_data.get('driver_championship', {})
            league.races_this_season = lg_data.get('races_this_season', 0)
            # Backward compatibility for new hype system
            league.hype = lg_data.get('hype', 1.0)
            league.hype_events_this_season = lg_data.get('hype_events_this_season', 0)
            
            # Restore team references by matching names
            team_names = lg_data.get('team_names', [])
            for team_name in team_names:
                team_obj = next((t for t in all_teams if t.name == team_name), None)
                if team_obj and team_obj not in league.teams:
                    league.teams.append(team_obj)
                    # Backward compatibility: infer tier attributes if missing (Phase 0 fix)
                    if team_obj.tier == 0:
                        team_obj.tier = league.tier
                        team_obj.league_id = name
                        team_obj.tier_name = league.tier_name
            
            state.leagues[name] = league
        
        # Deserialize manufacturers and parts
        manufacturers_data = data.get('manufacturers', {})
        for mfr_id, mfr_data in manufacturers_data.items():
            state.manufacturers[mfr_id] = state._deserialize_manufacturer(mfr_data)
        
        parts_data = data.get('parts_catalog', {})
        for part_id, part_data in parts_data.items():
            state.parts_catalog[part_id] = state._deserialize_part(part_data)
        
        state.parts_generation_counter = data.get('parts_generation_counter', {})
        state.current_meta = data.get('current_meta', {})
        
        # Restore part references in teams (now that parts_catalog is loaded)
        for team in all_teams:
            if hasattr(team, '_parts_inventory_ids'):
                team.parts_inventory = [state.parts_catalog[pid] for pid in team._parts_inventory_ids if pid in state.parts_catalog]
                delattr(team, '_parts_inventory_ids')
            if hasattr(team, '_equipped_parts_ids'):
                team.equipped_parts = {slot: state.parts_catalog[pid] for slot, pid in team._equipped_parts_ids.items() if pid in state.parts_catalog}
                delattr(team, '_equipped_parts_ids')
        
        # Deserialize contracts
        contracts_data = data.get('contracts', {})
        for entity_id_str, contract_data in contracts_data.items():
            entity_id = int(entity_id_str)
            contract = Contract(
                entity_id=contract_data['entity_id'],
                entity_name=contract_data['entity_name'],
                team_name=contract_data['team_name'],
                role=contract_data['role'],
                start_day=contract_data['start_day'],
                duration_days=contract_data['duration_days'],
                base_salary=contract_data['base_salary'],
                performance_clauses=contract_data.get('performance_clauses', {}),
                exit_clauses=contract_data.get('exit_clauses', {}),
                seasons_duration=contract_data.get('seasons_duration', 2),
                signing_bonus=contract_data.get('signing_bonus', 0),
                negotiation_round=contract_data.get('negotiation_round', 0),
                last_offer_rejected=contract_data.get('last_offer_rejected', False)
            )
            state.contracts[entity_id] = contract
        
        # Deserialize sponsorships (with migration support for old saves)
        sponsorships_data = data.get('sponsorships', {})
        for team_name, sponsors_list in sponsorships_data.items():
            state.sponsorships[team_name] = []
            for s in sponsors_list:
                # Detect old format and migrate
                if 'amount_per_tick' in s:
                    # Old format - convert to new
                    sponsorship = Sponsorship(
                        sponsor_name=s.get('sponsor_name', 'Unknown Sponsor'),
                        tier='associate',
                        base_payment_per_season=s.get('amount_per_tick', 0) * 365,
                        duration_seasons=max(1, s.get('duration_ticks', 365) // 365),
                        confidence=s.get('confidence', 100.0),
                        signed_tick=s.get('start_tick', 0),
                    )
                else:
                    # New format
                    sponsorship = Sponsorship(
                        sponsor_name=s['sponsor_name'],
                        tier=s.get('tier', 'associate'),
                        base_payment_per_season=s.get('base_payment_per_season', 0),
                        performance_multipliers=s.get('performance_multipliers', {}),
                        duration_seasons=s.get('duration_seasons', 1),
                        reputation_threshold=s.get('reputation_threshold', 0),
                        seasons_active=s.get('seasons_active', 0),
                        warning_issued=s.get('warning_issued', False),
                        # Extended fields (None/defaults if missing for backward compatibility)
                        sponsor_id=s.get('sponsor_id'),
                        industry=s.get('industry'),
                        sub_industry=s.get('sub_industry'),
                        financial_tier=s.get('financial_tier'),
                        brand_profile_json=s.get('brand_profile_json'),
                        contract_behavior_json=s.get('contract_behavior_json'),
                        activation_style_json=s.get('activation_style_json'),
                        narrative_hooks_json=s.get('narrative_hooks_json'),
                        confidence=s.get('confidence', 100.0),
                        performance_history=s.get('performance_history', []),
                        contract_type=s.get('contract_type', 'season_partnership'),
                        evaluation_cadence=s.get('evaluation_cadence', 5),
                        signed_tick=s.get('signed_tick', 0),
                        last_evaluated_tick=s.get('last_evaluated_tick', 0),
                        exclusivity_clauses=s.get('exclusivity_clauses', []),
                        total_paid_this_season=s.get('total_paid_this_season', 0),
                        last_payment_tick=s.get('last_payment_tick', 0)
                    )
                state.sponsorships[team_name].append(sponsorship)
        
        # Deserialize pending sponsor offers
        pending_offers_data = data.get('pending_sponsor_offers', {})
        for team_name, offers_list in pending_offers_data.items():
            state.pending_sponsor_offers[team_name] = []
            for s in offers_list:
                offer = Sponsorship(
                    sponsor_name=s.get('sponsor_name', 'Unknown Sponsor'),
                    tier=s.get('tier', 'associate'),
                    base_payment_per_season=s.get('base_payment_per_season', 0),
                    performance_multipliers=s.get('performance_multipliers', {}),
                    duration_seasons=s.get('duration_seasons', 1),
                    sponsor_id=s.get('sponsor_id'),
                    industry=s.get('industry'),
                    sub_industry=s.get('sub_industry'),
                    financial_tier=s.get('financial_tier'),
                    brand_profile_json=s.get('brand_profile_json'),
                    contract_behavior_json=s.get('contract_behavior_json'),
                    activation_style_json=s.get('activation_style_json'),
                    narrative_hooks_json=s.get('narrative_hooks_json'),
                    contract_type=s.get('contract_type', 'season_partnership'),
                    evaluation_cadence=s.get('evaluation_cadence', 5),
                    exclusivity_clauses=s.get('exclusivity_clauses', [])
                )
                state.pending_sponsor_offers[team_name].append(offer)

        # CRITICAL FIX: Restore free agents and job board
        # These were initialized but never loaded from save data, causing empty markets on loads
        free_agents_data = data.get('free_agents', [])
        state.free_agents = [state._deserialize_free_agent(fa) for fa in free_agents_data]
        _dbg(f"[FTB LOAD] ✅ Loaded {len(state.free_agents)} free agents from save")
        
        job_board_data = data.get('job_board', {})
        vacancies_data = job_board_data.get('vacancies', [])
        state.job_board = JobBoard()
        state.job_board.vacancies = [state._deserialize_job_listing(v) for v in vacancies_data]
        _dbg(f"[FTB LOAD] ✅ Loaded {len(state.job_board.vacancies)} job listings from save")

        # CRITICAL FIX: Restore race results for quali/race result display
        # These were never saved/loaded, causing results to not display on loaded saves
        race_results_data = data.get('_last_race_results', {})
        state._last_race_results = {
            league_id: state._deserialize_race_result(result_data)
            for league_id, result_data in race_results_data.items()
        }
        _dbg(f"[FTB LOAD] ✅ Loaded {len(state._last_race_results)} race results from save")
        
        state._last_race_contexts = data.get('_last_race_contexts', {})
        _dbg(f"[FTB LOAD] ✅ Loaded {len(state._last_race_contexts)} race contexts from save")

        # Ensure tracks exist for loaded saves and schedules reference valid tracks
        if not state.tracks:
            WorldBuilder._generate_tracks(state)
        for league in state.leagues.values():
            WorldBuilder._ensure_schedule_tracks(state, league)
        
        return state


# ============================================================
# SECTION: AI Delegate System - Identity-to-Stats Mapping
# ============================================================

def translate_player_identity_to_stats(
    player_identity: Union[str, List[str]],
    model_provider=None
) -> Dict[str, float]:
    """
    Translate player setup text into team principal stats using deterministic seed-based generation.

    This function processes player setup input (freeform wizard responses) into
    starting stat tendencies for the player's team principal. The same input text
    will always produce identical stats (deterministic).

    Design Philosophy:
    ------------------
    The values returned do not determine skill, intelligence, or performance.
    They do not control luck, success, or difficulty directly.

    Instead, these parameters tune operational priorities. In automanaged mode,
    they adjust how the AI scores various actions (hiring, firing, R&D, etc.).
    These weightings introduce stylistic variety without guaranteeing outcome.

    Every successful coach (cautious, aggressive, data-driven, or gut-feel based)
    has pathways to success. These parameters merely reflect starting playstyle.

    Stat Generation Method:
    -----------------------
    Uses a hash-based seed derived from the input text to generate deterministic
    random values for all 28 AIPrincipal stats. Each stat is independently generated
    in the range 1-99. No keyword matching, no LLM calls, purely deterministic.
    
    Args:
        player_identity: Free-form setup text or wizard responses
        model_provider: Unused (kept for API compatibility)

    Returns:
        Dict matching STATS_SCHEMAS['AIPrincipal'] with values in range 1-99
        (stats will vary across the full range based on seed)
    """
    from your_runtime import log
    import hashlib
    import random

    # Normalize input text
    if isinstance(player_identity, list):
        identity_text = " ".join(str(x) for x in player_identity if x)
    else:
        identity_text = str(player_identity)

    identity_text = identity_text.strip()

    # Fallback to neutral baseline if no input provided
    if not identity_text:
        log("ftb", "[Delegate] No setup input provided, using neutral baseline")
        return STATS_SCHEMAS['AIPrincipal'].copy()

    # Generate seed from normalized text
    normalized = identity_text.lower()
    seed = int(hashlib.md5(normalized.encode()).hexdigest(), 16)
    rng = random.Random(seed)

    # Generate all stats deterministically from seed
    base_stats = {}
    schema = STATS_SCHEMAS['AIPrincipal']
    
    for stat_name in schema:
        if stat_name == 'mettle':  # Keep mettle at default
            base_stats[stat_name] = 55.0
        else:
            # Generate deterministic value in range 1-99 for each stat
            value = rng.uniform(1.0, 99.0)
            base_stats[stat_name] = round(value, 1)

    avg_stat = sum(v for k, v in base_stats.items() if k != 'mettle') / (len(base_stats) - 1)
    log(
        "ftb",
        f"[Delegate] Player identity mapped deterministically (avg: {avg_stat:.1f}, range: {min(base_stats.values()):.0f}-{max(base_stats.values()):.0f})"
    )
    log(
        "ftb",
        f"[Delegate] Sample stats: aggression={base_stats.get('aggression', 50):.0f}, "
        f"risk_tolerance={base_stats.get('risk_tolerance', 50):.0f}, patience={base_stats.get('patience', 50):.0f}"
    )
    
    return base_stats


def translate_focus_to_modifiers(focus_text: str, base_stats: Dict[str, float], model_provider=None) -> Dict[str, float]:
    """
    Translate high-level focus intent into temporary stat modifiers.
    
    NOTE: This function is now stubbed (returns empty dict) to remove LLM dependency.
    Focus modifiers are disabled. If needed in the future, implement a deterministic
    keyword-based mapping system.
    
    Args:
        focus_text: Player's focus intent (unused)
        base_stats: Current manager stats (unused)
        model_provider: Model provider (unused)
    
    Returns:
        Empty dict (no modifiers applied)
    """
    from your_runtime import log
    
    if focus_text and focus_text.strip():
        log("ftb", f"[Delegate] Focus modifiers disabled (focus text: '{focus_text}')")
    
    return {}


def apply_focus_modifiers(principal: AIPrincipal, modifiers: Dict[str, float]) -> AIPrincipal:
    """
    Apply focus modifiers to a principal's stats, returning a modified copy.
    
    Args:
        principal: Base AIPrincipal entity
        modifiers: Dict of stat_name -> adjustment value
    
    Returns:
        New AIPrincipal with adjusted stats (clamped to 1-99 range)
    """
    if not modifiers:
        return principal
    
    # Create a copy with modified stats
    from copy import deepcopy
    modified = deepcopy(principal)
    
    for stat_name, adjustment in modifiers.items():
        if stat_name in modified.current_ratings:
            new_value = modified.current_ratings[stat_name] + adjustment
            modified.current_ratings[stat_name] = max(1.0, min(99.0, new_value))
    
    return modified


class WorldBuilder:
    """Deterministic world generation pipeline"""
    
    TIER_CONFIG = {
        'grassroots': {
            'count': 10, 'tier': 1, 'teams': 16, 'budget_range': (40000.0, 130000.0),
            'points_table': [34, 30, 27, 25, 23, 21, 19, 17, 16, 15, 14, 13, 12, 11, 10, 9, 8, 7, 6, 5],  # CIK-FIA karting (top 20)
            'fastest_lap_bonus': False  # Karting doesn't award fastest lap bonus
        },
        'formula_v': {
            'count': 6, 'tier': 2, 'teams': 16, 'budget_range': (400000.0, 800000.0),
            'points_table': [25, 18, 15, 12, 10, 8, 6, 4, 2, 1],  # Modern F1/F4 scoring (top 10)
            'fastest_lap_bonus': True  # F4 awards fastest lap bonus to top 10 finishers
        },
        'formula_x': {
            'count': 4, 'tier': 3, 'teams': 10, 'budget_range': (2000000.0, 5000000.0),
            'points_table': [25, 18, 15, 12, 10, 8, 6, 4, 2, 1],  # F3 scoring
            'fastest_lap_bonus': True
        },
        'formula_y': {
            'count': 2, 'tier': 4, 'teams': 11, 'budget_range': (10000000.0, 25000000.0),
            'points_table': [25, 18, 15, 12, 10, 8, 6, 4, 2, 1],  # F2 scoring
            'fastest_lap_bonus': True
        },
        'formula_z': {
            'count': 1, 'tier': 5, 'teams': 10, 'budget_range': (80000000.0, 250000000.0),
            'points_table': [25, 18, 15, 12, 10, 8, 6, 4, 2, 1],  # F1 scoring
            'fastest_lap_bonus': True
        },
    }
    
    # Tier-specific envelopes for realistic stat/age distributions
    TIER_ENVELOPES = {
        'grassroots': {
            'driver_age_range': (15, 20),  # Young grassroots drivers (15-18 average)
            'principal_age_range': (28, 50),
            'staff_age_range': (20, 45),
            'stat_mean': 32,
            'stat_stddev': 8,
            'mechanics_count': 1,
            'engineers_count': 0,  # Start with no engineers
            'base_salary_multiplier': 0.4,
        },
        'formula_v': {
            'driver_age_range': (17, 25),  # Scaled down from (20, 28)
            'principal_age_range': (30, 55),
            'staff_age_range': (22, 50),
            'stat_mean': 44,
            'stat_stddev': 9,
            'mechanics_count': 2,
            'engineers_count': 1,
            'base_salary_multiplier': 1.5,
        },
        'formula_x': {
            'driver_age_range': (19, 30),  # Scaled down from (22, 32)
            'principal_age_range': (33, 60),
            'staff_age_range': (24, 52),
            'stat_mean': 56,
            'stat_stddev': 9,
            'mechanics_count': 3,
            'engineers_count': 2,
            'base_salary_multiplier': 4.0,
        },
        'formula_y': {
            'driver_age_range': (21, 34),  # Scaled down from (24, 36)
            'principal_age_range': (36, 65),
            'staff_age_range': (26, 58),
            'stat_mean': 68,
            'stat_stddev': 8,
            'mechanics_count': 4,
            'engineers_count': 3,
            'base_salary_multiplier': 12.0,
        },
        'formula_z': {
            'driver_age_range': (18, 38),  # Minimum age 18 for Formula Z
            'principal_age_range': (35, 68),
            'staff_age_range': (25, 62),
            'stat_mean': 80,
            'stat_stddev': 7,
            'mechanics_count': 6,
            'engineers_count': 5,
            'base_salary_multiplier': 60.0,
        },
    }
    
    @staticmethod
    def generate_world(state: SimState) -> None:
        """Populate empty state with full world"""
        rng = state.get_rng("world", "init")
        state.ai_teams = [] # Clear existing
        state.leagues = {}
        state.tracks = {}
        
        # 1. Generate Tracks (canonical set for all tiers)
        WorldBuilder._generate_tracks(state)
        
        # 1.5 Generate Manufacturers & Parts Catalog (Phase 1)
        WorldBuilder._generate_manufacturers_and_parts(state)
        
        # 2. Create Leagues
        for tier_name, config in WorldBuilder.TIER_CONFIG.items():
            for i in range(config['count']):
                league_id = f"{tier_name}_{i+1}"
                
                # Generate unique league name using procedural system
                if generate_league_name:
                    league_name = generate_league_name(state.seed, config['tier'], i)
                    # Append tier descriptor for clarity
                    tier_display = tier_name.replace('_', ' ').title()
                    league_display_name = f"{league_name} ({tier_display})"
                else:
                    # Fallback if name generation unavailable
                    league_name = f"{tier_name.replace('_', ' ').title()} League {i+1}"
                    league_display_name = league_name
                    if config['count'] == 1:
                        league_name = tier_name.replace('_', ' ').title()
                        league_display_name = league_name
                
                league = League(league_display_name, config['tier'], tier_name, league_id, i)
                state.leagues[league_id] = league
                
                # 3. Generate Schedule with tracks (tighter schedules = more races per season)
                if tier_name == 'formula_z':
                    weeks = 24  # Top tier keeps 24 races (weekly = ~6 months)
                elif tier_name == 'formula_y':
                    weeks = 18  # Tier 4: 18 races × 7 days = ~4.5 months
                elif tier_name == 'formula_x':
                    weeks = 16  # Tier 3: 16 races × 10 days = ~5.5 months
                elif tier_name == 'formula_v':
                    weeks = 14  # Tier 2: 14 races × 10 days = ~4.5 months
                else:
                    weeks = 12  # Tier 1: 12 races × 14 days = ~5.5 months
                start_week = 2  # First race starts on day 2 (delayed by one day from original day 1)
                WorldBuilder._assign_tracks_to_schedule(state, league, weeks, start_week)
                
                # 4. Generate Teams
                WorldBuilder._generate_teams(state, league, config, rng)
        
        # 5. Generate Free Agent Pool (grassroots-level entities)
        WorldBuilder._generate_free_agents(state)
                
    @staticmethod
    def _generate_teams(state: SimState, league: League, config: Dict[str, Any], rng: random.Random) -> None:
        num_teams = config['teams']
        
        # Get tier envelope for realistic distributions
        envelope = WorldBuilder.TIER_ENVELOPES.get(league.tier_name, {
            'driver_age_range': (18, 35),
            'principal_age_range': (30, 60),
            'staff_age_range': (22, 50),
            'stat_mean': 20 + league.tier * 12,
            'stat_stddev': 10,
            'mechanics_count': 1,
            'engineers_count': 0,
            'base_salary_multiplier': 1.0,
        })
        
        stat_mean = envelope['stat_mean']
        stat_stddev = envelope['stat_stddev']
        salary_mult = envelope['base_salary_multiplier']
        
        for i in range(num_teams):
            # Generate team name using name system with uniqueness validation
            team_name = None
            if generate_team_name:
                # Try up to 100 times to generate a unique team name
                for attempt in range(100):
                    candidate_name = generate_team_name(state.seed + attempt, league.tier, league.league_index, i)
                    if state.validate_team_name(candidate_name):
                        team_name = candidate_name
                        break
                
                # Fallback if all attempts failed
                if team_name is None:
                    team_name = f"{league.name.split(' ')[0]} Team {i+1}"
                    _dbg(f"[FTB] Warning: Could not generate unique name for team {i} in {league.name}, using fallback: {team_name}")
            else:
                team_name = f"{league.name.split(' ')[0]} Team {i+1}"
            
            # Register the team name as taken
            state.register_team_name(team_name)
            
            team = Team(team_name)
            team.budget.cash = rng.uniform(*config['budget_range'])
            
            # Principal
            principal_id = state._next_entity_id
            state._next_entity_id += 1
            if generate_name:
                principal_name = generate_name(state.seed, "AIPrincipal", principal_id)
            else:
                principal_name = f"Principal {i}"
            
            p = AIPrincipal(principal_name)
            p.entity_id = principal_id
            p.display_name = principal_name
            p.age = rng.randint(*envelope['principal_age_range'])
            for k in STATS_SCHEMAS['AIPrincipal']:
                p.current_ratings[k] = float(max(1, min(99, rng.gauss(stat_mean + 5, stat_stddev))))
            team.principal = p
            
            # Create contract for principal
            contract_start = state.sim_day_of_year - rng.randint(0, 365)  # Random start in past year
            contract_duration = int(rng.uniform(104, 156) * 7)  # 2-3 years in days
            base_salary = int(50000 * salary_mult * (p.overall_rating / 50.0))
            
            state.contracts[principal_id] = Contract(
                entity_id=principal_id,
                entity_name=principal_name,
                team_name=team_name,
                role="principal",
                start_day=contract_start,
                duration_days=contract_duration,
                base_salary=base_salary
            )
            
            # Drivers
            for d_idx in range(2):
                driver_id = state._next_entity_id
                state._next_entity_id += 1
                if generate_name:
                    driver_name = generate_name(state.seed, "Driver", driver_id)
                else:
                    driver_name = f"Driver {league.tier}-{i}-{d_idx}"
                
                d = Driver(driver_name)
                d.entity_id = driver_id
                d.display_name = driver_name
                d.age = rng.randint(*envelope['driver_age_range'])
                for k in STATS_SCHEMAS['Driver']:
                    d.current_ratings[k] = float(max(1, min(99, rng.gauss(stat_mean, stat_stddev))))
                team.drivers.append(d)
                
                # Create contract for driver
                contract_start = state.sim_day_of_year - rng.randint(0, 365)
                contract_duration = int(rng.uniform(52, 104) * 7)  # 1-2 years
                base_salary = int(100000 * salary_mult * (d.overall_rating / 50.0))
                
                state.contracts[driver_id] = Contract(
                    entity_id=driver_id,
                    entity_name=driver_name,
                    team_name=team_name,
                    role="driver",
                    start_day=contract_start,
                    duration_days=contract_duration,
                    base_salary=base_salary
                )
                
            # Mechanics
            num_mechanics = envelope['mechanics_count']
            for m_idx in range(num_mechanics):
                mechanic_id = state._next_entity_id
                state._next_entity_id += 1
                if generate_name:
                    mechanic_name = generate_name(state.seed, "Mechanic", mechanic_id)
                else:
                    mechanic_name = f"Mechanic {i}-{m_idx}"
                
                m = Mechanic(mechanic_name)
                m.entity_id = mechanic_id
                m.display_name = mechanic_name
                m.age = rng.randint(*envelope['staff_age_range'])
                for k in STATS_SCHEMAS['Mechanic']:
                    m.current_ratings[k] = float(max(1, min(99, rng.gauss(stat_mean, stat_stddev))))
                team.mechanics.append(m)
                
                # Create contract for mechanic
                contract_start = state.sim_day_of_year - rng.randint(0, 365)
                contract_duration = int(rng.uniform(104, 208) * 7)  # 2-4 years
                base_salary = int(40000 * salary_mult * (m.overall_rating / 50.0))
                
                state.contracts[mechanic_id] = Contract(
                    entity_id=mechanic_id,
                    entity_name=mechanic_name,
                    team_name=team_name,
                    role="mechanic",
                    start_day=contract_start,
                    duration_days=contract_duration,
                    base_salary=base_salary
                )

            # Engineers (if tier supports them)
            num_engineers = envelope['engineers_count']
            for e_idx in range(num_engineers):
                engineer_id = state._next_entity_id
                state._next_entity_id += 1
                if generate_name:
                    engineer_name = generate_name(state.seed, "Engineer", engineer_id)
                else:
                    engineer_name = f"Engineer {i}-{e_idx}"
                
                eng = Engineer(engineer_name)
                eng.entity_id = engineer_id
                eng.display_name = engineer_name
                eng.age = rng.randint(*envelope['staff_age_range'])
                for k in STATS_SCHEMAS['Engineer']:
                    eng.current_ratings[k] = float(max(1, min(99, rng.gauss(stat_mean, stat_stddev))))
                team.engineers.append(eng)
                
                # Create contract for engineer
                contract_start = state.sim_day_of_year - rng.randint(0, 365)
                contract_duration = int(rng.uniform(104, 156) * 7)  # 2-3 years
                base_salary = int(60000 * salary_mult * (eng.overall_rating / 50.0))
                
                state.contracts[engineer_id] = Contract(
                    entity_id=engineer_id,
                    entity_name=engineer_name,
                    team_name=team_name,
                    role="engineer",
                    start_day=contract_start,
                    duration_days=contract_duration,
                    base_salary=base_salary
                )

            # Strategist
            strategist_id = state._next_entity_id
            state._next_entity_id += 1
            if generate_name:
                strategist_name = generate_name(state.seed, "Strategist", strategist_id)
            else:
                strategist_name = f"Strategist {i}"
            
            s = Strategist(strategist_name)
            s.entity_id = strategist_id
            s.display_name = strategist_name
            s.age = rng.randint(*envelope['staff_age_range'])
            for k in STATS_SCHEMAS['Strategist']:
                s.current_ratings[k] = float(max(1, min(99, rng.gauss(stat_mean, stat_stddev))))
            team.strategist = s
            
            # Create contract for strategist
            contract_start = state.sim_day_of_year - rng.randint(0, 365)
            contract_duration = int(rng.uniform(104, 156) * 7)  # 2-3 years
            base_salary = int(55000 * salary_mult * (s.overall_rating / 50.0))
            
            state.contracts[strategist_id] = Contract(
                entity_id=strategist_id,
                entity_name=strategist_name,
                team_name=team_name,
                role="strategist",
                start_day=contract_start,
                duration_days=contract_duration,
                base_salary=base_salary
            )

            # Car
            c = Car(f"{team_name} Chassis")
            for k in STATS_SCHEMAS['Car']:
                c.current_ratings[k] = float(max(1, min(99, rng.gauss(stat_mean, stat_stddev - 2))))
            
            # Store base ratings (without parts) for accurate part calculations
            c.base_ratings = c.current_ratings.copy()
            
            team.car = c
            
            # Set tier attributes (Phase 0 fix)
            team.tier = league.tier
            team.league_id = league.league_id
            team.tier_name = league.tier_name
            
            # Equip initial parts based on tier (Phase 6.0)
            parts_to_equip = {}
            for part_type in ['engine', 'tires']:  # All tiers get these
                eligible_parts = [
                    p for p in state.parts_catalog.values()
                    if p.part_type == part_type
                    and league.tier >= p.tier_minimum
                    and league.tier <= p.tier_maximum
                    and p.generation == 1  # Start with gen 1 parts
                ]
                if eligible_parts:
                    part = rng.choice(eligible_parts)
                    parts_to_equip[part_type] = part
            
            # Tier 2+ get suspension, brakes
            if league.tier >= 2:
                for part_type in ['suspension', 'brakes']:
                    eligible_parts = [
                        p for p in state.parts_catalog.values()
                        if p.part_type == part_type
                        and league.tier >= p.tier_minimum
                        and p.generation == 1
                    ]
                    if eligible_parts:
                        parts_to_equip[part_type] = rng.choice(eligible_parts)
            
            # Tier 3+ get aero
            if league.tier >= 3:
                eligible_parts = [
                    p for p in state.parts_catalog.values()
                    if p.part_type == 'aero_package'
                    and league.tier >= p.tier_minimum
                    and p.generation == 1
                ]
                if eligible_parts:
                    parts_to_equip['aero_package'] = rng.choice(eligible_parts)
            
            # Tier 4+ get chassis, cooling
            if league.tier >= 4:
                for part_type in ['chassis', 'cooling']:
                    eligible_parts = [
                        p for p in state.parts_catalog.values()
                        if p.part_type == part_type
                        and league.tier >= p.tier_minimum
                        and p.generation == 1
                    ]
                    if eligible_parts:
                        parts_to_equip[part_type] = rng.choice(eligible_parts)
            
            # Tier 5 gets electronics, transmission
            if league.tier >= 5:
                for part_type in ['electronics', 'transmission']:
                    eligible_parts = [
                        p for p in state.parts_catalog.values()
                        if p.part_type == part_type
                        and p.generation == 1
                    ]
                    if eligible_parts:
                        parts_to_equip[part_type] = rng.choice(eligible_parts)
            
            # Equip selected parts
            team.equipped_parts = parts_to_equip
            team.parts_inventory = []  # Start with empty inventory beyond equipped
            
            # Update car ratings with part bonuses
            # Use the car's stored base_ratings (tier-specific stats without parts)
            c.update_ratings(c.base_ratings, team.equipped_parts)
            
            # Add initial upgrades for higher tier teams (Phase 5.7)
            if league.tier >= 3 and rng.random() < 0.30:  # Tier 3: 30% chance for 1 upgrade
                available_upgrades = [
                    uid for uid, template in UPGRADE_PACKAGE_CATALOG.items()
                    if league.tier in template['tier_availability']
                    and template['cost'] <= team.budget.cash * 0.15
                ]
                if available_upgrades:
                    upgrade_id = rng.choice(available_upgrades)
                    team.installed_upgrades.append(upgrade_id)
                    # Apply upgrade stat improvements
                    upgrade_template = UPGRADE_PACKAGE_CATALOG[upgrade_id]
                    for stat_name, improvement in upgrade_template.get('stat_improvements', {}).items():
                        if stat_name in c.current_ratings:
                            c.current_ratings[stat_name] = min(99.0, c.current_ratings[stat_name] + improvement)
            
            elif league.tier >= 4 and rng.random() < 0.50:  # Tier 4: 50% chance for 1-2 upgrades
                num_upgrades = rng.randint(1, 2)
                available_upgrades = [
                    uid for uid, template in UPGRADE_PACKAGE_CATALOG.items()
                    if league.tier in template['tier_availability']
                ]
                for _ in range(num_upgrades):
                    if available_upgrades:
                        upgrade_id = rng.choice(available_upgrades)
                        team.installed_upgrades.append(upgrade_id)
                        available_upgrades.remove(upgrade_id)
                        # Apply upgrade stat improvements
                        upgrade_template = UPGRADE_PACKAGE_CATALOG[upgrade_id]
                        for stat_name, improvement in upgrade_template.get('stat_improvements', {}).items():
                            if stat_name in c.current_ratings:
                                c.current_ratings[stat_name] = min(99.0, c.current_ratings[stat_name] + improvement)
            
            elif league.tier >= 5:  # Tier 5: Always 2-3 upgrades
                num_upgrades = rng.randint(2, 3)
                available_upgrades = [
                    uid for uid, template in UPGRADE_PACKAGE_CATALOG.items()
                    if league.tier in template['tier_availability']
                ]
                for _ in range(num_upgrades):
                    if available_upgrades:
                        upgrade_id = rng.choice(available_upgrades)
                        team.installed_upgrades.append(upgrade_id)
                        available_upgrades.remove(upgrade_id)
                        # Apply upgrade stat improvements
                        upgrade_template = UPGRADE_PACKAGE_CATALOG[upgrade_id]
                        for stat_name, improvement in upgrade_template.get('stat_improvements', {}).items():
                            if stat_name in c.current_ratings:
                                c.current_ratings[stat_name] = min(99.0, c.current_ratings[stat_name] + improvement)
            
            league.teams.append(team)
            state.ai_teams.append(team)
    
    @staticmethod
    def _generate_free_agents(state: SimState) -> None:
        """Generate initial free agent pool with grassroots-level entities"""
        rng = state.get_rng("world", "free_agents")
        
        # Generate 80-120 free agents (drivers, engineers, mechanics) - expanded pool for more dynamic job market
        num_free_agents = rng.randint(80, 120)
        
        # Distribution: 40% drivers, 35% engineers, 25% mechanics
        num_drivers = int(num_free_agents * 0.4)
        num_engineers = int(num_free_agents * 0.35)
        num_mechanics = num_free_agents - num_drivers - num_engineers
        
        free_agents_created = 0
        
        # Generate free agent drivers (grassroots level, low-tier ratings)
        for i in range(num_drivers):
            driver_id = state._next_entity_id
            state._next_entity_id += 1
            
            if generate_name:
                driver_name = generate_name(state.seed, "Driver", driver_id)
            else:
                driver_name = f"Free Agent Driver {i+1}"
            
            driver = Driver(driver_name)
            driver.entity_id = driver_id
            driver.display_name = driver_name
            driver.age = rng.randint(16, 28)  # Younger skew for free agents
            
            # Grassroots-level stats (tier 1 quality: 20-45 range)
            stat_mean = 30.0
            stat_stddev = 8.0
            for k in STATS_SCHEMAS['Driver']:
                driver.current_ratings[k] = float(max(1, min(99, rng.gauss(stat_mean, stat_stddev))))
            
            # Calculate asking salary based on overall rating (convert per-tick to annual)
            per_tick_salary = estimate_salary_expectation(driver, team_tier=1)  # Grassroots tier
            asking_salary = per_tick_salary * 365  # Annual salary
            
            # Add to free agent pool
            state.add_to_free_agent_pool(driver, "world_generation", asking_salary)
            free_agents_created += 1
        
        # Generate free agent engineers
        for i in range(num_engineers):
            engineer_id = state._next_entity_id
            state._next_entity_id += 1
            
            if generate_name:
                engineer_name = generate_name(state.seed, "Engineer", engineer_id)
            else:
                engineer_name = f"Free Agent Engineer {i+1}"
            
            engineer = Engineer(engineer_name)
            engineer.entity_id = engineer_id
            engineer.display_name = engineer_name
            engineer.age = rng.randint(20, 38)  # Younger staff ages
            
            # Grassroots-level stats
            stat_mean = 30.0
            stat_stddev = 8.0
            for k in STATS_SCHEMAS['Engineer']:
                engineer.current_ratings[k] = float(max(1, min(99, rng.gauss(stat_mean, stat_stddev))))
            
            # Calculate asking salary (convert per-tick to annual)
            per_tick_salary = estimate_salary_expectation(engineer, team_tier=1)  # Grassroots tier
            asking_salary = per_tick_salary * 365  # Annual salary
            
            # Add to free agent pool
            state.add_to_free_agent_pool(engineer, "world_generation", asking_salary)
            free_agents_created += 1
        
        # Generate free agent mechanics
        for i in range(num_mechanics):
            mechanic_id = state._next_entity_id
            state._next_entity_id += 1
            
            if generate_name:
                mechanic_name = generate_name(state.seed, "Mechanic", mechanic_id)
            else:
                mechanic_name = f"Free Agent Mechanic {i+1}"
            
            mechanic = Mechanic(mechanic_name)
            mechanic.entity_id = mechanic_id
            mechanic.display_name = mechanic_name
            mechanic.age = rng.randint(18, 42)  # Younger staff ages
            
            # Grassroots-level stats
            stat_mean = 30.0
            stat_stddev = 8.0
            for k in STATS_SCHEMAS['Mechanic']:
                mechanic.current_ratings[k] = float(max(1, min(99, rng.gauss(stat_mean, stat_stddev))))
            
            # Calculate asking salary (convert per-tick to annual)
            per_tick_salary = estimate_salary_expectation(mechanic, team_tier=1)  # Grassroots tier
            asking_salary = per_tick_salary * 365  # Annual salary
            
            # Add to free agent pool
            state.add_to_free_agent_pool(mechanic, "world_generation", asking_salary)
            free_agents_created += 1
        
        _dbg(f"[FTB] WORLD_GEN: Generated {free_agents_created} free agents ({num_drivers} drivers, {num_engineers} engineers, {num_mechanics} mechanics)")
    
    @staticmethod
    def _generate_tracks(state: SimState) -> None:
        """Generate canonical set of tracks for all leagues"""
        from plugins import ftb_names
        
        rng = state.get_rng("world", "tracks")
        
        # Generate 18 tracks total
        # 3 Formula Z exclusive (prestige 8-10)
        # 15 shared across tiers (prestige 2-7)
        
        for track_idx in range(18):
            track_id = f"track_{track_idx+1:02d}"
            
            # Generate name and character
            track_name, track_character = ftb_names.generate_track_name(state.seed, track_idx)
            
            # Determine prestige and tier range
            if track_idx < 3:
                # Top 3 tracks are Formula Z exclusive
                prestige = rng.randint(8, 10)
                min_tier = 5
                max_tier = 5
            else:
                # Remaining tracks shared across tiers with varying prestige
                prestige = rng.randint(2, 7)
                min_tier = 1
                max_tier = 5
            
            # Generate track characteristics
            length_km = round(rng.uniform(2.5, 6.5), 2)
            corner_count = rng.randint(8, 22)
            
            # Lap count inversely proportional to length
            if length_km < 3.5:
                lap_count = rng.randint(60, 80)
            elif length_km < 5.0:
                lap_count = rng.randint(45, 65)
            else:
                lap_count = rng.randint(35, 55)
            
            # Random characteristics
            aero_demand = rng.choice(["high", "high", "medium", "medium", "low"])  # Weighted toward high
            mechanical_grip = rng.choice(["high", "medium", "medium", "low"])
            power_sensitivity = rng.choice(["high", "medium", "medium", "low"])
            tire_stress = rng.choice(["high", "medium", "medium", "low"])
            
            # Determine track type and characteristics
            track_type = rng.choice(["road", "road", "road", "street"])  # 75% road, 25% street
            characteristics = []
            if power_sensitivity == "high" and aero_demand == "high":
                characteristics.append("high_speed")
            if mechanical_grip == "high" and corner_count > 15:
                characteristics.append("technical")
            
            track = Track(
                track_id=track_id,
                name=track_name,
                prestige_rating=prestige,
                length_km=length_km,
                corner_count=corner_count,
                lap_count=lap_count,
                track_type=track_type,
                characteristics=characteristics,
                aero_demand=aero_demand,
                mechanical_grip_emphasis=mechanical_grip,
                power_sensitivity=power_sensitivity,
                tire_stress=tire_stress,
                min_tier=min_tier,
                max_tier=max_tier,
                track_character=track_character
            )
            
            state.tracks[track_id] = track
        
        _dbg(f"[FTB] WORLD_GEN: Generated {len(state.tracks)} tracks")
    
    @staticmethod
    def _generate_manufacturers_and_parts(state: SimState) -> None:
        """Generate procedural manufacturers and initial parts catalog (Phase 1)"""
        try:
            from plugins.ftb_heritage_templates import HERITAGE_TEMPLATES, get_weighted_template
            from plugins.ftb_names import generate_manufacturer_name, generate_part_model_name
        except ImportError as e:
            _dbg(f"[FTB] ERROR: Could not import heritage templates: {e}")
            return
        
        rng = state.get_rng("world", "manufacturers")
        
        # Part types and their tier availability
        PART_TYPES = {
            "engine": {1, 2, 3, 4, 5},  # Available at all tiers
            "tires": {1, 2, 3, 4, 5},  # Available at all tiers
            "suspension": {2, 3, 4, 5},  # Formula V and above
            "brakes": {2, 3, 4, 5},  # Formula V and above
            "aero_package": {3, 4, 5},  # Formula X and above
            "chassis": {4, 5},  # Formula Y and above
            "cooling": {4, 5},  # Formula Y and above
            "electronics": {5},  # Formula Z only
            "transmission": {5},  # Formula Z only
        }
        
        # Initialize generation counter for each part type
        for part_type in PART_TYPES.keys():
            state.parts_generation_counter[part_type] = 1
        
        # Generate 15-20 manufacturers
        num_manufacturers = rng.randint(15, 20)
        manufacturers_created = []
        
        for i in range(num_manufacturers):
            manufacturer_id = f"mfr_{i+1:03d}"
            
            # Select heritage template weighted by tier distribution
            # We don't know final tier yet, so use mid-tier as baseline
            template = get_weighted_template(rng, tier=3)
            
            # Generate name from template
            manufacturer_name = generate_manufacturer_name(state.seed, i, template)
            
            # Create Manufacturer entity
            manufacturer = Manufacturer()
            manufacturer.entity_id = state._next_entity_id
            state._next_entity_id += 1
            manufacturer.manufacturer_id = manufacturer_id
            manufacturer.name = manufacturer_name
            manufacturer.display_name = manufacturer_name
            manufacturer.nationality = template.nationality
            manufacturer.heritage_template_id = template.nationality.lower()
            manufacturer.founded_year = state.sim_year - rng.randint(5, 40)
            manufacturer.age = state.sim_year - manufacturer.founded_year
            
            # Determine which tiers this manufacturer supplies
            # Based on their financial stability and brand prestige (to be set below)
            num_tiers = rng.choices([1, 2, 3, 4], weights=[0.4, 0.3, 0.2, 0.1])[0]
            base_tier = rng.randint(1, 5)
            manufacturer.active_tiers = set(range(base_tier, min(6, base_tier + num_tiers)))
            
            # Initialize stats from heritage template biases + variance
            for stat_name in STATS_SCHEMAS['Manufacturer']:
                base_value = 50.0
                bias = template.philosophy_bias_stats.get(stat_name, 0.0)
                variance = rng.uniform(-10.0, 10.0)
                final_value = max(1.0, min(99.0, base_value + bias + variance))
                manufacturer.current_ratings[stat_name] = final_value
            
            manufacturer.current_generation = 1
            manufacturer.last_innovation_tick = 0
            
            state.manufacturers[manufacturer_id] = manufacturer
            manufacturers_created.append((manufacturer_id, manufacturer))
            
        _dbg(f"[FTB] WORLD_GEN: Generated {len(manufacturers_created)} manufacturers")
        
        # Generate initial parts catalog with tier-based scaling
        # Dynamic scaling: more manufacturers and generations unlock as tiers progress
        # Tier 1: 2 manufacturers × 1 generation (~2 parts per type)
        # Tier 2-3: +1 manufacturer per tier, +1 generation (~6-12 parts per type)
        # Tier 4-5: +2 manufacturers per tier, +1 generation (~15-25 parts per type)
        parts_created = 0
        
        for part_type, available_tiers in PART_TYPES.items():
            for tier in sorted(available_tiers):
                # Calculate number of manufacturers and generations for this tier
                if tier == 1:
                    num_manufacturers_for_tier = 2
                    max_generation = 1
                elif tier in [2, 3]:
                    num_manufacturers_for_tier = 2 + (tier - 1)  # 3 for tier 2, 4 for tier 3
                    max_generation = tier  # 2 generations for tier 2, 3 for tier 3
                else:  # tier 4 or 5
                    num_manufacturers_for_tier = 2 + 2 * (tier - 1)  # 8 for tier 4, 10 for tier 5
                    max_generation = tier  # 4 generations for tier 4, 5 for tier 5
                
                # Select manufacturers active in this tier
                eligible_manufacturers = [
                    (mfr_id, mfr) for mfr_id, mfr in manufacturers_created
                    if tier in mfr.active_tiers
                ]
                
                if not eligible_manufacturers:
                    # No manufacturers for this tier+part combo, skip
                    continue
                
                # Sample manufacturers (or all if fewer available)
                num_mfrs = min(len(eligible_manufacturers), num_manufacturers_for_tier)
                selected_manufacturers = rng.sample(eligible_manufacturers, num_mfrs)
                
                # Generate parts for each manufacturer at each generation level
                for generation in range(1, max_generation + 1):
                    for mfr_id, mfr in selected_manufacturers:
                        part_id = f"part_{part_type}_t{tier}_{mfr_id}_gen{generation}"
                        
                        # Generate part name
                        part_name = generate_part_model_name(
                            state.seed, part_id, mfr.name, part_type, generation=generation
                        )
                        
                        # Create Part entity
                        part = Part()
                        part.entity_id = state._next_entity_id
                        state._next_entity_id += 1
                        part.part_id = part_id
                        part.name = part_name
                        part.display_name = part_name
                        part.part_type = part_type
                        part.manufacturer_id = mfr_id
                        part.generation = generation
                        part.introduction_year = state.sim_year
                        part.introduction_tick = 0
                        part.tier_minimum = tier
                        part.tier_maximum = 5  # All parts can be used in higher tiers
                        part.age = 0
                        
                        # Initialize stats from manufacturer heritage + generation boost + variance
                        for stat_name in STATS_SCHEMAS['Part']:
                            base_value = 50.0
                            
                            # Inherit manufacturer characteristics more strongly (40-60% influence)
                            # This creates distinct manufacturer identities
                            if stat_name == 'peak_performance':
                                # Innovation-focused manufacturers make faster parts
                                if 'innovation_rate' in mfr.current_ratings:
                                    base_value += (mfr.current_ratings['innovation_rate'] - 50) * 0.5
                                if 'development_cycle_speed' in mfr.current_ratings:
                                    base_value += (mfr.current_ratings['development_cycle_speed'] - 50) * 0.3
                            elif stat_name == 'reliability':
                                # Reliability philosophy directly affects part reliability
                                if 'reliability_philosophy' in mfr.current_ratings:
                                    base_value += (mfr.current_ratings['reliability_philosophy'] - 50) * 0.6
                                if 'quality_control_rigor' in mfr.current_ratings:
                                    base_value += (mfr.current_ratings['quality_control_rigor'] - 50) * 0.4
                            elif stat_name == 'weight':
                                # Build quality affects part weight (inverse - higher quality = lighter)
                                if 'build_quality' in mfr.current_ratings:
                                    base_value -= (mfr.current_ratings['build_quality'] - 50) * 0.4
                            elif stat_name == 'efficiency':
                                # Technical heritage and material science affect efficiency
                                if 'material_science_depth' in mfr.current_ratings:
                                    base_value += (mfr.current_ratings['material_science_depth'] - 50) * 0.5
                                if 'technical_heritage' in mfr.current_ratings:
                                    base_value += (mfr.current_ratings['technical_heritage'] - 50) * 0.3
                            elif stat_name == 'correlation_accuracy':
                                # CFD and technical capabilities affect correlation
                                if 'cfd_capability' in mfr.current_ratings:
                                    base_value += (mfr.current_ratings['cfd_capability'] - 50) * 0.5
                            elif stat_name == 'maintenance_cost':
                                # Financial stability affects cost (more stable = lower costs)
                                if 'financial_stability' in mfr.current_ratings:
                                    base_value -= (mfr.current_ratings['financial_stability'] - 50) * 0.3
                            elif stat_name == 'upgrade_potential':
                                # Risk appetite manufacturers have higher upgrade potential but less reliability
                                if 'risk_appetite' in mfr.current_ratings:
                                    base_value += (mfr.current_ratings['risk_appetite'] - 50) * 0.4
                            
                            # Apply aero/power philosophy for aero packages and engines
                            if part_type in ['aero_package', 'front_wing', 'rear_wing']:
                                if 'aero_philosophy' in mfr.current_ratings:
                                    # Aero-focused manufacturers excel at aero parts
                                    if stat_name in ['peak_performance', 'efficiency', 'correlation_accuracy']:
                                        base_value += (mfr.current_ratings['aero_philosophy'] - 50) * 0.5
                            elif part_type == 'engine':
                                if 'power_philosophy' in mfr.current_ratings:
                                    # Power-focused manufacturers excel at engines
                                    if stat_name in ['peak_performance', 'efficiency']:
                                        base_value += (mfr.current_ratings['power_philosophy'] - 50) * 0.5
                            
                            # Higher generations get performance boost
                            generation_bonus = (generation - 1) * 3.0  # +3 per generation
                            base_value += generation_bonus
                            
                            # Add variance (reduced from ±15 to ±10 since manufacturers already provide variation)
                            variance = rng.uniform(-10.0, 10.0)
                            final_value = max(1.0, min(99.0, base_value + variance))
                            part.current_ratings[stat_name] = final_value
                        
                        # Set regulatory exposure vector (random weights on 5 dimensions)
                        part.regulatory_exposure = {
                            'structural_margin': rng.uniform(0.0, 1.0),
                            'aero_freedom': rng.uniform(0.0, 1.0),
                            'power_ceiling': rng.uniform(0.0, 1.0),
                            'reliability_mandate': rng.uniform(0.0, 1.0),
                            'cost_cap_friendly': rng.uniform(0.0, 1.0)
                        }
                        
                        # Set compatibility tags based on part characteristics
                        if part.current_ratings.get('peak_performance', 50) > 65:
                            part.compatibility_tags.append("high_performance")
                        if part.current_ratings.get('weight', 50) < 40:
                            part.compatibility_tags.append("lightweight")
                        if part.current_ratings.get('reliability', 50) > 65:
                            part.compatibility_tags.append("reliable")
                        
                        part.effectiveness_modifier = 1.0  # New parts start at full effectiveness
                        
                        state.parts_catalog[part_id] = part
                        parts_created += 1
                    
                    # Update generation counter for this part type
                    if generation > state.parts_generation_counter.get(part_type, 0):
                        state.parts_generation_counter[part_type] = generation
        
        _dbg(f"[FTB] WORLD_GEN: Generated {parts_created} parts across {len(PART_TYPES)} part types (tier-scaled)")
    
    @staticmethod
    def _assign_tracks_to_schedule(state: SimState, league: League, num_races: int, start_week: int) -> None:
        """Assign tracks to league schedule, ensuring prestige tracks for finales"""
        rng = state.get_rng("world", f"schedule_{league.league_id}")
        
        # Filter tracks available for this tier
        available_tracks = [
            track for track in state.tracks.values()
            if track.min_tier <= league.tier <= track.max_tier
        ]
        
        if not available_tracks:
            _dbg(f"[FTB] WARNING: No tracks available for {league.name} (tier {league.tier})")
            # Fallback to simple schedule without tracks
            league.schedule = [start_week + idx*2 for idx in range(num_races)]
            return
        
        # Select tracks for season
        selected_track_ids = []
        
        # Season finale gets highest prestige track available
        finale_tracks = sorted(available_tracks, key=lambda t: t.prestige_rating, reverse=True)
        selected_track_ids.append(finale_tracks[0].track_id)
        
        # Fill remaining spots with varied tracks (allow repeats for realism)
        for i in range(num_races - 1):
            track = rng.choice(available_tracks)
            selected_track_ids.insert(i, track.track_id)  # Insert at position (finale stays last)
        
        # Create schedule with tight motorsport calendar spacing by tier
        # Tier 1 (Grassroots/Karting): every 14 days (bi-weekly local events)
        # Tier 2 (Formula V/F4): every 10 days (frequent regional racing)
        # Tier 3 (Formula X/F3): every 10 days (packed F3 schedule)
        # Tier 4 (Formula Y/F2): every 7 days (weekly F2 racing)
        # Tier 5 (Formula Z/F1): every 7 days (weekly F1 grand prix)
        race_spacing = {1: 14, 2: 10, 3: 10, 4: 7, 5: 7}
        spacing = race_spacing.get(league.tier, 10)
        league.schedule = [(start_week + idx*spacing, selected_track_ids[idx]) for idx in range(num_races)]
        
        _dbg(f"[FTB] WORLD_GEN: Assigned {num_races} tracks to {league.name} schedule (every {spacing} days)")

    @staticmethod
    def _ensure_schedule_tracks(state: SimState, league: League) -> None:
        """Ensure league schedule contains valid (tick, track_id) entries."""
        if not league.schedule:
            return

        rng = state.get_rng("world", f"schedule_fix_{league.league_id}")
        available_tracks = [
            track for track in state.tracks.values()
            if track.min_tier <= league.tier <= track.max_tier
        ]

        if not available_tracks:
            _dbg(f"[FTB] ERROR: No tracks available to repair schedule for {league.name} (tier {league.tier})")
            return

        available_track_ids = [track.track_id for track in available_tracks]
        fixed_schedule = []
        fixes = 0
        old_format = league.schedule and not isinstance(league.schedule[0], (tuple, list))

        for entry in league.schedule:
            if isinstance(entry, (tuple, list)) and len(entry) == 2:
                tick = int(entry[0])
                track_id = entry[1]
            else:
                tick = int(entry)
                track_id = None

            if not track_id or track_id not in state.tracks:
                track_id = rng.choice(available_track_ids)
                fixes += 1

            fixed_schedule.append((tick, track_id))

        if fixes > 0 or old_format:
            league.schedule = fixed_schedule
            _dbg(f"[FTB] SCHEDULE_FIX: {league.name} updated {fixes} entries to include valid track IDs")


# ============================================================
# SECTION 5: Simulation Engine (Pure Computation, NO LLM)
# ============================================================

# Stat weighting tables for different series/regulations
# Format: {'stat_name': weight} where weights sum to ~1.0 for clarity

# Part types and their tier availability
PART_TYPES = {
    "engine": {1, 2, 3, 4, 5},  # Available at all tiers
    "tires": {1, 2, 3, 4, 5},  # Available at all tiers
    "suspension": {2, 3, 4, 5},  # Formula V and above
    "brakes": {2, 3, 4, 5},  # Formula V and above
    "aero_package": {3, 4, 5},  # Formula X and above
    "chassis": {4, 5},  # Formula Y and above
    "cooling": {4, 5},  # Formula Y and above 
    "electronics": {5},  # Formula Z only
    "transmission": {5},  # Formula Z only
}

QUALIFYING_WEIGHTS = {
    'default': {
        'driver': {
            'qualifying_pace': 0.6,
            'pace': 0.4,
        },
        'car': {
            'aero_efficiency': 0.3,
            'downforce_peak': 0.2,
            'power_output': 0.2,
            'mechanical_grip': 0.3,
        },
        'mechanic': {
            'pre_race_preparation': 1.0,
        },
        'phase_weights': {  # How much each entity type contributes
            'driver': 0.5,
            'car': 0.4,
            'mechanic': 0.1,
        },
    },
}

RACE_WEIGHTS = {
    'default': {
        'driver': {
            'race_pace': 0.4,
            'pace': 0.2,
            'tire_conservation': 0.2,
            'consistency': 0.2,
        },
        'car': {
            'aero_efficiency': 0.3,
            'reliability': 0.3,
            'mechanical_grip': 0.2,
            'power_delivery_smoothness': 0.2,
        },
        'phase_weights': {
            'driver': 0.6,
            'car': 0.4,
        },
    },
}

STRATEGY_WEIGHTS = {
    'default': {
        'strategist': {
            'race_reading': 0.6,
            'tire_modeling': 0.4,
        },
        'impact_multiplier': 0.15,  # How much strategy can swing performance
    },
}

PIT_WEIGHTS = {
    'default': {
        'mechanic': {
            'pit_execution': 0.7,
            'coordination': 0.3,
        },
        'impact_multiplier': 0.1,  # Pit quality effect on race outcome
    },
}


# ============================================================
# SPONSOR LIFECYCLE COORDINATOR
# ============================================================

def generate_sponsor_offers(state: SimState, team: Team, rng: random.Random, count: int = 3) -> List[Sponsorship]:
    """
    Generate sponsor offers for a team based on tier and reputation.
    Returns list of Sponsorship objects (not yet signed).
    """
    if not ftb_sponsors:
        return []  # Module not available
    
    offers = []
    team_tier = team.tier
    
    # Check if team qualifies for cross-tier sponsor breakthrough
    allow_breakthrough = False
    if team.standing_metrics.get('reputation', 0) >= 70:
        # High reputation unlocks tier-above sponsors
        allow_breakthrough = True
    
    # Check for performance outlier (top 10% of tier with 70%+ win rate)
    # TODO: Add actual win rate tracking and tier percentile calculation
    # For now, use reputation as proxy
    if team.standing_metrics.get('reputation', 0) >= 75:
        allow_breakthrough = True
    
    # Determine how many sponsors to offer based on tier
    # Grassroots: 1-2, Regional: 2-3, National: 3-5, Formula Z: 5-8
    if team_tier == 1:
        num_offers = rng.randint(1, 2)
    elif team_tier in [2, 3]:
        num_offers = rng.randint(2, 3)
    elif team_tier == 4:
        num_offers = rng.randint(3, 5)
    else:
        num_offers = rng.randint(5, 8)
    
    num_offers = min(num_offers, count)  # Respect requested count
    
    # Apply reputation-based sponsor blackout (reduce offers if low reputation)
    reputation = team.standing_metrics.get('reputation', 50)
    if reputation < 30:
        # Severe blackout: 75% fewer offers
        num_offers = max(0, int(num_offers * 0.25))
    elif reputation < 40:
        # Moderate blackout: 50% fewer offers
        num_offers = max(1, int(num_offers * 0.50))
    
    # Generate unique sponsor profiles
    sponsor_idx_base = state.tick + hash(team.name) % 10000
    for i in range(num_offers):
        sponsor_idx = sponsor_idx_base + i
        
        # For the first offer, consider tier breakthrough if eligible
        use_breakthrough = allow_breakthrough and (i == 0) and (rng.random() < 0.15)  # 15% chance for first offer
        
        profile = ftb_sponsors.generate_sponsor_profile(
            state.seed, 
            team_tier, 
            sponsor_idx,
            allow_tier_breakthrough=use_breakthrough
        )
        
        # Generate exclusivity clauses
        exclusivity = ftb_sponsors.generate_exclusivity_clauses(profile, rng)
        
        # Generate infrastructure demands based on financial tier
        infrastructure_demands = {}
        facility_tours = 0
        
        if profile.financial_profile.tier.value == "global":
            # Global sponsors expect professional facilities
            infrastructure_demands = {
                'factory_quality': 70.0,
                'data_analysis': 60.0
            }
            facility_tours = rng.randint(1, 2)  # 1-2 facility tours per season
            
            # If team tier is high enough, also expect advanced facilities
            if team_tier >= 4:
                infrastructure_demands['wind_tunnel_entry'] = 60.0
                
        elif profile.financial_profile.tier.value == "national":
            # National sponsors expect some professionalism
            infrastructure_demands = {
                'workshop': 60.0,
                'data_logging': 55.0
            }
            if team_tier >= 3:
                infrastructure_demands['data_analysis'] = 50.0
            facility_tours = rng.randint(0, 1)
            
        elif profile.financial_profile.tier.value == "regional":
            # Regional sponsors care less about facilities
            if rng.random() < 0.3:  # 30% chance
                infrastructure_demands = {
                    'workshop': 50.0
                }
        
        # High prestige sponsors are more demanding
        if profile.brand_profile.prestige > 0.75:
            for facility in infrastructure_demands:
                infrastructure_demands[facility] += 10.0
        
        # Determine payment amount within profile's range
        payment_min = profile.financial_profile.budget_min
        payment_max = profile.financial_profile.budget_max
        payment = int(rng.uniform(payment_min, payment_max))
        
        # Determine contract duration
        if profile.contract_behavior.loyalty > 0.65:
            duration = rng.randint(2, 3)  # Longer contracts for loyal sponsors
        else:
            duration = 1
        
        # Determine contract type
        if rng.random() < 0.30:  # 30% chance of fixed short
            contract_type = "fixed_short"
            eval_cadence = 3  # Evaluate every 3 races
        else:
            contract_type = "season_partnership"
            eval_cadence = 5  # Evaluate every 5 races
        
        # Create Sponsorship object (offer state, not signed)
        sponsorship = Sponsorship(
            sponsor_name=profile.name,
            tier=profile.financial_profile.tier.value,
            base_payment_per_season=payment,
            duration_seasons=duration,
            # Extended fields
            sponsor_id=profile.sponsor_id,
            industry=profile.industry.value,
            sub_industry=profile.sub_industry.value,
            financial_tier=profile.financial_profile.tier.value,
            brand_profile_json=ftb_sponsors.profile_to_json(profile).split('"brand_profile":')[1].split(',"financial_profile"')[0],  # Extract section
            contract_behavior_json=json.dumps({
                'loyalty': profile.contract_behavior.loyalty,
                'pressure_threshold': profile.contract_behavior.pressure_threshold,
                'performance_dependency': profile.contract_behavior.performance_dependency,
                'reputation_dependency': profile.contract_behavior.reputation_dependency
            }),
            activation_style_json=json.dumps({
                'branding_visibility': profile.activation_style.branding_visibility.value,
                'requires_podiums': profile.activation_style.requires_podiums,
                'requires_media_mentions': profile.activation_style.requires_media_mentions,
                'requires_driver_profile': profile.activation_style.requires_driver_profile
            }),
            narrative_hooks_json=json.dumps({
                'scandal_risk': profile.narrative_hooks.scandal_risk,
                'bailout_savior': profile.narrative_hooks.bailout_savior,
                'hostile_exit': profile.narrative_hooks.hostile_exit,
                'legacy_sponsor': profile.narrative_hooks.legacy_sponsor
            }),
            confidence=100.0,
            contract_type=contract_type,
            evaluation_cadence=eval_cadence,
            signed_tick=0,  # Not signed yet
            exclusivity_clauses=exclusivity,
            infrastructure_demands=infrastructure_demands,
            facility_tour_events_required=facility_tours
        )
        
        offers.append(sponsorship)
    
    return offers


def evaluate_sponsor_confidence(state: SimState, team: Team, sponsor: Sponsorship) -> Tuple[float, Dict[str, float]]:
    """
    Evaluate sponsor confidence based on team performance.
    Returns (confidence_delta, factor_breakdown)
    
    Formula: weighted multi-factor
    - Championship position (40%)
    - Points rate vs expectations (30%)
    - Reputation (20%)
    - Media mentions (10%)
    """
    # Parse contract behavior
    try:
        behavior = json.loads(sponsor.contract_behavior_json) if sponsor.contract_behavior_json else {}
    except (json.JSONDecodeError, TypeError):
        behavior = {'performance_dependency': 0.5, 'reputation_dependency': 0.4}
    
    perf_dependency = behavior.get('performance_dependency', 0.5)
    rep_dependency = behavior.get('reputation_dependency', 0.4)
    
    factors = {}
    
    # 1. Championship position factor
    championship_pos = team.championship_position if hasattr(team, 'championship_position') else 5
    all_teams = ([state.player_team] if state.player_team else []) + state.ai_teams
    total_teams = len([t for t in all_teams if t.tier == team.tier])
    position_percentile = 1.0 - ((championship_pos - 1) / max(1, total_teams - 1))
    
    # Top 3 = positive, bottom half = negative
    if championship_pos <= 3:
        position_factor = 0.20 + (position_percentile * 0.20)
    elif position_percentile > 0.5:
        position_factor = 0.05
    else:
        position_factor = -0.15 * (1.0 - position_percentile * 2)
    
    factors['championship_position'] = position_factor
    
    # 2. Points rate factor
    points = team.points if hasattr(team, 'points') else 0
    races_run = max(1, state.races_run if hasattr(state, 'races_run') else 1)
    points_per_race = points / races_run
    
    # Expected points per race based on position
    expected_ppr = max(5, 30 - championship_pos * 3)
    points_gap = (points_per_race - expected_ppr) / max(1, expected_ppr)
    points_factor = points_gap * 0.20  # +/- 20% based on gap
    factors['points_rate'] = points_factor
    
    # 3. Reputation factor
    reputation = team.reputation if hasattr(team, 'reputation') else 50
    rep_factor = (reputation - 50) / 100.0 * 0.15  # +/- 15%
    factors['reputation'] = rep_factor
    
    # 4. Media mentions factor (simplified - assume 1 mention per 10 reputation)
    media_mentions = reputation // 10
    expected_mentions = 5
    media_factor = (media_mentions - expected_mentions) / max(1, expected_mentions) * 0.10
    factors['media_mentions'] = media_factor
    
    # 5. Infrastructure quality factor (new - checks against sponsor demands)
    infrastructure_factor = 0.0
    if sponsor.infrastructure_demands:
        infra_gaps = []
        for facility, required_quality in sponsor.infrastructure_demands.items():
            unlock_key = f"{facility}_unlocked"
            
            # Determine facility tier for penalty scaling
            facility_tier = FACILITY_TIER_MAP.get(facility, 1)
            tier_penalty_multiplier = {1: 1.0, 2: 1.2, 4: 1.8, 5: 2.5}.get(facility_tier, 1.0)
            
            # Check if facility exists and is unlocked
            if facility in team.infrastructure:
                if unlock_key in team.infrastructure:
                    if team.infrastructure[unlock_key]:
                        actual_quality = team.infrastructure[facility]
                        gap = actual_quality - required_quality
                        
                        # Scale negative gaps by tier (losing Z-tier facility is catastrophic)
                        if gap < 0:
                            gap *= tier_penalty_multiplier
                        
                        # If facility sold (quality at 0) and was high-tier, severe penalty
                        if actual_quality == 0 and facility_tier >= 4:
                            gap = -80.0 * tier_penalty_multiplier
                        
                        infra_gaps.append(gap)
                    else:
                        # Facility not unlocked but required = major penalty
                        infra_gaps.append(-50.0 * tier_penalty_multiplier)
                else:
                    # No unlock key means always accessible
                    actual_quality = team.infrastructure.get(facility, 50.0)
                    gap = actual_quality - required_quality
                    if gap < 0:
                        gap *= tier_penalty_multiplier
                    if actual_quality == 0 and facility_tier >= 4:
                        gap = -80.0 * tier_penalty_multiplier
                    infra_gaps.append(gap)
            else:
                # Facility doesn't exist = penalty
                infra_gaps.append(-30.0 * tier_penalty_multiplier)
        
        if infra_gaps:
            # Average gap across all demanded facilities
            avg_gap = sum(infra_gaps) / len(infra_gaps)
            # Convert to factor: +10 gap = +5% confidence, -10 gap = -5% confidence
            infrastructure_factor = (avg_gap / 10.0) * 0.05
            # Allow more severe penalties for infrastructure failures (especially Z-tier)
            infrastructure_factor = max(-0.40, min(0.15, infrastructure_factor))
        
        factors['infrastructure'] = infrastructure_factor
    else:
        factors['infrastructure'] = 0.0
    
    # Weight factors by sponsor personality
    # Adjust weights to include infrastructure (reduce other weights proportionally)
    base_weight = 0.85 if sponsor.infrastructure_demands else 1.0
    weighted_total = (
        factors['championship_position'] * 0.40 * perf_dependency * base_weight +
        factors['points_rate'] * 0.30 * perf_dependency * base_weight +
        factors['reputation'] * 0.20 * rep_dependency * base_weight +
        factors['media_mentions'] * 0.10 * rep_dependency * base_weight +
        factors['infrastructure'] * 0.15  # Infrastructure gets 15% weight when demanded
    )
    
    # Normalize to confidence delta (-10 to +10 per evaluation)
    confidence_delta = weighted_total * 25.0
    
    # Apply volatility effect (amplifies changes)
    try:
        brand_profile = json.loads(sponsor.brand_profile_json) if sponsor.brand_profile_json else {}
    except (json.JSONDecodeError, TypeError):
        brand_profile = {}
    
    volatility = brand_profile.get('volatility', 0.5)  # 0.0-1.0 scale
    
    # High volatility = faster swings in both directions
    # volatility 0.0 = 0.7x multiplier (stable)
    # volatility 0.5 = 1.0x multiplier (baseline)
    # volatility 1.0 = 1.5x multiplier (highly reactive)
    volatility_multiplier = 0.7 + (volatility * 0.8)
    
    # Cap negative volatility to reduce catastrophic collapses (max 1.3x on negative swings)
    if confidence_delta < 0:
        volatility_multiplier = min(volatility_multiplier, 1.3)
    
    confidence_delta *= volatility_multiplier
    
    return confidence_delta, factors


def check_sponsor_warnings(state: SimState, team: Team, sponsor: Sponsorship) -> Optional[SimEvent]:
    """
    Check if sponsor should issue a performance warning.
    Warning at confidence < 40% if not already warned.
    """
    if sponsor.confidence < 40.0 and not sponsor.warning_issued:
        sponsor.warning_issued = True
        
        # Parse behavior for pressure threshold
        try:
            behavior = json.loads(sponsor.contract_behavior_json) if sponsor.contract_behavior_json else {}
        except:
            behavior = {}
        
        return SimEvent(
            event_type="pressure",
            ts=state.tick,
            category="sponsor_patience_warning",
            severity="warning",
            priority=6.0,
            data={
                'team': team.name,
                'sponsor_name': sponsor.sponsor_name,
                'confidence': sponsor.confidence,
                'tier': sponsor.tier,
                'demands': json.loads(sponsor.activation_style_json) if sponsor.activation_style_json else {},
                'description': f"{sponsor.sponsor_name} is concerned about team performance (confidence: {sponsor.confidence:.0f}%)"
            }
        )
    
    return None


def check_sponsor_termination(state: SimState, team: Team, sponsor: Sponsorship, rng: random.Random) -> Optional[SimEvent]:
    """
    Check if sponsor should terminate contract early.
    Termination at confidence < 20% after warning, or scandal event.
    """
    # Confidence-based termination
    if sponsor.confidence < 20.0 and sponsor.warning_issued:
        # Parse narrative hooks
        try:
            hooks = json.loads(sponsor.narrative_hooks_json) if sponsor.narrative_hooks_json else {}
        except:
            hooks = {}
        
        hostile_exit = hooks.get('hostile_exit', False)
        
        return SimEvent(
            event_type="consequence",
            ts=state.tick,
            category="sponsor_terminated" if not hostile_exit else "sponsor_hostile_exit",
            severity="critical" if hostile_exit else "warning",
            priority=8.0 if hostile_exit else 7.0,
            data={
                'team': team.name,
                'sponsor_name': sponsor.sponsor_name,
                'tier': sponsor.tier,
                'confidence': sponsor.confidence,
                'seasons_remaining': sponsor.duration_seasons - sponsor.seasons_active,
                'hostile_exit': hostile_exit,
                'description': f"{sponsor.sponsor_name} has terminated their sponsorship (confidence: {sponsor.confidence:.0f}%)"
            }
        )
    
    # Scandal-based termination (random event)
    try:
        hooks = json.loads(sponsor.narrative_hooks_json) if sponsor.narrative_hooks_json else {}
    except:
        hooks = {}
    
    scandal_risk = hooks.get('scandal_risk', 0.0)
    if scandal_risk > 0.7 and rng.random() < 0.01:  # 1% chance per tick if high risk
        return SimEvent(
            event_type="consequence",
            ts=state.tick,
            category="sponsor_scandal_exit",
            severity="critical",
            priority=9.0,
            data={
                'team': team.name,
                'sponsor_name': sponsor.sponsor_name,
                'tier': sponsor.tier,
                'scandal_risk': scandal_risk,
                'description': f"{sponsor.sponsor_name} exits due to internal scandal"
            }
        )
    
    return None


def check_sponsor_renewal(state: SimState, team: Team, sponsor: Sponsorship, rng: random.Random) -> Optional[SimEvent]:
    """
    Check if sponsor should offer contract renewal.
    Called when contract duration ends (seasons_active >= duration_seasons).
    """
    if sponsor.seasons_active < sponsor.duration_seasons:
        return None
    
    # Parse loyalty from contract behavior
    try:
        behavior = json.loads(sponsor.contract_behavior_json) if sponsor.contract_behavior_json else {}
    except:
        behavior = {}
    
    loyalty = behavior.get('loyalty', 0.5)
    
    # Renewal probability = loyalty + (confidence - 50) / 100
    renewal_prob = loyalty + (sponsor.confidence - 50.0) / 100.0
    renewal_prob = max(0.0, min(1.0, renewal_prob))
    
    if rng.random() < renewal_prob:
        # Offer renewal
        return SimEvent(
            event_type="opportunity",
            ts=state.tick,
            category="sponsor_renewal_offer",
            severity="info",
            priority=5.0,
            data={
                'team': team.name,
                'sponsor_name': sponsor.sponsor_name,
                'tier': sponsor.tier,
                'current_payment': sponsor.base_payment_per_season,
                'confidence': sponsor.confidence,
                'loyalty': loyalty,
                'description': f"{sponsor.sponsor_name} offers contract renewal"
            }
        )
    else:
        # Natural departure (not hostile)
        return SimEvent(
            event_type="outcome",
            ts=state.tick,
            category="sponsor_departed",
            severity="info",
            priority=4.0,
            data={
                'team': team.name,
                'sponsor_name': sponsor.sponsor_name,
                'tier': sponsor.tier,
                'confidence': sponsor.confidence,
                'description': f"{sponsor.sponsor_name}'s contract has ended"
            }
        )


def apply_sponsor_payment(state: SimState, team: Team, sponsor: Sponsorship) -> Optional[SimEvent]:
    """
    Apply monthly sponsor payment to team budget with performance multipliers and economic downturn effects.
    Returns payment event.
    """
    # Base payment per month (season = 12 months)
    monthly_payment = sponsor.base_payment_per_season // 12
    
    # Apply performance multiplier based on current confidence
    # confidence 100 = 1.5x, 75 = 1.25x, 50 = 1.0x, 25 = 0.75x, 0 = 0.5x
    perf_multiplier = 0.5 + (sponsor.confidence / 100.0)
    perf_multiplier = max(0.5, min(2.0, perf_multiplier))
    
    # Apply economic downturn multiplier if active
    economic_multiplier = state.economic_state.get('sponsor_market_multiplier', 1.0)
    
    actual_payment = int(monthly_payment * perf_multiplier * economic_multiplier)
    
    # Add to team budget
    team.budget.cash += actual_payment
    sponsor.total_paid_this_season += actual_payment
    sponsor.last_payment_tick = state.tick
    
    _dbg(f"[FTB SPONSOR] 💰 {sponsor.sponsor_name} → {team.name}: ${actual_payment:,} (base: ${monthly_payment:,}, conf: {sponsor.confidence:.0f}%, mult: {perf_multiplier:.2f}x)")
    
    # Log sponsor payment transaction (only for player team)
    if team == state.player_team:
        state.log_transaction(
            type="income",
            category="sponsor_payment",
            amount=actual_payment,
            description=f"Monthly payment from {sponsor.sponsor_name}",
            balance_after=team.budget.cash,
            related_entity=sponsor.sponsor_name,
            metadata={'confidence': sponsor.confidence, 'multiplier': perf_multiplier}
        )
    
    return SimEvent(
        event_type="outcome",
        ts=state.tick,
        category="sponsor_payment",
        severity="info",
        priority=2.0,
        data={
            'team': team.name,
            'sponsor_name': sponsor.sponsor_name,
            'amount': actual_payment,
            'base_amount': monthly_payment,
            'multiplier': perf_multiplier,
            'economic_multiplier': economic_multiplier,
            'confidence': sponsor.confidence,
            'description': f"{sponsor.sponsor_name} payment: ${actual_payment:,} (base: ${monthly_payment:,}, multiplier: {perf_multiplier:.2f}x, economic: {economic_multiplier:.2f}x)"
        }
    )


def process_sponsor_lifecycle(state: SimState, team: Team, rng: random.Random) -> List[SimEvent]:
    """
    Process all sponsor lifecycle events for a team.
    Called periodically from main tick loop.
    """
    events = []
    
    if team.name not in state.sponsorships:
        return events
    
    sponsors_to_remove = []
    
    for sponsor in state.sponsorships[team.name]:
        # 1. Evaluate confidence (every evaluation_cadence ticks)
        ticks_since_eval = state.tick - sponsor.last_evaluated_tick
        if ticks_since_eval >= sponsor.evaluation_cadence:
            confidence_delta, factors = evaluate_sponsor_confidence(state, team, sponsor)
            sponsor.confidence += confidence_delta
            sponsor.confidence = max(0.0, min(100.0, sponsor.confidence))
            sponsor.last_evaluated_tick = state.tick
            sponsor.performance_history.append(sponsor.confidence)
            
            # Keep only last 10 evaluations
            if len(sponsor.performance_history) > 10:
                sponsor.performance_history = sponsor.performance_history[-10:]
        
        # 2. Check for warnings
        warning_event = check_sponsor_warnings(state, team, sponsor)
        if warning_event:
            events.append(warning_event)
        
        # 3. Check for termination
        termination_event = check_sponsor_termination(state, team, sponsor, rng)
        if termination_event:
            events.append(termination_event)
            sponsors_to_remove.append(sponsor)
            continue
        
        # 4. Apply monthly payments (every 30 ticks ~ 1 month)
        ticks_since_payment = state.tick - sponsor.last_payment_tick
        if ticks_since_payment >= 30:
            _dbg(f"[FTB SPONSOR] Paying {sponsor.sponsor_name} to {team.name} (ticks since last: {ticks_since_payment})")
            payment_event = apply_sponsor_payment(state, team, sponsor)
            if payment_event:
                events.append(payment_event)
        
        # 5. Check for renewal (at end of season)
        # Simplified: check when seasons_active >= duration_seasons
        # This should be called at season boundaries in real implementation
        renewal_event = check_sponsor_renewal(state, team, sponsor, rng)
        if renewal_event:
            events.append(renewal_event)
            if renewal_event.category == "sponsor_departed":
                sponsors_to_remove.append(sponsor)
    
    # Remove terminated/departed sponsors
    for sponsor in sponsors_to_remove:
        state.sponsorships[team.name].remove(sponsor)
    
    # Mark sponsors dirty to trigger UI refresh if any were removed
    if sponsors_to_remove and team == state.player_team:
        state.mark_dirty('sponsors')
    
    return events


class FTBSimulation:
    """
    All game computation lives here.
    NO LLM CALLS - only numerical computation.
    """
    
    @staticmethod
    def score_entity(entity: Entity, weights: Dict[str, float]) -> float:
        """Score an entity based on weighted stats"""
        if not entity: return 0.0
        score = 0.0
        total_weight = 0.0
        
        for stat, weight in weights.items():
            val = getattr(entity, stat, 50.0)
            score += val * weight
            total_weight += weight
            
        return score / total_weight if total_weight > 0 else 50.0

    @staticmethod
    def compose_phase_score(parts: Dict[str, float], weights: Dict[str, float]) -> float:
        """Compose weighted score from components (driver, car, etc.)"""
        score = 0.0
        total_weight = 0.0
        
        for part_name, val in parts.items():
            w = weights.get(part_name, 0.0)
            score += val * w
            total_weight += w
            
        return score / total_weight if total_weight > 0 else 0.0

    
    @staticmethod
    def _get_expected_races(league: League) -> int:
        """Get expected number of races for a league based on tier"""
        if league.tier == 5:
            return 24  # Formula Z: 24 races
        elif league.tier == 4:
            return 18  # Formula Y: 18 races
        elif league.tier == 3:
            return 16  # Formula X: 16 races
        elif league.tier == 2:
            return 14  # Formula V: 14 races
        else:
            return 12  # Grassroots: 12 races
    
    @staticmethod
    def _get_tier_name(tier: int) -> str:
        """Get display name for tier"""
        tier_names = {
            1: "Grassroots",
            2: "Formula V",
            3: "Formula X",
            4: "Formula Y",
            5: "Formula Z"
        }
        return tier_names.get(tier, f"Tier {tier}")
    
    @staticmethod
    def _calculate_promotion_eligibility(state: SimState, team: Team, position: int, points: float, league: League) -> float:
        """
        Calculate promotion eligibility score (0-100) based on:
        - Championship position
        - Points earned
        - Financial health
        - Team reputation
        - Infrastructure quality
        """
        score = 0.0
        
        # Position weight (40 points max)
        if position == 1:
            score += 40
        elif position == 2:
            score += 30
        elif position == 3:
            score += 20
        
        # Points earned (20 points max)
        # Assume average winner gets ~300 points in grassroots
        expected_winner_points = {1: 250, 2: 350, 3: 400, 4: 450, 5: 500}.get(league.tier, 250)
        points_ratio = min(1.0, points / expected_winner_points)
        score += points_ratio * 20
        
        # Financial health (20 points max)
        cash = team.budget.cash
        tier_cash_threshold = {1: 150000, 2: 300000, 3: 600000, 4: 1200000, 5: 2500000}.get(league.tier, 150000)
        financial_score = min(1.0, cash / tier_cash_threshold)
        score += financial_score * 20
        
        # Reputation (10 points max)
        reputation = team.standing_metrics.get('reputation', 50)
        score += (reputation / 100) * 10
        
        # Infrastructure (10 points max)
        avg_infrastructure = 50  # Default
        if hasattr(team, 'infrastructure') and team.infrastructure:
            qualities = [getattr(team.infrastructure, field, 50) for field in ['factory_quality', 'sim_quality', 'windtunnel_quality', 'data_quality']]
            avg_infrastructure = sum(q for q in qualities if q > 0) / len([q for q in qualities if q > 0]) if any(q > 0 for q in qualities) else 50
        score += (avg_infrastructure / 100) * 10
        
        return score
    
    @staticmethod
    def _calculate_promotion_fee(to_tier: int, team: Team) -> int:
        """Calculate entry fee for applying to promotion"""
        base_fees = {
            2: 100000,   # Grassroots → Formula V
            3: 250000,   # Formula V → Formula X
            4: 500000,   # Formula X → Formula Y
            5: 1000000   # Formula Y → Formula Z
        }
        return base_fees.get(to_tier, 100000)
    
    @staticmethod
    def _evaluate_relegation_risk(state: SimState, team: Team, position: int, points: float, league: League) -> dict:
        """
        Evaluate relegation risk factors and return risk score + reasons
        """
        risk_score = 0.0
        reasons = []
        
        # Poor championship position (40 points max)
        total_teams = len([t for t in league.teams if t])
        if position >= total_teams:
            risk_score += 40
            reasons.append(f"Last place finish")
        elif position >= total_teams - 1:
            risk_score += 30
            reasons.append(f"Second-to-last place")
        elif position >= total_teams - 2:
            risk_score += 20
            reasons.append(f"Bottom 3 finish")
        
        # Low points (20 points max)
        if points < 10:
            risk_score += 20
            reasons.append("Critically low points")
        elif points < 30:
            risk_score += 10
            reasons.append("Below-average points")
        
        # Financial crisis (30 points max)
        cash = team.budget.cash
        financial_crisis = False
        if cash < 20000:
            risk_score += 30
            reasons.append("Financial insolvency")
            financial_crisis = True
        elif cash < 50000:
            risk_score += 20
            reasons.append("Severe cash shortage")
            financial_crisis = True
        elif cash < 100000:
            risk_score += 10
            reasons.append("Financial strain")
        
        # Poor reputation (10 points max)
        reputation = team.standing_metrics.get('reputation', 50)
        if reputation < 20:
            risk_score += 10
            reasons.append("Damaged reputation")
        elif reputation < 35:
            risk_score += 5
            reasons.append("Poor reputation")
        
        return {
            'risk_score': risk_score,
            'reasons': reasons,
            'financial_crisis': financial_crisis
        }
    
    @staticmethod
    def _process_promotion(state: SimState, promo_data: dict) -> List[SimEvent]:
        """Execute a promotion (move team to higher tier)"""
        events = []
        team_obj = promo_data['team_obj']
        from_league = promo_data['from_league']
        to_tier = promo_data['to_tier']
        entry_fee = promo_data['entry_fee']
        
        # Find target league
        target_leagues = [l for l in state.leagues.values() if l.tier == to_tier]
        if not target_leagues:
            _dbg(f"[FTB] ERROR: No league found for tier {to_tier} promotion")
            return events
        
        target_league = target_leagues[0]
        
        # Charge entry fee if applicable
        if entry_fee > 0:
            team_obj.budget.cash -= entry_fee
            events.append(SimEvent(
                event_type="outcome",
                category="promotion_fee_paid",
                ts=state.tick,
                priority=75.0,
                severity="info",
                data={
                    'team': team_obj.name,
                    'fee': entry_fee,
                    'message': f'Paid ${entry_fee:,} promotion entry fee'
                }
            ))
        
        # Move team
        old_tier = team_obj.tier
        from_league.teams.remove(team_obj)
        target_league.teams.append(team_obj)
        team_obj.tier = target_league.tier
        team_obj.league_id = target_league.league_id
        team_obj.tier_name = target_league.tier_name
        
        # Generate promotion success event
        events.append(SimEvent(
            event_type="outcome",
            category="team_promoted",
            ts=state.tick,
            priority=95.0,
            severity="major",
            data={
                'team': team_obj.name,
                'from_tier': old_tier,
                'to_tier': target_league.tier,
                'from_tier_name': FTBSimulation._get_tier_name(old_tier),
                'to_tier_name': target_league.tier_name,
                'entry_fee': entry_fee,
                'message': f'🎉 Promoted to {target_league.tier_name}!'
            }
        ))
        
        # Feature unlocks
        old_features = TIER_FEATURES.get(old_tier, {})
        new_features = TIER_FEATURES.get(target_league.tier, {})
        
        unlocked_features = []
        if not old_features.get('can_hire_strategist') and new_features.get('can_hire_strategist'):
            unlocked_features.append('Strategist hiring')
        if not old_features.get('can_rd_projects') and new_features.get('can_rd_projects'):
            unlocked_features.append('R&D projects')
        if not old_features.get('can_manufacturer_contracts') and new_features.get('can_manufacturer_contracts'):
            unlocked_features.append('Manufacturer partnerships')
        
        if unlocked_features:
            events.append(SimEvent(
                event_type="opportunity",
                category="tier_features_unlocked",
                ts=state.tick,
                priority=85.0,
                severity="info",
                data={
                    'team': team_obj.name,
                    'tier': target_league.tier,
                    'tier_name': target_league.tier_name,
                    'unlocked_features': unlocked_features,
                    'max_engineers': new_features.get('max_engineers', 0),
                    'max_mechanics': new_features.get('max_mechanics', 0)
                }
            ))
        
        state.mark_dirty('standings')
        _dbg(f"[FTB] PROMOTION: {team_obj.name} moved from {FTBSimulation._get_tier_name(old_tier)} to {target_league.tier_name}")
        return events
    
    @staticmethod
    def _process_relegation(state: SimState, releg_data: dict) -> List[SimEvent]:
        """Execute a relegation (move team to lower tier)"""
        events = []
        team_obj = releg_data['team_obj']
        from_league = releg_data['from_league']
        to_tier = releg_data['to_tier']
        forced = releg_data['forced']
        
        # Find target league
        target_leagues = [l for l in state.leagues.values() if l.tier == to_tier]
        if not target_leagues:
            _dbg(f"[FTB] ERROR: No league found for tier {to_tier} relegation")
            return events
        
        target_league = target_leagues[0]
        
        # Move team
        old_tier = team_obj.tier
        from_league.teams.remove(team_obj)
        target_league.teams.append(team_obj)
        team_obj.tier = target_league.tier
        team_obj.league_id = target_league.league_id
        team_obj.tier_name = target_league.tier_name
        
        # Generate relegation event
        events.append(SimEvent(
            event_type="outcome",
            category="team_relegated",
            ts=state.tick,
            priority=90.0,
            severity="major" if forced else "warning",
            data={
                'team': team_obj.name,
                'from_tier': old_tier,
                'to_tier': target_league.tier,
                'from_tier_name': FTBSimulation._get_tier_name(old_tier),
                'to_tier_name': target_league.tier_name,
                'forced': forced,
                'message': f'{"⚠️ FORCED" if forced else "📉 Voluntary"} Relegation to {target_league.tier_name}'
            }
        ))
        
        # Feature losses
        old_features = TIER_FEATURES.get(old_tier, {})
        new_features = TIER_FEATURES.get(target_league.tier, {})
        
        lost_features = []
        if old_features.get('can_hire_strategist') and not new_features.get('can_hire_strategist'):
            lost_features.append('Strategist hiring')
        if old_features.get('can_rd_projects') and not new_features.get('can_rd_projects'):
            lost_features.append('R&D projects')
        if old_features.get('can_manufacturer_contracts') and not new_features.get('can_manufacturer_contracts'):
            lost_features.append('Manufacturer partnerships')
        
        if lost_features:
            events.append(SimEvent(
                event_type="outcome",
                category="tier_features_lost",
                ts=state.tick,
                priority=85.0,
                severity="warning",
                data={
                    'team': team_obj.name,
                    'tier': target_league.tier,
                    'tier_name': target_league.tier_name,
                    'lost_features': lost_features,
                    'max_engineers': new_features.get('max_engineers', 0),
                    'max_mechanics': new_features.get('max_mechanics', 0)
                }
            ))
        
        state.mark_dirty('standings')
        _dbg(f"[FTB] RELEGATION: {team_obj.name} moved from {FTBSimulation._get_tier_name(old_tier)} to {target_league.tier_name} (forced={forced})")
        return events

    @staticmethod
    def tick_simulation(state: SimState) -> List[SimEvent]:
        """
        Main tick loop - advance simulation and return events for narration.
        """
        _dbg(f"[FTB TICK] tick_simulation ENTRY: current_tick={state.tick}, advancing to {state.tick + 1}")
        _dbg(f"[FTB TICK] State before tick: player_team={state.player_team.name if state.player_team else 'None'}, leagues={len(state.leagues)}, day={state.sim_day_of_year}")
        events = []
        
        # ============================================================================
        # PRE-TICK: CHECK FOR UPCOMING PLAYER RACES (Interactive Race Day System)
        # ============================================================================
        # BEFORE advancing tick, check if next tick has a player race
        # If so, show pre-race prompt and pause tick advancement
        if ftb_race_day and state.race_day_state and state.player_team:
            from plugins.ftb_race_day import RaceDayPhase, should_show_pre_race_prompt
            
            # BLOCK tick advancement when in an active race day flow
            # Any phase that isn't IDLE means a race day is in progress
            if state.race_day_state.phase != RaceDayPhase.IDLE:
                _dbg(f"[FTB RACE DAY] ⏸️  Tick blocked - race day active (phase={state.race_day_state.phase.name})")
                return events
            
            # Only check if we're in IDLE phase (not already in a race day flow)
            if state.race_day_state.phase == RaceDayPhase.IDLE:
                race_info = should_show_pre_race_prompt(state, state.tick)
                
                if race_info:
                    race_tick, league, track_id = race_info
                    track = state.tracks.get(track_id) if track_id else None
                    track_name = track.name if track else "Unknown Circuit"
                    
                    _dbg(f"[FTB RACE DAY] 🏁 Pre-race prompt triggered for tick {race_tick}: {league.name} at {track_name}")
                    
                    # Set race day state to PRE_RACE_PROMPT
                    state.race_day_state.phase = RaceDayPhase.PRE_RACE_PROMPT
                    state.race_day_state.race_tick = race_tick
                    state.race_day_state.league_id = league.league_id
                    state.race_day_state.track_id = track_id
                    
                    # Record that we've prompted for this race so we never re-prompt
                    state.prompted_race_ticks.add((league.league_id, race_tick))
                    
                    # Emit event to show prompt in UI
                    events.append(SimEvent(
                        event_type="ui_action",
                        category="show_pre_race_prompt",
                        ts=state.tick,
                        priority=100.0,
                        severity="info",
                        data={
                            '_ftb': True,
                            'league_name': league.name,
                            'league_id': league.league_id,
                            'track_name': track_name,
                            'track_id': track_id,
                            'tier': league.tier,
                            'race_tick': race_tick,
                            'message': f'Race tomorrow at {track_name}'
                        }
                    ))
                    
                    _dbg(f"[FTB RACE DAY] ⏸️  PAUSING tick advance - waiting for player response")
                    # Return immediately without advancing tick
                    # Tick will resume after player responds to prompt
                    return events
        
        # Track initial budget for summary
        if state.player_team:
            state._tick_budget_before = state.player_team.budget.cash
        
        # Advance time
        old_tick = state.tick
        state.tick += 1
        _dbg(f"[FTB TICK] Tick advanced: {old_tick} -> {state.tick}")
        
        # Advance calendar and age entities
        birthday_events = state.advance_calendar()
        events.extend(birthday_events)
        
        # Apply morale mean reversion (daily pull toward personality baseline)
        # Skip on race days to let race performance changes dominate
        is_race_day = False
        for league in state.leagues.values():
            for entry in (league.schedule or []):
                race_tick = entry[0] if isinstance(entry, (tuple, list)) else entry
                if race_tick == state.tick:
                    is_race_day = True
                    break
            if is_race_day:
                break
        
        if not is_race_day:
            morale_changed = False
            for league in state.leagues.values():
                for team in league.teams:
                    morale_reversion_events = state.apply_morale_mean_reversion(team)
                    if morale_reversion_events:
                        morale_changed = True
                    events.extend(morale_reversion_events)
            
            # Mark roster dirty if any morale changes occurred
            if morale_changed:
                state.mark_dirty('roster')
        
        # Update contract openness flags (driver poaching system)
        state.update_contract_openness_flags()
        
        # Process AI poaching attempts (monthly)
        ai_poach_events = state.process_ai_poaching_attempts()
        events.extend(ai_poach_events)
        if ai_poach_events:
            state.mark_dirty('roster')
            state.mark_dirty('finance')
        
        # Age free agents and remove expired ones
        fa_events = state.age_free_agents()
        events.extend(fa_events)
        
        # Process scheduled team spawns (after folds)
        if hasattr(state, '_teams_to_spawn') and state._teams_to_spawn:
            for spawn_data in state._teams_to_spawn[:]:  # Copy list to allow removal during iteration
                if state.tick >= spawn_data['spawn_after_tick']:
                    # Time to spawn this team
                    new_team = FTBSimulation.spawn_new_team(
                        state,
                        tier=spawn_data['tier'],
                        replaced_team_name=spawn_data.get('replaced_team_name')
                    )
                    
                    if new_team:
                        # Generate spawn event
                        events.append(SimEvent(
                            event_type="outcome",
                            category="team_spawned",
                            ts=state.tick,
                            priority=85.0,
                            severity="major",
                            data={
                                'team_name': new_team.name,
                                'tier': new_team.tier,
                                'ownership_type': new_team.ownership_type,
                                'replaced_team': spawn_data.get('replaced_team_name'),
                                'starting_budget': new_team.budget.cash,
                                'message': f'New team {new_team.name} enters {["", "Grassroots", "Formula V", "Formula X", "Formula Y", "Formula Z"][new_team.tier]} competition'
                            }
                        ))
                        state.mark_dirty('standings')
                    
                    # Remove from spawn queue
                    state._teams_to_spawn.remove(spawn_data)
        
        # Process bi-weekly salary payouts (every 14 ticks)
        if (state.tick - state.last_salary_payout_tick) >= 14:
            salary_events = state.process_salary_payouts()
            events.extend(salary_events)
            state.last_salary_payout_tick = state.tick
            if salary_events:
                state.mark_dirty('finance')
        
        # ML ECONOMIC REALISM: Infrastructure maintenance costs (monthly - 2% of facility value per season)
        # Process on monthly basis (every 30 ticks)
        if state.tick % 30 == 0:
            all_teams = ([state.player_team] if state.player_team else []) + state.ai_teams
            for team in all_teams:
                if hasattr(team, 'infrastructure'):
                    # Calculate total infrastructure value and apply 2% annual maintenance (divided by 12 months)
                    monthly_maintenance = 0.0
                    for infra_key, quality in team.infrastructure.items():
                        if infra_key.endswith('_unlocked'):
                            continue
                        # Estimate facility value based on quality (0-100) using exponential scaling
                        # Low quality (20) = ~$10k, Medium (50) = ~$100k, High (80) = ~$500k
                        facility_value = 5000 * (1.08 ** quality)
                        # 2% annual maintenance = 0.167% monthly
                        monthly_maintenance += facility_value * 0.00167
                    
                    if monthly_maintenance > 0:
                        team.budget.cash -= monthly_maintenance
                        if team == state.player_team:
                            events.append(SimEvent(
                                event_type="outcome",
                                category="infrastructure_maintenance",
                                ts=state.tick,
                                priority=40.0,
                                severity="info",
                                data={
                                    'team': team.name,
                                    'maintenance_cost': monthly_maintenance,
                                    'message': f'Infrastructure maintenance: ${monthly_maintenance:,.0f}'
                                }
                            ))
        
        _dbg(f"[FTB TICK] Processing sponsors for tick {state.tick}")
        # Process sponsor lifecycle (payments, evaluations, warnings, terminations)
        rng = random.Random(state.seed + state.tick)
        all_teams = ([state.player_team] if state.player_team else []) + state.ai_teams
        for team in all_teams:
            sponsor_events = process_sponsor_lifecycle(state, team, rng)
            if sponsor_events:
                _dbg(f"[FTB SPONSOR] Team {team.name}: {len(sponsor_events)} sponsor events (types: {[e.category for e in sponsor_events]})")
            events.extend(sponsor_events)
            if sponsor_events:
                state.mark_dirty('finance')
        
        # Generate sponsor offers periodically (every 30 ticks ~ once per month)
        if state.tick % 30 == 0:
            all_teams = ([state.player_team] if state.player_team else []) + state.ai_teams
            for team in all_teams:
                # Only generate offers if team doesn't have too many pending and doesn't have max sponsors
                active_count = len(state.sponsorships.get(team.name, []))
                pending_count = len(state.pending_sponsor_offers.get(team.name, []))
                
                # Max sponsors based on tier
                max_sponsors = {1: 2, 2: 3, 3: 5, 4: 7, 5: 10}.get(team.tier, 3)
                
                if active_count < max_sponsors and pending_count < 3:
                    # Generate 1-2 new offers
                    new_offers = generate_sponsor_offers(state, team, rng, count=rng.randint(1, 2))
                    if new_offers:
                        if team.name not in state.pending_sponsor_offers:
                            state.pending_sponsor_offers[team.name] = []
                        state.pending_sponsor_offers[team.name].extend(new_offers)
                        # Mark sponsors dirty to trigger UI refresh for new offers
                        state.mark_dirty('sponsors')
                        
                        # Emit offer event for player team
                        if team == state.player_team:
                            for offer in new_offers:
                                events.append(SimEvent(
                                    event_type="opportunity",
                                    category="sponsor_offer",
                                    ts=state.tick,
                                    priority=70.0,
                                    severity="info",
                                    data={
                                        'team': team.name,
                                        'sponsor_name': offer.sponsor_name,
                                        'tier': offer.tier,
                                        'payment': offer.base_payment_per_season,
                                        'duration': offer.duration_seasons
                                    },
                                    description=f"Sponsor offer from {offer.sponsor_name}: ${offer.base_payment_per_season:,}/season"
                                ))
        
        # ═══════════════════════════════════════════════════════════════
        # PROCESS PENDING PROMOTIONS & RELEGATIONS
        # ═══════════════════════════════════════════════════════════════
        if hasattr(state, 'pending_promotions'):
            promotions_to_process = [p for p in state.pending_promotions if p['process_tick'] <= state.tick]
            for promo in promotions_to_process:
                promo_events = FTBSimulation._process_promotion(state, promo)
                events.extend(promo_events)
                state.pending_promotions.remove(promo)
        
        if hasattr(state, 'pending_relegations'):
            relegations_to_process = [r for r in state.pending_relegations if r['process_tick'] <= state.tick]
            for releg in relegations_to_process:
                releg_events = FTBSimulation._process_relegation(state, releg)
                events.extend(releg_events)
                state.pending_relegations.remove(releg)
        
        # Process economic downturn events (rare, every ~3-5 seasons)
        if state.tick % 30 == 0:  # Check monthly
            downturn_events = FTBSimulation._process_economic_downturn(state, rng)
            events.extend(downturn_events)
            if downturn_events:
                state.mark_dirty('finance')
        
        # Staff progression (monthly - infrastructure impact)
        if state.tick % 30 == 0:
            staff_progression_events = FTBSimulation._progress_staff_training(state)
            events.extend(staff_progression_events)
        
        # Manufacturer innovation cycles (Phase 6.1-6.3)
        innovation_events = FTBSimulation._process_manufacturer_innovation(state)
        events.extend(innovation_events)
        if innovation_events:
            state.mark_dirty('parts_market')
        
        # Propagate obsolescence effects (Phase 6.4)
        obsolescence_events = FTBSimulation._propagate_obsolescence_effects(state)
        events.extend(obsolescence_events)
        
        # Meta shifts from regulatory changes (Phase 6.5-6.6)
        meta_events = FTBSimulation._process_meta_shifts(state)
        events.extend(meta_events)
        if meta_events:
            state.mark_dirty('meta')
        
        # Competitive pressure driving innovation (Phase 6.7-6.9)
        pressure_events = FTBSimulation._process_competitive_pressure(state)
        events.extend(pressure_events)
        
        # Handle offseason ticks
        if state.in_offseason and state.offseason_ticks_remaining > 0:
            state.offseason_ticks_remaining -= 1
            
            # Silly Season processing (Formula Z only, weekly during offseason)
            if state.tick % 7 == 0:  # Weekly checks during offseason
                silly_season_events = FTBSimulation._process_silly_season(state)
                events.extend(silly_season_events)
                if silly_season_events:
                    state.mark_dirty('job_market')
            
            if state.offseason_ticks_remaining == 0:
                state.in_offseason = False
                state.phase = "development"  # Exit offseason, return to normal development
                events.append(SimEvent(
                    event_type="time",
                    category="offseason_end",
                    ts=state.tick,
                    priority=75.0,
                    data={'new_season': state.season_number, 'message': 'New season begins!'}
                ))
        
        # Resolve pending developments
        dev_events = FTBSimulation._resolve_pending_developments(state)
        events.extend(dev_events)
        if dev_events:
            state.mark_dirty('development')
        
        # Progress R&D projects (Phase 4.5)
        rd_events = FTBSimulation._progress_rd_projects(state)
        events.extend(rd_events)
        if rd_events:
            state.mark_dirty('development')
        
        # Check league schedules and simulate races
        races_this_tick = 0
        for league_id, league in state.leagues.items():
            # Handle both old format (List[int]) and new format (List[Tuple[int, str]])
            # New format is preferred: [(tick, track_id), ...] with proper track assignments
            race_entry = None
            track_id = None
            
            # Check if schedule needs migration
            # Note: JSON deserialization converts tuples to lists
            if league.schedule and not isinstance(league.schedule[0], (tuple, list)):
                _dbg(f"[FTB] WARNING: {league.name} schedule uses old format (tick-only). Track assignments missing.")
            
            for entry in league.schedule:
                if isinstance(entry, (tuple, list)) and len(entry) == 2:
                    # New format: (tick, track_id) or [tick, track_id] from JSON
                    if entry[0] == state.tick:
                        race_entry = entry
                        track_id = entry[1]
                        break
                else:
                    # Old format: just tick number
                    if entry == state.tick:
                        race_entry = entry
                        track_id = None
                        break
            
            if race_entry is not None:
                # CRITICAL FIX: Skip if this race was already completed (via live race day system)
                if (league.league_id, state.tick) in state.completed_race_ticks:
                    _dbg(f"[FTB] RACE_SKIP: {league.name} race at tick {state.tick} already completed (live race day)")
                    continue
                
                # CRITICAL FIX: Skip player's league if the interactive race day system
                # is handling it (QUALI_COMPLETE or RACE_RUNNING)
                if ftb_race_day and state.race_day_state and state.race_day_state.phase.value != "idle":
                    from plugins.ftb_race_day import RaceDayPhase as _RDP
                    if (state.race_day_state.phase not in (_RDP.IDLE, _RDP.POST_RACE_ADVANCE)
                            and state.race_day_state.league_id == league.league_id):
                        _dbg(f"[FTB] RACE_SKIP: {league.name} race at tick {state.tick} handled by interactive race day (phase={state.race_day_state.phase.name})")
                        continue
                
                races_this_tick += 1
                
                # Get track info if available
                track = state.tracks.get(track_id) if track_id else None
                if not track:
                    WorldBuilder._ensure_schedule_tracks(state, league)
                    track_id = None
                    for entry in league.schedule:
                        if isinstance(entry, (tuple, list)) and len(entry) == 2 and entry[0] == state.tick:
                            track_id = entry[1]
                            break
                    track = state.tracks.get(track_id) if track_id else None
                    if not track:
                        track = next((t for t in state.tracks.values()
                                      if t.min_tier <= league.tier <= t.max_tier), None)
                        track_id = track.track_id if track else None
                        if not track:
                            _dbg(f"[FTB] ERROR: No valid track found for {league.name} at tick {state.tick}")
                            continue
                track_name = track.name if track else "Unknown Circuit"
                
                # CHECK: Is this the player's league and should we prompt for live viewing?
                is_player_race = state.player_team and state.player_team.league_id == league_id
                should_watch_live = False
                
                # For player races (not in delegate mode), ask if they want to watch live
                # This happens automatically without interrupting flow
                if is_player_race and state.control_mode != "delegated":
                    # Check if we should watch live (default to instant if not set)
                    should_watch_live = getattr(state, '_watch_current_race_live', False)
                    # Clear the flag after checking
                    state._watch_current_race_live = False
                
                _dbg(f"[FTB] RACE_START: Tick {state.tick} - {league.name} (Tier {league.tier}) Round {league.races_this_season + 1} at {track_name}")
                _dbg(f"[FTB] Live viewing mode: {'ENABLED' if should_watch_live else 'DISABLED'}")
                
                # Update phase to race_weekend
                state.phase = "race_weekend"
                
                # Emit race weekend start event
                events.append(SimEvent(
                    event_type="time",
                    category="enter_race_weekend",
                    ts=state.tick,
                    priority=70.0,
                    data={
                        'league_id': league_id,
                        'league_name': league.name,
                        'tier': league.tier,
                        'round_number': league.races_this_season + 1,
                        'calendar_date': state.current_date_str(),
                        'track_id': track_id,
                        'track_name': track_name
                    }
                ))
                
                # Emit audio event: start engine audio for this league tier
                league_tier_map = {1: 'formulaz', 2: 'formulaz', 3: 'midformula', 4: 'midformula', 5: 'grassroots'}
                league_tier_audio = league_tier_map.get(league.tier, 'midformula')
                events.append(SimEvent(
                    event_type="audio",
                    category="race_start",
                    ts=state.tick,
                    priority=50.0,
                    data={
                        'audio_type': 'world',
                        'action': 'engine_start',
                        'league_tier': league_tier_audio
                    }
                ))
                
                # Simulate race for this league (pass track)
                race_events = FTBSimulation.simulate_race_weekend(state, league, track)
                
                # If should_watch_live, we need to stream these events over time instead of dumping them all at once
                if should_watch_live:
                    _dbg(f"[FTB] 🎥 Live race mode activated - will stream {len(race_events)} events")
                    state._live_pbp_mode = True
                    state._live_pbp_events = race_events  # Store for streaming
                    state._live_pbp_cursor = 0
                    state._live_pbp_start_ts = time.time()
                    state._live_pbp_interval = 2.0  # 2 seconds per event
                    
                    # Start live feed in ftb_pbp
                    race_result = state._last_race_results.get(league.league_id)
                    if race_result:
                        try:
                            import plugins.ftb_pbp as ftb_pbp
                            ftb_pbp.start_live_feed(race_result, state, interval_sec=2.0)
                            _dbg(f"[FTB] 📺 ftb_pbp live feed started")
                        except Exception as e:
                            _dbg(f"[FTB] Warning: Could not start ftb_pbp live feed: {e}")
                    
                    # Don't add race_events to main events list yet - they'll be streamed
                    # Instead, return a special event that tells the controller to enter streaming mode
                    events.append(SimEvent(
                        event_type="control",
                        category="enter_live_race_mode",
                        ts=state.tick,
                        priority=100.0,
                        data={
                            'league_id': league_id,
                            'total_events': len(race_events),
                            'duration_sec': len(race_events) * 2.0
                        }
                    ))
                else:
                    # Normal instant race - add all events immediately
                    events.extend(race_events)
                
                state.completed_race_ticks.add((league.league_id, state.tick))
                state.pending_race_day = False
                state.pending_race_info = None
                state.pending_race_tick = None
                
                # CRITICAL FIX: Reset race_day_state to IDLE after race completes
                # This prevents the state from getting stuck in non-IDLE phases
                if ftb_race_day and hasattr(state, 'race_day_state') and state.race_day_state:
                    from plugins.ftb_race_day import RaceDayPhase
                    state.race_day_state.phase = RaceDayPhase.IDLE
                    state.race_day_state.player_wants_live_race = False
                    state.race_day_state.live_race_active = False
                    _dbg(f"[FTB] 🔄 Reset race_day_state to IDLE after race completion")
                
                # Create notification for player team race result
                if state.player_team and not state.race_day_active:
                    try:
                        import plugins.ftb_notifications as ftb_notif
                        
                        # Find player team's race result
                        player_result = next(
                            (e for e in race_events 
                             if e.category == "race_result" and e.data.get('team') == state.player_team.name),
                            None
                        )
                        
                        if player_result:
                            pos = player_result.data.get('position', 0)
                            points = player_result.data.get('points', 0)
                            track_name = player_result.data.get('track_name', 'Unknown')
                            
                            # Determine priority based on result
                            if pos <= 3:
                                priority = 80  # Podium = high priority
                                title = f"🏆 P{pos} Finish at {track_name}!"
                            else:
                                priority = 60
                                title = f"🏁 P{pos} Finish at {track_name}"
                            
                            message = f"{state.player_team.name} finished P{pos} and earned {points} points"
                            if player_result.data.get('prize_money', 0) > 0:
                                from plugins.ftb_game import format_currency
                                prize = format_currency(player_result.data['prize_money'])
                                message += f" and {prize} prize money"
                            
                            ftb_notif.create_notification(
                                category='race_result',
                                title=title,
                                message=message,
                                priority=priority,
                                metadata={'position': pos, 'points': points, 'track': track_name},
                                db_path=getattr(state, 'state_db_path', None)
                            )
                            _dbg(f"[FTB] ✅ Created race result notification: {title}")
                    except Exception as e:
                        _dbg(f"[FTB] Failed to create race result notification: {e}")
                        import traceback
                        traceback.print_exc()
                
                # Mark stats as dirty after race
                state.mark_dirty('stats')
                
                # Return to development phase after race weekend
                state.phase = "development"
                
                _dbg(f"[FTB] RACE_COMPLETE: {league.name} Round {league.races_this_season} - {len(race_events)} events generated")
                
                # Emit audio event: stop engine audio
                events.append(SimEvent(
                    event_type="audio",
                    category="race_end",
                    ts=state.tick,
                    priority=50.0,
                    data={
                        'audio_type': 'world',
                        'action': 'engine_stop'
                    }
                ))
                
        # Check for season end per league
        for league_id, league in state.leagues.items():
            # Check if season is complete for this league
            expected_races = FTBSimulation._get_expected_races(league)
            if league.races_this_season >= expected_races:
                _dbg(f"[FTB] SEASON_END: {league.name} completed {league.races_this_season} races")
                season_end_events = FTBSimulation.process_season_end_for_league(state, league)
                events.extend(season_end_events)
        
        # Update entity growth/decay
        FTBSimulation.update_entity_growth_decay(state)
        
        # Apply financial flows
        financial_events = FTBSimulation.apply_financial_flows(state)
        if financial_events:
            state.mark_dirty('finance')
        events.extend(financial_events)
        
        # Update standing metrics
        if state.player_team:
            expectations = FTBSimulation.infer_role_and_expectations(state, state.player_team)
            standing_events = FTBSimulation.update_standing_metrics(state, state.player_team, {}, expectations.get('role', 'survivor'))
            events.extend(standing_events)
        
        # Generate opportunities
        opp_events = FTBSimulation.generate_opportunities(state)
        events.extend(opp_events)
        
        # Regulation changes (every 3 seasons = 48 races, announce 180 days ahead)
        if state.races_completed_this_season % 48 == 0 and state.races_completed_this_season > 0:
            regulation_events = FTBSimulation._generate_regulation_change(state)
            events.extend(regulation_events)
        
        # Formula Z news generation (if meta plugin is available)
        # This is called periodically from meta plugin, but we trigger it here
        # The meta plugin will check if enough time has passed
        
        # AI team action execution (probabilistic 10% per team per tick)
        ai_action_events = FTBSimulation._execute_ai_team_actions(state)
        events.extend(ai_action_events)
        if ai_action_events:
            # AI actions might change contracts, roster, finances
            state.mark_dirty('team')
            state.mark_dirty('contracts')
        
        # Player delegation execution (AI makes decisions for player team)
        if state.control_mode == "delegated" and state.player_team:
            delegated_events = FTBSimulation._execute_player_delegation(state)
            events.extend(delegated_events)
            if delegated_events:
                state.mark_dirty('team')
                state.mark_dirty('contracts')
                state.mark_dirty('development')
                state.mark_dirty('finance')
        
        # Check pending decisions and auto-resolve expired ones
        decision_events = FTBSimulation.check_pending_decisions(state)
        events.extend(decision_events)
        
        # Assign event IDs to all events
        for event in events:
            if event.event_id == 0:
                event.event_id = FTBSimulation._generate_event_id(state)
        
        # Persist events to history (for standing metrics and replay analysis)
        state.event_history.extend(events)
        
        # Trim event history to last 100 events to prevent unbounded growth
        if len(state.event_history) > 100:
            state.event_history = state.event_history[-100:]
        
        # Emit performance state update for audio engine (modal drift music)
        if state.player_team:
            team_standings = state.leagues.get(state.player_team.league_id)
            position = 10  # Default mid-pack
            max_position = 20
            
            if team_standings:
                # Find player team position in standings
                for idx, team in enumerate(team_standings.teams, 1):
                    if team.team_id == state.player_team.team_id:
                        position = idx
                        break
                max_position = len(team_standings.teams)
            
            # Gather performance metrics
            budget_value = getattr(state.player_team, 'budget', 0)
            if hasattr(budget_value, 'cash'):
                budget_value = budget_value.cash
            performance_data = {
                'morale': getattr(state.player_team, 'morale', 0.5),
                'reputation': getattr(state.player_team, 'reputation', 0.5),
                'legitimacy': getattr(state.player_team, 'legitimacy', 0.5),
                'position': position,
                'max_position': max_position,
                'budget': budget_value,
                'budget_baseline': 1000000,  # Baseline budget for comparison
            }
            
            events.append(SimEvent(
                event_type="audio",
                category="state_update",
                ts=state.tick,
                priority=50.0,
                data=performance_data
            ))
        
        # Generate a tick summary event for player visibility (always generate even if quiet tick)
        if state.player_team:
            budget_before = getattr(state, '_tick_budget_before', state.player_team.budget.cash)
            budget_after = state.player_team.budget.cash
            budget_change = budget_after - budget_before
            
            summary_data = {
                'tick': state.tick,
                'day': state.sim_day_of_year,
                'season': state.season_number,
                'date_str': state.current_date_str(),
                'player_team': state.player_team.name,
                'budget_before': budget_before,
                'budget_after': budget_after,
                'budget_change': budget_change,
                'event_count': len(events),
                'phase': state.phase
            }
            
            # Construct informative message
            budget_change_str = f"${abs(budget_change):,.0f}" if budget_change != 0 else "$0"
            budget_change_sign = "+" if budget_change > 0 else "-" if budget_change < 0 else ""
            
            # Add financial details if salary payout occurred
            if (state.tick - state.last_salary_payout_tick) == 0:
                payroll = state.player_team.budget.calculate_staff_payroll() * 14  # Bi-weekly total
                summary_data['payroll_paid'] = payroll
                summary_data['message'] = f"Day {state.sim_day_of_year}: Payroll paid ({budget_change_sign}{budget_change_str})"
                summary_data['detail'] = f"Bi-weekly payroll for {len(state.player_team.budget.staff_salaries)} staff"
            else:
                days_to_payout = 14 - (state.tick - state.last_salary_payout_tick)
                if budget_change != 0:
                    summary_data['message'] = f"Day {state.sim_day_of_year}: {budget_change_sign}{budget_change_str} • Next payroll in {days_to_payout} ticks"
                else:
                    summary_data['message'] = f"Day {state.sim_day_of_year}: Routine operations • Next payroll in {days_to_payout} ticks"
            
            # Always emit time advancement event for UI feedback
            events.append(SimEvent(
                event_type="time",
                category="tick_summary",
                ts=state.tick,
                priority=10.0,  # Low priority, informational only
                severity="info",
                data=summary_data
            ))
        
        _dbg(f"[FTB TICK] tick_simulation COMPLETE: generated {len(events)} events for tick {state.tick}")
        _dbg(f"[FTB TICK] Final state: player_team={state.player_team.name if state.player_team else 'None'}, leagues={len(state.leagues)}, phase={state.phase}")
        if events:
            event_categories = [e.category for e in events]
            _dbg(f"[FTB TICK] 📋 Event categories: {event_categories}")
        else:
            _dbg(f"[FTB TICK] ⚠️ No events generated this tick!")
        
        return events
    
    @staticmethod
    def calculate_morale_diminishing_returns(current_morale: float, proposed_change: float) -> float:
        """Calculate diminishing returns multiplier for morale changes
        
        Prevents runaway high/low morale by reducing effectiveness of
        changes when morale is already extreme.
        
        Args:
            current_morale: Current morale value (0-100)
            proposed_change: Proposed morale change amount
        
        Returns:
            Multiplier between 0.0 and 1.0
        """
        # Distance from center (50)
        distance_from_center = abs(current_morale - 50.0)
        threshold = MORALE_CONFIG['diminishing_returns_threshold']
        
        # If change would push further from center, apply diminishing returns
        if (current_morale > 50.0 and proposed_change > 0) or \
           (current_morale < 50.0 and proposed_change < 0):
            
            # Stronger diminishing returns as you get further from 50
            # At morale 70 (dist=20): 100% effectiveness (at threshold)
            # At morale 80 (dist=30): 60% effectiveness
            # At morale 90 (dist=40): 20% effectiveness (extreme cap)
            # At morale 20 (dist=30): 60% effectiveness (for negative changes)
            # At morale 10 (dist=40): 20% effectiveness (extreme cap)
            
            if distance_from_center < threshold:
                return 1.0  # Full effect within normal range
            elif distance_from_center < threshold + 10:
                return 0.8  # 80% effect
            elif distance_from_center < threshold + 20:
                return 0.5  # 50% effect
            else:
                return MORALE_CONFIG['extreme_morale_cap']  # 20% effect at extremes
        
        else:
            # Change brings morale back toward center - allow full effect
            return 1.0
    
    @staticmethod
    def _apply_performance_morale_changes(state: SimState, league: League, race_result: 'RaceResult', 
                                          qualifying_scores: List[Tuple['Team', 'Driver', float]]) -> List[SimEvent]:
        """
        Apply morale changes to teams and entities based on race performance.
        Uses mettle stat to determine resistance to morale loss from poor results.
        
        Threshold-based system:
        - Finish above expected position → small morale gain (not mettle-scaled)
        - Finish at expected position → no change
        - Finish below expected position → morale loss scaled by (100 - mettle) / 100
        
        Lower mettle = more vulnerable to bad results
        Higher mettle = more resilient to setbacks
        """
        events = []
        
        # Build expected positions from qualifying order
        expected_positions = {}
        for idx, (team, driver, qual_score) in enumerate(qualifying_scores, 1):
            expected_positions[team.name] = idx
        
        # Process race results and apply morale changes
        for position, (driver_name, team_name, status) in enumerate(race_result.final_positions, 1):
            # Find team object
            team = next((t for t in league.teams if t.name == team_name), None)
            if not team:
                continue
            
            # Find driver object
            driver = next((d for d in team.drivers if d and d.name == driver_name), None)
            if not driver:
                continue
            
            # Calculate performance delta
            expected_pos = expected_positions.get(team_name, position)
            position_delta = expected_pos - position  # Positive = better than expected, negative = worse
            
            # Skip if DNF'd (different morale logic could be added for DNFs)
            if status != 'finished':
                # DNF is always bad - apply significant morale hit (3x more impactful)
                dnf_morale_loss = -15.0
                driver_mettle = getattr(driver, 'mettle', 55.0)
                mettle_multiplier = (100.0 - driver_mettle) / 100.0
                adjusted_dnf_loss = dnf_morale_loss * mettle_multiplier
                
                # Apply to driver if they have morale stat
                if hasattr(driver, 'morale'):
                    old_morale = driver.morale
                    
                    # Apply diminishing returns to prevent runaway low morale
                    diminishing_mult = FTBSimulation.calculate_morale_diminishing_returns(old_morale, adjusted_dnf_loss)
                    final_dnf_change = adjusted_dnf_loss * diminishing_mult
                    
                    driver.morale = max(0.0, min(100.0, driver.morale + final_dnf_change))
                    
                    events.append(SimEvent(
                        event_type="outcome",
                        category="morale",
                        ts=state.tick,
                        priority=65.0,
                        severity="warning",
                        data={
                            'entity': driver_name,
                            'team': team_name,
                            'morale_change': final_dnf_change,
                            'old_morale': old_morale,
                            'new_morale': driver.morale,
                            'reason': f"DNF: {status}",
                            'mettle': driver_mettle,
                            'diminishing_multiplier': diminishing_mult
                        }
                    ))
                
                # Apply to team morale metric (full impact, not half)
                if 'morale' in team.standing_metrics:
                    old_team_morale = team.standing_metrics['morale']
                    team.standing_metrics['morale'] = max(0.0, min(100.0, old_team_morale + adjusted_dnf_loss * 0.8))
                continue
            
            # Calculate morale change based on performance delta (3x more reactive)
            morale_change = 0.0
            
            if position_delta > 2:
                # Significantly better than expected - strong morale boost
                morale_change = min(12.0, position_delta * 3.5)
            elif position_delta > 0:
                # Slightly better than expected - good boost
                morale_change = position_delta * 2.5
            elif position_delta == 0:
                # Exactly as expected - tiny boost (meeting expectations is good)
                morale_change = 0.5
            elif position_delta >= -2:
                # Slightly worse than expected - noticeable loss, mettle-scaled
                driver_mettle = getattr(driver, 'mettle', 55.0)
                mettle_multiplier = (100.0 - driver_mettle) / 100.0
                morale_change = position_delta * 4.0 * mettle_multiplier
            else:
                # Much worse than expected - severe loss, mettle-scaled
                driver_mettle = getattr(driver, 'mettle', 55.0)
                mettle_multiplier = (100.0 - driver_mettle) / 100.0
                morale_change = max(-20.0, position_delta * 5.0 * mettle_multiplier)
            
            # Apply morale changes to driver (if they have morale stat)
            if hasattr(driver, 'morale') and abs(morale_change) >= 0.5:
                old_morale = driver.morale
                
                # Apply diminishing returns to prevent runaway morale
                diminishing_mult = FTBSimulation.calculate_morale_diminishing_returns(old_morale, morale_change)
                final_change = morale_change * diminishing_mult
                
                # Cap at max single change limit
                max_change = MORALE_CONFIG.get('max_single_change', 20.0)
                final_change = max(-max_change, min(max_change, final_change))
                
                driver.morale = max(0.0, min(100.0, driver.morale + final_change))
                
                events.append(SimEvent(
                    event_type="outcome",
                    category="morale",
                    ts=state.tick,
                    priority=55.0,
                    severity="info" if final_change > 0 else "minor",
                    data={
                        'entity': driver_name,
                        'team': team_name,
                        'morale_change': final_change,
                        'old_morale': old_morale,
                        'new_morale': driver.morale,
                        'reason': f"Finished P{position} (expected P{expected_pos})",
                        'position': position,
                        'expected_position': expected_pos,
                        'mettle': getattr(driver, 'mettle', 55.0),
                        'diminishing_multiplier': diminishing_mult
                    }
                ))
            
            # Apply to team morale metric (aggregate effect, 80% of driver morale change)
            if 'morale' in team.standing_metrics and abs(morale_change) >= 0.5:
                old_team_morale = team.standing_metrics['morale']
                # Team morale changes almost as much as driver morale
                team_morale_change = morale_change * 0.8
                team.standing_metrics['morale'] = max(0.0, min(100.0, old_team_morale + team_morale_change))
        
        return events
    
    @staticmethod
    def _get_base_race_prize(league: League) -> float:
        # Pool size per race (distributed by points table share)
        # Increased 4-5x to inject more cash and make race results financially meaningful
        tier_race_prizes = {
            1: 175000,      # was 37,500 (4.7x increase) - Grassroots need more support
            2: 250000,      # was 50,000 (5x increase)
            3: 500000,      # was 125,000 (4x increase)
            4: 1000000,     # was 250,000 (4x increase)
            5: 2000000      # was 500,000 (4x increase)
        }
        return tier_race_prizes.get(league.tier, 175000)

    @staticmethod
    def _get_race_prize_share(points_table: List[int], position: int) -> float:
        if position <= 0 or position > len(points_table):
            return 0.0
        total_points = sum(points_table)
        if total_points <= 0:
            return 0.0
        return float(points_table[position - 1]) / float(total_points)

    @staticmethod
    def _calculate_race_hype(league: League, race_result, qualifying_scores: List) -> float:
        """Calculate hype generated by this race based on deviations from expected results"""
        hype_gain = 0.0
        
        if not race_result.final_positions or len(race_result.final_positions) < 2:
            return 0.0
        
        # Factor 1: Close finishes (photo finish drama)
        # Check if top 2 had similar qualifying performance
        if len(qualifying_scores) >= 2:
            # Get qual scores for top 2 finishers in race
            p1_name = race_result.final_positions[0][0]  # driver name
            p2_name = race_result.final_positions[1][0] if len(race_result.final_positions) > 1 else None
            
            if p2_name:
                # Check margin in championship if available
                if league.driver_championship:
                    top_drivers = sorted(league.driver_championship.items(), key=lambda x: x[1], reverse=True)[:5]
                    if any(p1_name == d[0] or p2_name == d[0] for d in top_drivers):
                        hype_gain += 0.015  # Championship battle finish
        
        # Factor 2: Underdog/upset victories (qualifying position vs finish)
        winner_team = race_result.final_positions[0][1]  # team name
        winner_driver = race_result.final_positions[0][0]
        
        # Find winner's starting position
        winner_grid = None
        for idx, (team, driver, _) in enumerate(qualifying_scores, 1):
            if team.name == winner_team and driver.name == winner_driver:
                winner_grid = idx
                break
        
        if winner_grid and winner_grid > 1:
            # Gained positions = hype (logarithmic)
            positions_gained = winner_grid - 1
            if positions_gained >= 10:
                hype_gain += 0.05  # Dramatic comeback
            elif positions_gained >= 5:
                hype_gain += 0.03  # Strong upset
            elif positions_gained >= 3:
                hype_gain += 0.015  # Notable upset
        
        # Factor 3: Championship battle tightness (if late season)
        if league.races_this_season >= 8 and league.championship_table:
            # Get top 3 in championship
            sorted_standings = sorted(league.championship_table.items(), key=lambda x: x[1], reverse=True)
            if len(sorted_standings) >= 2:
                leader_points = sorted_standings[0][1]
                second_points = sorted_standings[1][1]
                gap = leader_points - second_points
                
                # Tight title fight generates hype
                if gap < 10:
                    hype_gain += 0.04  # Very tight
                elif gap < 25:
                    hype_gain += 0.02  # Close fight
        
        # Factor 4: Multiple teams in points (competitive field)
        teams_scoring = len([t for t, d, s in race_result.final_positions if s == 'finished'])
        if teams_scoring >= len(race_result.final_positions) * 0.8:  # 80%+ finish rate
            hype_gain += 0.01  # Clean, competitive race
        
        return hype_gain

    @staticmethod
    def _archive_race_result(state: SimState, league: League, track: Optional[Track],
                             race_result: 'RaceResult',
                             qualifying_scores: List[Tuple['Team', 'Driver', float]]) -> None:
        if not state.player_team or not state.state_db_path:
            return

        player_team_name = state.player_team.name

        try:
            import json
            from plugins import ftb_state_db

            tier_config = WorldBuilder.TIER_CONFIG.get(league.tier_name, WorldBuilder.TIER_CONFIG['grassroots'])
            points_table = tier_config['points_table']
            base_race_prize = FTBSimulation._get_base_race_prize(league)
            player_drivers = [driver.name for driver in state.player_team.drivers if driver]

            finish_positions = [
                {'driver': driver_name, 'team': team_name, 'position': pos + 1, 'status': status}
                for pos, (driver_name, team_name, status) in enumerate(race_result.final_positions)
            ]

            player_grid = None
            for i, (team, driver, _) in enumerate(qualifying_scores):
                if team.name == player_team_name:
                    player_grid = i + 1
                    break

            player_position = None
            player_prize = 0.0
            for pos, (driver_name, team_name, status) in enumerate(race_result.final_positions):
                if team_name == player_team_name:
                    player_position = pos + 1
                    prize_share = FTBSimulation._get_race_prize_share(points_table, player_position)
                    player_prize = base_race_prize * prize_share if status == 'finished' else 0
                    break

            player_incidents = [
                {'lap': event.lap_number, 'type': event.event_type, 'description': event.description}
                for event in race_result.race_events
                if any(driver.name in event.description for driver in state.player_team.drivers if driver)
                   or state.player_team.name in event.description
            ]

            champ_position = state.player_team.standing_metrics.get('championship_position')
            points_after = state.player_team.standing_metrics.get('points', 0)

            race_record = {
                'race_id': f"{league.league_id}_S{state.season_number}_R{league.races_this_season + 1}",
                'season': state.season_number,
                'round_number': league.races_this_season + 1,
                'league_id': league.league_id,
                'track_name': track.name if track else 'Unknown Circuit',
                'tick': state.tick,
                'player_team_name': player_team_name,
                'player_drivers_json': json.dumps(player_drivers),
                'finish_positions_json': json.dumps(finish_positions),
                'grid_position': player_grid,
                'prize_money': player_prize,
                'fastest_lap_holder': race_result.fastest_lap[0] if race_result.fastest_lap else None,
                'incidents_json': json.dumps(player_incidents),
                'championship_position_after': champ_position,
                'points_after': points_after
            }

            ftb_state_db.write_race_result_archive(state.state_db_path, race_record)
            
            # ═══════════════════════════════════════════════════════════════
            # PHASE 2: UPDATE HISTORICAL DATA AFTER RACE COMPLETION
            # ═══════════════════════════════════════════════════════════════
            try:
                from plugins import ftb_historical_integration
                
                # Update real-time metrics after race
                race_data = {
                    'race_id': race_record['race_id'],
                    'season': state.season_number,
                    'round_number': race_record['round_number'],
                    'track_name': race_record['track_name'],
                    'finish_positions': finish_positions,
                    'player_team': player_team_name
                }
                
                ftb_historical_integration.on_race_completed(
                    state.state_db_path, 
                    state, 
                    race_data
                )
                
                # Check for milestones (podium streaks, records, etc.)
                milestones = ftb_historical_integration.check_milestone_alerts(
                    state.state_db_path,
                    player_team_name
                )
                
                if milestones:
                    _dbg(f"[FTB] 🏆 Milestones achieved: {len(milestones)}")
                    for milestone in milestones[:3]:  # Log first 3
                        _dbg(f"[FTB]    • {milestone['type']}: {milestone['description']}")
                        
            except Exception as e:
                _dbg(f"[FTB] Warning: Could not update historical data after race: {e}")
        except Exception as e:
            _dbg(f"[FTB] Warning: Could not archive race result: {e}")

    @staticmethod
    def _process_race_results(state: SimState, league: League, track: Optional[Track], 
                              race_result: 'RaceResult', qualifying_scores: List[Tuple]) -> List[SimEvent]:
        """
        Process race results: award points, prizes, update standings.
        Extracted from simulate_race_weekend to be reusable for live race mode.
        """
        events = []
        
        # Get teams from this league
        teams_with_drivers = [t for t in league.teams if t and t.drivers]
        
        # Get tier-specific configuration
        tier_config = WorldBuilder.TIER_CONFIG.get(league.tier_name, WorldBuilder.TIER_CONFIG['grassroots'])
        points_table = tier_config['points_table']
        fastest_lap_bonus_enabled = tier_config['fastest_lap_bonus']
        base_race_prize = FTBSimulation._get_base_race_prize(league)
        
        # Track fastest lap for bonus
        fastest_lap_driver = None
        fastest_lap_team = None
        fastest_lap_position = None
        if race_result.fastest_lap:
            fastest_lap_driver = race_result.fastest_lap[0]
            for pos, (drv_name, tm_name, status) in enumerate(race_result.final_positions, 1):
                if drv_name == fastest_lap_driver and status == 'finished':
                    fastest_lap_team = tm_name
                    fastest_lap_position = pos
                    break
        
        track_name = track.name if track else "Unknown Circuit"
        track_id = track.track_id if track else None
        
        # Award points and prizes
        for position, (driver_name, team_name, status) in enumerate(race_result.final_positions, 1):
            team = next((t for t in teams_with_drivers if t.name == team_name), None)
            if not team:
                continue
            
            driver = next((d for d in team.drivers if d and d.name == driver_name), None)
            
            # Award championship points
            points = 0
            if status == 'finished' and position <= len(points_table):
                points = points_table[position - 1]
            
            # Update team championship
            if team.name not in league.championship_table:
                league.championship_table[team.name] = 0.0
            league.championship_table[team.name] += points
            team.standing_metrics['points'] = league.championship_table[team.name]
            
            # Sync to player_team if applicable
            if state.player_team and team.name == state.player_team.name:
                state.player_team.standing_metrics['points'] = league.championship_table[team.name]
            
            # Update driver championship
            if driver:
                if driver.name not in league.driver_championship:
                    league.driver_championship[driver.name] = 0.0
                league.driver_championship[driver.name] += points
            
            # Award prize money
            prize_share = FTBSimulation._get_race_prize_share(points_table, position)
            race_prize = base_race_prize * prize_share if status == 'finished' else 0
            
            if race_prize > 0:
                payout_team = team
                if state.player_team and team.name == state.player_team.name and team is not state.player_team:
                    payout_team = state.player_team
                
                payout_team.budget.cash += race_prize
                if payout_team == state.player_team:
                    state.mark_dirty('finance')
                    state.log_transaction(
                        type="income",
                        category="prize_money",
                        amount=race_prize,
                        description=f"Race prize: P{position} at {track_name}",
                        balance_after=payout_team.budget.cash,
                        metadata={'position': position, 'track': track_name, 'driver': driver_name}
                    )
            
            # Get grid position
            grid_pos = next((i+1 for i, (t, d, _) in enumerate(qualifying_scores) if t.name == team_name and d.name == driver_name), position)
            
            # Emit race result event
            events.append(SimEvent(
                event_type="outcome",
                category="race_result",
                ts=state.tick,
                priority=80.0,
                data={
                    'position': position,
                    'grid_position': grid_pos,
                    'points': points,
                    'prize_money': race_prize,
                    'team': team_name,
                    'driver': driver_name,
                    'status': status,
                    'league_id': league.league_id,
                    'league_name': league.name,
                    'tier': league.tier,
                    'round_number': league.races_this_season + 1,
                    'track_id': track_id,
                    'track_name': track_name,
                    'total_laps': len([ld for ld in race_result.laps if ld.driver_name == driver_name]),
                    'fastest_lap': race_result.telemetry.get(driver_name, {}).get('fastest_lap', None)
                }
            ))
        
        # Award fastest lap bonus
        if fastest_lap_bonus_enabled and fastest_lap_driver and fastest_lap_team and fastest_lap_position and fastest_lap_position <= 10:
            fl_team = next((t for t in teams_with_drivers if t.name == fastest_lap_team), None)
            if fl_team:
                if fl_team.name not in league.championship_table:
                    league.championship_table[fl_team.name] = 0.0
                league.championship_table[fl_team.name] += 1.0
                fl_team.standing_metrics['points'] = league.championship_table[fl_team.name]
                
                if state.player_team and fl_team.name == state.player_team.name:
                    state.player_team.standing_metrics['points'] = league.championship_table[fl_team.name]
                
                fl_driver = next((d for d in fl_team.drivers if d and d.name == fastest_lap_driver), None)
                if fl_driver:
                    if fl_driver.name not in league.driver_championship:
                        league.driver_championship[fl_driver.name] = 0.0
                    league.driver_championship[fl_driver.name] += 1.0
                    
                    events.append(SimEvent(
                        event_type="outcome",
                        category="fastest_lap_bonus",
                        ts=state.tick,
                        priority=75.0,
                        data={
                            'driver': fastest_lap_driver,
                            'team': fastest_lap_team,
                            'position': fastest_lap_position,
                            'lap_time': race_result.fastest_lap[1],
                            'bonus_points': 1,
                            'league_id': league.league_id,
                            'league_name': league.name,
                            'tier': league.tier,
                            'round_number': league.races_this_season + 1,
                            'track_name': track_name
                        }
                    ))
        
        # Increment race counter
        league.races_this_season += 1
        
        _dbg(f"[FTB] _process_race_results: League {league.name} race #{league.races_this_season} complete")
        
        return events

    @staticmethod
    def simulate_race_weekend(state: SimState, league: League, track: Optional[Track] = None) -> List[SimEvent]:
        """Pure numerical race simulation using entity stats for a specific league"""
        events = []
        rng = state.get_rng("race", context=f"league_{league.league_id}_tick_{state.tick}")
        
        # Get teams from this league only
        teams_with_drivers = [t for t in league.teams if t and t.drivers]
        
        if not teams_with_drivers:
            _dbg(f"[FTB] WARNING: No teams with drivers in {league.name}")
            return events
        
        track_name = track.name if track else "Unknown Circuit"
        _dbg(f"[FTB] RACE_SIM: {len(teams_with_drivers)} teams competing in {league.name} at {track_name}")
        
        # Get track-specific stat modifiers if track is provided
        track_modifiers = track.get_stat_modifiers() if track else {}
            
        # ============================================
        # QUALIFYING
        # ============================================
        qual_weights = QUALIFYING_WEIGHTS['default'].copy()
        
        # Apply track modifiers to qualifying weights
        if track_modifiers:
            for weight_key, modifier in track_modifiers.items():
                # Extract category and stat from weight_key (e.g., "aero_efficiency_weight")
                if weight_key.endswith('_weight'):
                    stat_name = weight_key[:-7]  # Remove "_weight" suffix
                    # Find which category this stat belongs to and apply modifier
                    for category in ['driver', 'car', 'mechanic']:
                        if stat_name in qual_weights[category]:
                            qual_weights[category][stat_name] *= modifier
        
        qualifying_scores = []
        
        for team in teams_with_drivers:
            # Qualify ALL drivers from the team (both driver slots)
            for driver in team.drivers:
                if not driver:
                    continue
                car = team.car
                mechanic = team.mechanics[0] if team.mechanics else None
                
                # Score components
                # Note: We pass the weights directly, missing keys in entity will default to 50.0 via getattr logic
                d_score = FTBSimulation.score_entity(driver, qual_weights['driver'])
                c_score = FTBSimulation.score_entity(car, qual_weights['car']) 
                m_score = FTBSimulation.score_entity(mechanic, qual_weights.get('mechanic', {}))
                
                # Compose
                parts = {'driver': d_score, 'car': c_score, 'mechanic': m_score}
                base_score = FTBSimulation.compose_phase_score(parts, qual_weights['phase_weights'])
                
                # Consistency variance (derived from driver consistency stat)
                consistency = getattr(driver, 'consistency', 50.0)
                variance_range = (100.0 - consistency) / 200.0
                variance_roll = rng.uniform(-variance_range * 10, variance_range * 10)
                
                final_score = base_score + variance_roll
                qualifying_scores.append((team, driver, final_score))
            
        qualifying_scores.sort(key=lambda x: x[2], reverse=True)
        
        # Emit Qualifying Results
        for position, (team, driver, score) in enumerate(qualifying_scores, 1):
             gap_to_pole = (qualifying_scores[0][2] - score) / 10.0
             events.append(SimEvent(
                event_type="outcome",
                category="qualifying_result",
                ts=state.tick,
                priority=70.0,
                data={
                    'position': position,
                    'team': team.name,
                    'driver': driver.name,
                    'gap_to_pole': round(gap_to_pole, 3),
                    'score': round(score, 2),
                    'league_id': league.league_id,
                    'league_name': league.name,
                    'tier': league.tier,
                    'round_number': league.races_this_season + 1,
                    'track_id': track.track_id if track else None,
                    'track_name': track.name if track else 'Unknown Circuit'
                }
            ))
            
        # ============================================
        # RACE — LAP-BY-LAP SIMULATION
        # ============================================
        
        # Apply pending grid penalties before race starts
        qualifying_scores = FTBSimulation._apply_pending_grid_penalties(state, qualifying_scores, league.tier)
        
        # Run lap-by-lap simulation
        race_result = FTBSimulation._simulate_race_lap_by_lap(
            state, league, track, qualifying_scores, rng
        )
        
        # Convert race events to SimEvents for narrator
        for race_event in race_result.race_events:
            severity = "info"
            
            # Base priority by event type
            if race_event.event_type == "overtake":
                severity = "info"
                base_priority = 65.0
            elif race_event.event_type == "mechanical_dnf":
                severity = "warning"
                base_priority = 75.0
            elif race_event.event_type == "crash":
                severity = "major"
                base_priority = 80.0
            else:
                base_priority = 70.0
            
            # BOOST priority for player team events (ensures narrator sees them immediately)
            team_involved = race_event.metadata.get('team', '')
            player_team_name = state.player_team.name if state.player_team else ''
            
            if team_involved == player_team_name:
                priority = base_priority + 15.0  # Player events jump to front of queue
                severity = "major"  # Ensure high-priority filter catches it
            else:
                priority = base_priority
            
            # Emit audio event for crashes (all crashes, not just player)
            if race_event.event_type == "crash":
                time_loss = race_event.metadata.get('time_loss', 15.0)
                crash_severity = min(1.0, time_loss / 30.0)  # 0.0-1.0 based on time lost
                events.append(SimEvent(
                    event_type="audio",
                    category="crash",
                    ts=state.tick,
                    priority=50.0,
                    data={
                        'audio_type': 'world',
                        'action': 'crash',
                        'severity': crash_severity
                    }
                ))
            
            # Build event data from race event
            event_data = {
                'lap': race_event.lap_number,
                'description': race_event.description,
                'involved_drivers': race_event.involved_drivers,
                'league_id': league.league_id,
                'league_name': league.name,
                'tier': league.tier,
                'track_id': track.track_id if track else None,
                'track_name': track.name if track else 'Unknown Circuit',
                'round_number': league.races_this_season + 1,
            }
            
            # Add metadata fields
            event_data.update(race_event.metadata)
            
            events.append(SimEvent(
                event_type="outcome",
                category=race_event.event_type,
                ts=state.tick,
                priority=priority,
                severity=severity,
                data=event_data
            ))
            
            # PENALTY SYSTEM: Investigate crashes for potential penalties
            if race_event.event_type == "crash":
                crash_penalties = FTBSimulation._investigate_crash_for_penalties(
                    state, 
                    {'race_id': race_result.race_id},
                    race_event,
                    league.tier,
                    rng
                )
                for penalty in crash_penalties:
                    state.penalties.append(penalty)
                    
                    # Create notification for player team penalties
                    if state.player_team and penalty.team_name == state.player_team.name:
                        try:
                            import plugins.ftb_notifications as ftb_notif
                            penalty_desc = f"{penalty.penalty_type.replace('_', ' ').title()}: {penalty.reason}"
                            ftb_notif.create_notification(
                                category='penalty',
                                title=f"⚠️ Penalty: {penalty.penalty_type.replace('_', ' ').title()}",
                                message=f"{penalty.team_name} received a penalty. {penalty_desc}",
                                priority=85,
                                metadata={'penalty_type': penalty.penalty_type, 'magnitude': penalty.magnitude},
                                db_path=getattr(state, 'state_db_path', None)
                            )
                        except Exception as e:
                            _dbg(f"[FTB] Failed to create penalty notification: {e}")
                    
                    # Emit penalty event for narrator
                    events.append(SimEvent(
                        event_type="outcome",
                        category="penalty",
                        ts=state.tick,
                        priority=85.0,
                        severity="major" if penalty.penalty_type in ["grid_penalty", "points_deduction"] else "warning",
                        data={
                            'penalty_type': penalty.penalty_type,
                            'team': penalty.team_name,
                            'driver': getattr(penalty, 'driver_name', ''),
                            'magnitude': penalty.magnitude,
                            'reason': penalty.reason,
                            'league_id': league.league_id,
                            'tier': league.tier
                        }
                    ))
        
        # PENALTY SYSTEM: Process track limits violations after race
        track_limits_penalties = FTBSimulation._process_track_limits_violations(
            state,
            {'race_id': race_result.race_id},
            race_result,
            league.tier,
            rng
        )
        for penalty in track_limits_penalties:
            state.penalties.append(penalty)
            
            # Create notification for player team track limits penalties
            if state.player_team and penalty.team_name == state.player_team.name:
                try:
                    import plugins.ftb_notifications as ftb_notif
                    ftb_notif.create_notification(
                        category='penalty',
                        title=f"⚠️ Track Limits Violation",
                        message=f"{penalty.team_name}: {penalty.reason}",
                        priority=75,
                        metadata={'penalty_type': penalty.penalty_type, 'magnitude': penalty.magnitude},
                        db_path=getattr(state, 'state_db_path', None)
                    )
                except Exception as e:
                    _dbg(f"[FTB] Failed to create track limits notification: {e}")
            
            # Emit penalty event
            events.append(SimEvent(
                event_type="outcome",
                category="penalty",
                ts=state.tick,
                priority=75.0,
                severity="warning",
                data={
                    'penalty_type': penalty.penalty_type,
                    'team': penalty.team_name,
                    'driver': getattr(penalty, 'driver_name', ''),
                    'magnitude': penalty.magnitude,
                    'reason': penalty.reason,
                    'league_id': league.league_id,
                    'tier': league.tier
                }
            ))
        
        # Process race results and award points/prizes
        # Get tier-specific points table and fastest lap bonus config
        tier_config = WorldBuilder.TIER_CONFIG.get(league.tier_name, WorldBuilder.TIER_CONFIG['grassroots'])
        points_table = tier_config['points_table']
        fastest_lap_bonus_enabled = tier_config['fastest_lap_bonus']
        
        base_race_prize = FTBSimulation._get_base_race_prize(league)
        
        # Track fastest lap driver's position for bonus point
        fastest_lap_driver = None
        fastest_lap_team = None
        fastest_lap_position = None
        if race_result.fastest_lap:
            fastest_lap_driver = race_result.fastest_lap[0]
            # Find team and position for fastest lap holder
            for pos, (drv_name, tm_name, status) in enumerate(race_result.final_positions, 1):
                if drv_name == fastest_lap_driver and status == 'finished':
                    fastest_lap_team = tm_name
                    fastest_lap_position = pos
                    break
        
        # Calculate hype from this race (deviation from expected results)
        hype_delta = FTBSimulation._calculate_race_hype(league, race_result, qualifying_scores)
        if hype_delta > 0:
            league.hype = min(3.0, league.hype + hype_delta)  # Cap at 3x
            league.hype_events_this_season += 1
            _dbg(f"[FTB] HYPE: {league.name} gained +{hype_delta:.3f} hype (now {league.hype:.2f}x) - exciting race!")
        
        # Award points and prizes based on final positions
        points_awarded_count = 0
        loop_iterations = 0
        _dbg(f"[FTB] POINTS_DEBUG: Processing {len(race_result.final_positions)} positions, points_table={points_table[:5]}... (first 5)")
        if len(race_result.final_positions) > 0:
            _dbg(f"[FTB] POINTS_DEBUG: Sample position data - P1: {race_result.final_positions[0]}")
        for position, (driver_name, team_name, status) in enumerate(race_result.final_positions, 1):
            loop_iterations += 1
            # Find team and driver objects
            team = next((t for t in teams_with_drivers if t.name == team_name), None)
            if not team:
                _dbg(f"[FTB] ERROR: Team '{team_name}' (P{position}, {driver_name}) not found in league.teams with drivers - skipping points/events!")
                continue
            
            # Safely iterate through all drivers (team may have fewer than 2)
            driver = next((d for d in team.drivers if d and d.name == driver_name), None)
            
            # Award points if finished
            points = 0
            if status == 'finished' and position <= len(points_table):
                points = points_table[position - 1]
                _dbg(f"[FTB] POINTS_DEBUG: P{position} {driver_name} status='{status}' pos<={len(points_table)} → {points} pts")
            else:
                _dbg(f"[FTB] POINTS_DEBUG: P{position} {driver_name} status='{status}' pos>{len(points_table)}? {position > len(points_table)} → 0 pts (FAILED)")
            
            # Update championship table (always, whether points > 0 or not)
            if team.name not in league.championship_table:
                league.championship_table[team.name] = 0.0
            league.championship_table[team.name] += points
            # Sync team.standing_metrics for database exports and sponsor evaluations
            team.standing_metrics['points'] = league.championship_table[team.name]
            
            # Sync to player_team if this is the player's team
            is_player = state.player_team and team.name == state.player_team.name
            if is_player:
                state.player_team.standing_metrics['points'] = league.championship_table[team.name]
                _dbg(f"[FTB] PLAYER_FINISH: P{position} {driver_name} = {points} pts (Total: {league.championship_table[team.name]:.0f} pts)")
            
            # Log all point-scoring finishes
            if points > 0:
                points_awarded_count += 1
                _dbg(f"[FTB] POINTS_AWARDED: P{position}={driver_name} ({team_name}) {points} pts")
            
            # Award driver championship points
            if driver:
                if driver.name not in league.driver_championship:
                    league.driver_championship[driver.name] = 0.0
                league.driver_championship[driver.name] += points
            
            # Calculate prize money (pool distributed by points table share)
            prize_share = FTBSimulation._get_race_prize_share(points_table, position)
            race_prize = base_race_prize * prize_share if status == 'finished' else 0
            track_name = track.name if track else "Unknown Circuit"
            track_id = track.track_id if track else None
            
            # Award race prize money to team
            if race_prize > 0:
                payout_team = team
                if state.player_team and team.name == state.player_team.name and team is not state.player_team:
                    payout_team = state.player_team

                payout_team.budget.cash += race_prize
                if payout_team == state.player_team:
                    state.mark_dirty('finance')
                
                # Log prize money transaction (only for player team)
                if payout_team == state.player_team:
                    state.log_transaction(
                        type="income",
                        category="prize_money",
                        amount=race_prize,
                        description=f"Race prize: P{position} at {track_name}",
                        balance_after=payout_team.budget.cash,
                        metadata={'position': position, 'track': track_name, 'driver': driver_name}
                    )
            
            # Get grid position from qualifying
            grid_pos = next((i+1 for i, (t, d, _) in enumerate(qualifying_scores) if t.name == team_name and d.name == driver_name), position)
            
            # Emit race result event for each finisher
            events.append(SimEvent(
                event_type="outcome",
                category="race_result",
                ts=state.tick,
                priority=80.0,
                data={
                    'position': position,
                    'grid_position': grid_pos,
                    'points': points,
                    'prize_money': race_prize,
                    'team': team_name,
                    'driver': driver_name,
                    'status': status,
                    'league_id': league.league_id,
                    'league_name': league.name,
                    'tier': league.tier,
                    'round_number': league.races_this_season + 1,
                    'track_id': track_id,
                    'track_name': track_name,
                    'total_laps': len([ld for ld in race_result.laps if ld.driver_name == driver_name]),
                    'fastest_lap': race_result.telemetry.get(driver_name, {}).get('fastest_lap', None)
                }
            ))
        
        # Log points summary
        _dbg(f"[FTB] POINTS_SUMMARY: {points_awarded_count} positions scored points (table size: {len(points_table)}, loop ran {loop_iterations} times)")
        
        # Award fastest lap bonus point (if enabled and driver finished in top 10)
        if fastest_lap_bonus_enabled and fastest_lap_driver and fastest_lap_team and fastest_lap_position and fastest_lap_position <= 10:
            # Find team object for fastest lap holder
            fl_team = next((t for t in teams_with_drivers if t.name == fastest_lap_team), None)
            if fl_team:
                # Award +1 point to team championship
                if fl_team.name not in league.championship_table:
                    league.championship_table[fl_team.name] = 0.0
                league.championship_table[fl_team.name] += 1.0
                fl_team.standing_metrics['points'] = league.championship_table[fl_team.name]
                
                # Sync to player_team if applicable
                if state.player_team and fl_team.name == state.player_team.name:
                    state.player_team.standing_metrics['points'] = league.championship_table[fl_team.name]
                
                # Award +1 point to driver championship
                fl_driver = next((d for d in fl_team.drivers if d and d.name == fastest_lap_driver), None)
                if fl_driver:
                    if fl_driver.name not in league.driver_championship:
                        league.driver_championship[fl_driver.name] = 0.0
                    league.driver_championship[fl_driver.name] += 1.0
                    
                    _dbg(f"[FTB] FASTEST_LAP_BONUS: {fastest_lap_driver} ({fastest_lap_team}) P{fastest_lap_position} +1 pt (lap: {race_result.fastest_lap[1]:.3f}s)")
                    
                    # Emit fastest lap bonus event for narrator
                    events.append(SimEvent(
                        event_type="outcome",
                        category="fastest_lap_bonus",
                        ts=state.tick,
                        priority=75.0,
                        data={
                            'driver': fastest_lap_driver,
                            'team': fastest_lap_team,
                            'position': fastest_lap_position,
                            'lap_time': race_result.fastest_lap[1],
                            'bonus_points': 1,
                            'league_id': league.league_id,
                            'league_name': league.name,
                            'tier': league.tier,
                            'round_number': league.races_this_season + 1,
                            'track_name': track.name if track else 'Unknown Circuit'
                        }
                    ))
        
        # PENALTY IMPACT: Apply financial and championship penalties
        penalties_to_apply = [p for p in state.penalties 
                             if not getattr(p, 'applied', False) 
                             and p.penalty_type in ['fine', 'points_deduction']]
        
        for penalty in penalties_to_apply:
            # Find team
            team = next((t for t in teams_with_drivers if t.name == penalty.team_name), None)
            if not team:
                continue
            
            if penalty.penalty_type == 'fine':
                # Deduct fine from team budget
                fine_amount = penalty.magnitude
                team.budget.cash -= fine_amount
                penalty.applied = True
                
                # Log transaction for player team
                if team == state.player_team:
                    state.log_transaction(
                        type="expense",
                        category="penalty",
                        amount=fine_amount,
                        description=f"Penalty fine: {penalty.reason}",
                        balance_after=team.budget.cash,
                        metadata={'penalty_type': penalty.penalty_type, 'driver': penalty.driver_name}
                    )
                
                events.append(SimEvent(
                    event_type="outcome",
                    category="financial",
                    ts=state.tick,
                    priority=70.0,
                    severity="warning",
                    data={
                        'team': penalty.team_name,
                        'amount': -fine_amount,
                        'reason': f"Penalty fine: {penalty.reason}",
                        'new_balance': team.budget.cash
                    }
                ))
                
                _dbg(f"[FTB] PENALTY_FINE: {penalty.team_name} fined ${fine_amount:,} - {penalty.reason}")
            
            elif penalty.penalty_type == 'points_deduction':
                # Deduct championship points
                if team.name in league.championship_table:
                    points_before = league.championship_table[team.name]
                    league.championship_table[team.name] = max(0, points_before - penalty.magnitude)
                    points_after = league.championship_table[team.name]
                    penalty.applied = True
                    
                    events.append(SimEvent(
                        event_type="outcome",
                        category="penalty",
                        ts=state.tick,
                        priority=90.0,
                        severity="major",
                        data={
                            'team': penalty.team_name,
                            'points_deducted': penalty.magnitude,
                            'points_before': points_before,
                            'points_after': points_after,
                            'reason': penalty.reason
                        }
                    ))
                    
                    _dbg(f"[FTB] PENALTY_POINTS: {penalty.team_name} lost {penalty.magnitude} pts ({points_before:.0f} → {points_after:.0f}) - {penalty.reason}")
        
        # Increment race counter for this league
        league.races_this_season += 1
        state.races_completed_this_season += 1
        
        # Log race completion
        winner_name = race_result.final_positions[0][0] if race_result.final_positions else "Unknown"
        winner_points = points_table[0] if race_result.final_positions else 0
        _dbg(f"[FTB] RACE_COMPLETE: {race_result.track_name}, Winner={winner_name} ({winner_points} pts), {len(race_result.laps)} lap records, {len(race_result.race_events)} events")
        
        # Update manager career stats (if player team participated)
        if state.player_team and state.manager_career_stats:
            player_team_name = state.player_team.name
            player_participated = any(team_name == player_team_name for _, team_name, _ in race_result.final_positions)
            
            if player_participated:
                state.manager_career_stats.total_races += 1
                
                # Check for wins and podiums
                for position, (driver_name, team_name, status) in enumerate(race_result.final_positions, 1):
                    if team_name == player_team_name and status == 'finished':
                        if position == 1:
                            state.manager_career_stats.wins += 1
                        if position <= 3:
                            state.manager_career_stats.podiums += 1
                        break
                
                # Check for pole position (from qualifying)
                if qualifying_scores and qualifying_scores[0][0] == state.player_team:
                    state.manager_career_stats.poles += 1
                
                # Mark manager career as dirty to trigger UI refresh
                state.mark_dirty('manager_career')
        
        # Apply part degradation to all participating teams (Phase 2.4)
        track_intensity = 1.0
        if track:
            # High-speed tracks and street circuits are more demanding
            if 'street' in track.track_type.lower() or 'high_speed' in track.characteristics:
                track_intensity = 1.3
            elif 'technical' in track.characteristics:
                track_intensity = 1.1
        
        for team in teams_with_drivers:
            for part in team.equipped_parts.values():
                part.apply_race_degradation(race_intensity=track_intensity)
        
        # Update play-by-play widget with race data
        try:
            if not state.race_day_active:
                import ftb_pbp
                if getattr(state, '_live_pbp_mode', False):
                    interval = getattr(state, '_live_pbp_interval', None)
                    ftb_pbp.start_live_feed(race_result, state, interval_sec=interval or 1.5)
                else:
                    ftb_pbp.update_race_data(race_result, state)
        except Exception as e:
            # Silently fail if widget not loaded
            pass
        finally:
            state._live_pbp_mode = False
            state._live_pbp_interval = None
            state._last_race_result = race_result
            state._last_race_context = {
                'league_id': league.league_id,
                'track_id': track.track_id if track else None,
                'qualifying_scores': qualifying_scores
            }
            state._last_race_results[league.league_id] = race_result
            state._last_race_contexts[league.league_id] = {
                'league_id': league.league_id,
                'track_id': track.track_id if track else None,
                'qualifying_scores': qualifying_scores
            }
        
        # Archive race result to history database (only for player team participation)
        if not state.race_day_active:
            FTBSimulation._archive_race_result(state, league, track, race_result, qualifying_scores)
            
        # Apply performance-based morale changes (mettle system)
        morale_events = FTBSimulation._apply_performance_morale_changes(state, league, race_result, qualifying_scores)
        events.extend(morale_events)
        
        # Apply mettle growth/decay based on season performance
        mettle_events = FTBSimulation._apply_mettle_adjustment(state, league, race_result, qualifying_scores)
        events.extend(mettle_events)
        
        return events
    
    @staticmethod
    def _apply_mettle_adjustment(state: SimState, league: League, race_result: 'RaceResult',
                                 qualifying_scores: List[Tuple['Team', 'Driver', float]]) -> List[SimEvent]:
        """
        Adjust mettle stat for entities based on how they handle adversity.
        Mettle grows slowly when overcoming challenges, decays slowly from persistent failure.
        
        Growth triggers:
        - Finishing better than expected despite setbacks
        - Recovering from DNFs or poor performance earlier in season
        - Consecutive improvements
        
        Decay triggers:
        - Persistent underperformance (3+ races below expected)
        - Giving up (finishing far below potential repeatedly)
        
        Max change: +1.0 per season (growth), -0.5 per season (decay)
        """
        events = []
        
        # Track performance history per entity (would ideally be in state, but using event history for now)
        # Get last 3 race results for each driver to detect trends
        
        for position, (driver_name, team_name, status) in enumerate(race_result.final_positions, 1):
            # Find team and driver objects
            team = next((t for t in league.teams if t.name == team_name), None)
            if not team:
                continue
            
            driver = next((d for d in team.drivers if d and d.name == driver_name), None)
            if not driver or not hasattr(driver, 'mettle'):
                continue
            
            # Get expected position from qualifying
            expected_pos = next((idx + 1 for idx, (t, d, _) in enumerate(qualifying_scores) if t.name == team_name), position)
            
            # Get recent performance trend (last 3 races)
            recent_races = [e for e in state.event_history[-100:] 
                           if e.category == "race_result" 
                           and e.data.get('driver') == driver_name
                           and e.data.get('league_id') == league.league_id][-3:]
            
            mettle_change = 0.0
            reason = ""
            
            if status == 'finished':
                position_delta = expected_pos - position  # Positive = better than expected
                
                # Check for improvement trend
                if len(recent_races) >= 2:
                    positions = [e.data.get('position', 99) for e in recent_races]
                    improving = all(positions[i] >= positions[i+1] for i in range(len(positions)-1))
                    declining = all(positions[i] <= positions[i+1] for i in range(len(positions)-1))
                    
                    if improving and position_delta > 0:
                        # Overcoming adversity - gaining resilience
                        mettle_change = min(0.3, position_delta * 0.1)
                        reason = "Showing improvement under pressure"
                    elif declining and position_delta < -2:
                        # Losing resolve from persistent poor performance
                        mettle_change = max(-0.2, position_delta * 0.05)
                        reason = "Struggling to maintain composure"
                    elif position_delta > 3:
                        # Single great result shows mental strength
                        mettle_change = min(0.2, position_delta * 0.05)
                        reason = "Rose to the challenge"
                    elif len(recent_races) >= 3 and all(e.data.get('position', 99) > expected_pos + 2 for e in recent_races):
                        # Persistent underperformance
                        mettle_change = -0.15
                        reason = "Rattled by consecutive poor results"
            else:
                # DNF - check if recovering from previous DNFs or getting demoralized
                recent_dnfs = sum(1 for e in recent_races if e.data.get('status') != 'finished')
                
                if recent_dnfs >= 2:
                    # Multiple DNFs - losing mental edge
                    mettle_change = -0.2
                    reason = "Repeated setbacks taking toll"
            
            # Apply mettle change (clamped to 0-100 range)
            if abs(mettle_change) >= 0.05:  # Minimum threshold
                old_mettle = driver.mettle
                driver.mettle = max(0.0, min(100.0, driver.mettle + mettle_change))
                
                events.append(SimEvent(
                    event_type="stat_change",
                    category="mettle_adjustment",
                    ts=state.tick,
                    priority=40.0,
                    severity="info",
                    data={
                        'entity': driver_name,
                        'team': team_name,
                        'stat': 'mettle',
                        'old_value': old_mettle,
                        'new_value': driver.mettle,
                        'change': mettle_change,
                        'reason': reason
                    }
                ))
        
        return events
    
    @staticmethod
    def _simulate_race_lap_by_lap(state: SimState, league: League, track: Optional[Track], 
                                    qualifying_scores: List[Tuple[Team, Driver, float]], 
                                    rng: random.Random) -> RaceResult:
        """
        Simulate race lap-by-lap with cumulative timing, dirty-air/traffic
        effects, and realistic overtake thresholds.
        Returns RaceResult with complete lap data and race events.
        """
        # Initialize race result
        race_id = f"{league.league_id}_r{league.races_this_season + 1}_t{state.tick}"
        result = RaceResult(
            race_id=race_id,
            league_id=league.league_id,
            league_name=league.name,
            track_id=track.track_id if track else "unknown",
            track_name=track.name if track else "Unknown Circuit",
            season=state.season_number,
            round_number=league.races_this_season + 1
        )
        
        # Get lap count from track
        total_laps = track.lap_count if track else 50
        
        # Calculate base pace for each driver (similar to old system)
        race_weights = RACE_WEIGHTS['default']
        driver_paces = []  # List of dicts with driver data
        
        for grid_pos, (team, driver, qual_score) in enumerate(qualifying_scores, 1):
            car = team.car
            
            # Base pace calculation
            d_score = FTBSimulation.score_entity(driver, race_weights['driver'])
            c_score = FTBSimulation.score_entity(car, race_weights['car'])
            combined_pace = FTBSimulation.compose_phase_score(
                {'driver': d_score, 'car': c_score}, 
                race_weights['phase_weights']
            )
            
            # Convert pace score to lap time (higher score = faster = lower time)
            # Base lap time around 80-120 seconds, scaled by pace
            base_lap_time = 100.0 - (combined_pace - 50.0) * 0.3
            
            # Get driver characteristics
            consistency = getattr(driver, 'consistency', 50.0)
            racecraft = getattr(driver, 'racecraft', 50.0)
            overtaking = getattr(driver, 'overtaking_skill', 50.0)
            aggression = getattr(driver, 'aggression', 50.0)
            discipline = getattr(driver, 'discipline', 50.0)
            mistake_rate = getattr(driver, 'mistake_rate', 50.0)
            
            # Car reliability
            reliability = getattr(car, 'reliability', 50.0)
            
            driver_paces.append({
                'team': team,
                'driver': driver,
                'base_lap_time': base_lap_time,
                'consistency': consistency,
                'racecraft': (racecraft + overtaking) / 2.0,
                'aggression': aggression,
                'discipline': discipline,
                'mistake_rate': mistake_rate,
                'reliability': reliability,
                'dnf': False,
                'tire_age': 0,
                'tire_compound': 'medium',
                'cumulative_time': 0.0,  # Track total race time
                'dnf_lap': 0,
            })
        
        # Current race order (starts in qualifying order)
        # current_order[i] = index into driver_paces for position i+1
        current_order = list(range(len(driver_paces)))
        
        # ---- Dirty-air / traffic parameters ----
        # Cars within this gap (seconds) to car ahead get a dirty-air lap-time penalty
        DIRTY_AIR_THRESHOLD = 1.5   # seconds of gap to car ahead
        DIRTY_AIR_PENALTY   = 0.15  # seconds lost per lap when stuck in traffic
        # Overtake requires the attacking driver to be THIS much faster *after*
        # traffic penalty is applied. Combines with racecraft to lower threshold.
        BASE_OVERTAKE_DELTA = 0.35  # seconds faster needed to attempt a pass
        
        # Simulate each lap
        for lap_num in range(1, total_laps + 1):
            lap_times = {}  # idx -> lap_time this lap
            
            # Build a quick position-lookup: driver_idx -> current_position (1-based)
            pos_of = {}
            for pos_idx, drv_idx in enumerate(current_order):
                pos_of[drv_idx] = pos_idx + 1
            
            # ---- Phase 1: Calculate raw lap times ----
            for idx, driver_data in enumerate(driver_paces):
                if driver_data['dnf']:
                    lap_times[idx] = float('inf')
                    continue
                
                # Base lap time
                lap_time = driver_data['base_lap_time']
                
                # Add consistency variance (smaller range, more realistic)
                variance = (100.0 - driver_data['consistency']) / 150.0
                lap_time += rng.gauss(0, variance)
                
                # Tire degradation (non-linear: small early, larger later)
                tire_age = driver_data['tire_age']
                tire_deg = tire_age * 0.015 + (tire_age ** 2) * 0.0003
                lap_time += tire_deg
                
                # ---- Dirty-air / traffic penalty ----
                my_pos = pos_of[idx]
                if my_pos > 1:
                    # Find the car directly ahead
                    ahead_idx = current_order[my_pos - 2]  # 0-based
                    if not driver_paces[ahead_idx]['dnf']:
                        gap_to_ahead = driver_data['cumulative_time'] - driver_paces[ahead_idx]['cumulative_time']
                        if gap_to_ahead < DIRTY_AIR_THRESHOLD:
                            # Lose time in dirty air; high racecraft mitigates
                            craft_factor = 1.0 - (driver_data['racecraft'] / 200.0)  # 0.75-1.0
                            lap_time += DIRTY_AIR_PENALTY * craft_factor
                
                # Random incidents (mechanical DNF)
                dnf_chance = (100.0 - driver_data['reliability']) / 60000.0
                if rng.random() < dnf_chance:
                    driver_data['dnf'] = True
                    driver_data['dnf_lap'] = lap_num
                    
                    result.race_events.append(RaceEventRecord(
                        lap_number=lap_num,
                        event_type="mechanical_dnf",
                        involved_drivers=[driver_data['driver'].name],
                        description=f"{driver_data['driver'].name} retires with mechanical failure",
                        metadata={'team': driver_data['team'].name}
                    ))
                    
                    lap_times[idx] = float('inf')
                    continue
                
                # Random crash/mistake (slightly rarer)
                incident_chance = (driver_data['mistake_rate'] + driver_data['aggression'] * 0.5 - driver_data['discipline']) / 700.0
                if rng.random() < incident_chance:
                    time_loss = rng.uniform(10.0, 30.0)
                    lap_time += time_loss
                    
                    result.race_events.append(RaceEventRecord(
                        lap_number=lap_num,
                        event_type="crash",
                        involved_drivers=[driver_data['driver'].name],
                        description=f"{driver_data['driver'].name} crashes and loses {time_loss:.1f} seconds",
                        metadata={'team': driver_data['team'].name, 'time_loss': time_loss}
                    ))
                
                # Increment tire age
                driver_data['tire_age'] += 1
                
                lap_times[idx] = lap_time
            
            # ---- Phase 2: Update cumulative times ----
            for idx, driver_data in enumerate(driver_paces):
                if not driver_data['dnf']:
                    driver_data['cumulative_time'] += lap_times[idx]
            
            # ---- Phase 3: Determine new positions by cumulative time ----
            # Build list of (driver_idx, cumulative_time) for non-DNF drivers
            active_drivers = [
                (idx, driver_paces[idx]['cumulative_time'])
                for idx in range(len(driver_paces))
                if not driver_paces[idx]['dnf']
            ]
            active_drivers.sort(key=lambda x: x[1])
            
            # ---- Phase 4: Apply overtake gating ----
            # Start from current order, only allow a position swap if the
            # faster driver has enough delta AND passes a racecraft check.
            # This prevents chaotic shuffles each lap.
            new_order_active = [x[0] for x in active_drivers]  # order by raw cumulative
            
            # Build the gated order starting from the old order
            # Keep DNFs out; they go to the back
            old_active = [idx for idx in current_order if not driver_paces[idx]['dnf']]
            gated_order = list(old_active)  # start from last lap's order
            
            # Walk through every pair and see if cumulative time says someone
            # behind should be ahead.  Only allow the swap if delta is big enough.
            changed = True
            passes_done = 0
            max_passes = 3  # limit bubble-sort passes per lap to keep it calm
            while changed and passes_done < max_passes:
                changed = False
                passes_done += 1
                for i in range(len(gated_order) - 1):
                    ahead_idx = gated_order[i]
                    behind_idx = gated_order[i + 1]
                    
                    time_ahead = driver_paces[ahead_idx]['cumulative_time']
                    time_behind = driver_paces[behind_idx]['cumulative_time']
                    
                    # behind_idx is actually faster (lower cumulative) than ahead_idx?
                    if time_behind < time_ahead:
                        delta = time_ahead - time_behind
                        
                        # Overtake threshold: base delta scaled by attacker's racecraft
                        craft_bonus = (driver_paces[behind_idx]['racecraft'] - 50.0) / 200.0
                        required_delta = max(0.10, BASE_OVERTAKE_DELTA - craft_bonus)
                        
                        if delta >= required_delta:
                            # Overtake succeeds
                            gated_order[i], gated_order[i + 1] = gated_order[i + 1], gated_order[i]
                            changed = True
                            
                            # Record overtake event
                            new_pos = i + 1  # 1-based position after swap
                            old_pos = i + 2
                            result.race_events.append(RaceEventRecord(
                                lap_number=lap_num,
                                event_type="overtake",
                                involved_drivers=[driver_paces[behind_idx]['driver'].name],
                                description=f"{driver_paces[behind_idx]['driver'].name} overtakes {driver_paces[ahead_idx]['driver'].name} for P{new_pos}",
                                position_change={driver_paces[behind_idx]['driver'].name: new_pos},
                                metadata={
                                    'positions_gained': 1,
                                    'delta': round(delta, 3),
                                    'passed_driver': driver_paces[ahead_idx]['driver'].name
                                }
                            ))
            
            # Append DNF drivers at the end (preserving their last order)
            dnf_drivers = [idx for idx in current_order if driver_paces[idx]['dnf']]
            current_order = gated_order + dnf_drivers
            
            # ---- Phase 5: Record lap data ----
            leader_cumulative = driver_paces[gated_order[0]]['cumulative_time'] if gated_order else 0.0
            for position, driver_idx in enumerate(gated_order, 1):
                lap_time_val = lap_times.get(driver_idx, 0.0)
                cum_gap = driver_paces[driver_idx]['cumulative_time'] - leader_cumulative if position > 1 else 0.0
                
                # Gap to car ahead
                gap_ahead = 0.0
                if position > 1:
                    ahead_cum = driver_paces[gated_order[position - 2]]['cumulative_time']
                    gap_ahead = driver_paces[driver_idx]['cumulative_time'] - ahead_cum
                
                # Simplified sector times (divide lap into thirds)
                sector_1 = lap_time_val / 3.0 + rng.uniform(-0.1, 0.1)
                sector_2 = lap_time_val / 3.0 + rng.uniform(-0.1, 0.1)
                sector_3 = lap_time_val - sector_1 - sector_2
                
                lap_data = LapData(
                    lap_number=lap_num,
                    driver_name=driver_paces[driver_idx]['driver'].name,
                    team_name=driver_paces[driver_idx]['team'].name,
                    lap_time=lap_time_val,
                    position=position,
                    tire_compound=driver_paces[driver_idx]['tire_compound'],
                    tire_age=driver_paces[driver_idx]['tire_age'],
                    gap_to_leader=cum_gap,
                    gap_to_ahead=gap_ahead,
                    sector_1=sector_1,
                    sector_2=sector_2,
                    sector_3=sector_3
                )
                result.laps.append(lap_data)
        
        # Final classification - finishers first (by cumulative time), then DNFs
        final_active = [(idx, driver_paces[idx]['cumulative_time'])
                        for idx in range(len(driver_paces)) if not driver_paces[idx]['dnf']]
        final_active.sort(key=lambda x: x[1])
        
        for driver_idx, _ in final_active:
            result.final_positions.append((
                driver_paces[driver_idx]['driver'].name,
                driver_paces[driver_idx]['team'].name,
                'finished'
            ))
        
        # Add DNF drivers at the end (sorted by lap they retired, latest first)
        dnf_list = [(idx, driver_paces[idx]['dnf_lap'])
                    for idx in range(len(driver_paces)) if driver_paces[idx]['dnf']]
        dnf_list.sort(key=lambda x: x[1], reverse=True)
        
        for driver_idx, _ in dnf_list:
            result.final_positions.append((
                driver_paces[driver_idx]['driver'].name,
                driver_paces[driver_idx]['team'].name,
                'dnf'
            ))
        
        # Calculate fastest lap
        if result.laps:
            fastest = min(result.laps, key=lambda l: l.lap_time)
            result.fastest_lap = (fastest.driver_name, fastest.lap_time)
        
        # Derive basic telemetry
        for driver_idx, driver_data in enumerate(driver_paces):
            driver_name = driver_data['driver'].name
            driver_laps = [l for l in result.laps if l.driver_name == driver_name]
            
            if driver_laps:
                lap_times_list = [l.lap_time for l in driver_laps]
                avg_lap = sum(lap_times_list) / len(lap_times_list)
                std_lap = (sum((t - avg_lap)**2 for t in lap_times_list) / len(lap_times_list)) ** 0.5
                
                result.telemetry[driver_name] = {
                    'avg_lap_time': avg_lap,
                    'lap_time_std_dev': std_lap,
                    'consistency_rating': 100.0 - (std_lap * 20.0),  # Lower std dev = higher consistency
                    'fastest_lap': min(lap_times_list),
                    'tire_management': 100.0 - (driver_data['tire_age'] * 0.5)  # Simplified
                }
        
        _dbg(f"[FTB] LAP_SIM: Completed {total_laps} laps, {len(result.race_events)} events, {len(result.final_positions)} finishers")
        
        return result
    
    @staticmethod
    def _investigate_crash_for_penalties(state: SimState, race: Dict[str, Any], crash_event: 'RaceEventRecord', 
                                         tier: int, rng: random.Random) -> List['Penalty']:
        """
        Investigate crash incident and determine if penalties should be issued.
        Uses tier-based strictness from PENALTY_CONFIG.
        
        Returns list of Penalty objects to add to state.penalties
        """
        penalties = []
        
        # Get tier configuration
        tier_config = PENALTY_CONFIG.get(tier, PENALTY_CONFIG[1])
        
        # Check if crash should be investigated
        if rng.random() > tier_config['crash_investigation_rate']:
            return penalties  # No investigation
        
        # Get involved driver and team
        driver_name = crash_event.involved_drivers[0] if crash_event.involved_drivers else "Unknown"
        team_name = crash_event.metadata.get('team', 'Unknown')
        
        # Find driver entity to check stats
        driver = None
        for t in state.ai_teams + ([state.player_team] if state.player_team else []):
            if t.name == team_name:
                for d in t.drivers:
                    if d.name == driver_name:
                        driver = d
                        break
                break
        
        if not driver:
            return penalties  # Can't assess without driver data
        
        # Calculate fault score based on driver characteristics
        aggression = getattr(driver, 'aggression', 50.0)
        discipline = getattr(driver, 'discipline', 50.0)
        composure = getattr(driver, 'composure', 50.0)
        
        # Higher aggression + lower discipline/composure = more likely at fault
        fault_score = (aggression / 100.0) * 0.5 + ((100.0 - discipline) / 100.0) * 0.3 + ((100.0 - composure) / 100.0) * 0.2
        
        # Check if driver is at fault (threshold varies by tier)
        fault_thresholds = {1: 0.70, 2: 0.60, 3: 0.55, 4: 0.50, 5: 0.45}
        fault_threshold = fault_thresholds.get(tier, 0.55)
        
        if fault_score < fault_threshold:
            return penalties  # Racing incident, no penalty
        
        # Check recent penalty history for repeat offenders (exclude current race)
        current_race_id = race.get('race_id', 0)
        recent_penalties = [p for p in state.penalties 
                           if p.team_name == team_name and 
                           p.race_id != current_race_id and 
                           getattr(state, 'current_day', 0) - getattr(p, 'game_day', 0) < 90]
        repeat_offender = len(recent_penalties) >= 2
        
        # Decide penalty type based on tier and history
        if tier <= 2:  # Lower tiers favor warnings
            if rng.random() < tier_config['warning_before_penalty_rate'] and not repeat_offender:
                penalty_type = "warning"
                magnitude = 1
                reason = f"Causing collision on lap {crash_event.lap_number} - Official Warning"
            else:
                penalty_type = "fine"
                magnitude = int(tier_config['base_fine_amounts']['causing_collision'] * tier_config['fine_multiplier'])
                reason = f"Causing collision on lap {crash_event.lap_number}"
        elif tier == 3:  # Balanced: warnings or grid penalties
            if rng.random() < tier_config['warning_before_penalty_rate'] and not repeat_offender:
                penalty_type = "warning"
                magnitude = 1
                reason = f"Causing collision on lap {crash_event.lap_number} - Official Warning"
            else:
                penalty_type = "grid_penalty"
                magnitude = rng.randint(*tier_config['grid_penalty_range'])
                reason = f"Causing collision on lap {crash_event.lap_number} - {magnitude}-place grid penalty for next race"
        else:  # Tier 4-5: Strict, grid penalties and fines
            if repeat_offender:
                # Harsh penalty for repeat offenders
                penalty_type = "grid_penalty"
                magnitude = rng.randint(tier_config['grid_penalty_range'][1] - 3, tier_config['grid_penalty_range'][1])
                reason = f"Causing collision on lap {crash_event.lap_number} - repeat offender - {magnitude}-place grid penalty"
                
                # Also add fine
                fine = Penalty(
                    race_id=race.get('race_id', 0),
                    team_name=team_name,
                    driver_name=driver_name,
                    penalty_type="fine",
                    magnitude=int(tier_config['base_fine_amounts']['causing_collision'] * tier_config['fine_multiplier'] * 1.5),
                    reason=f"Dangerous driving - repeat offense",
                    issued_by="Stewards",
                    appealable=False,
                    game_day=getattr(state, 'current_day', 0)
                )
                penalties.append(fine)
            else:
                penalty_type = "grid_penalty"
                magnitude = rng.randint(*tier_config['grid_penalty_range'])
                reason = f"Causing collision on lap {crash_event.lap_number} - {magnitude}-place grid penalty for next race"
        
        # Create penalty
        penalty = Penalty(
            race_id=race.get('race_id', 0),
            team_name=team_name,
            driver_name=driver_name,
            penalty_type=penalty_type,
            magnitude=magnitude,
            reason=reason,
            issued_by="Stewards",
            appealable=(tier >= 4),  # Only higher tiers can appeal
            game_day=getattr(state, 'current_day', 0)
        )
        penalties.append(penalty)
        
        return penalties
    
    @staticmethod
    def _process_track_limits_violations(state: SimState, race: Dict[str, Any], result: 'RaceResult', 
                                         tier: int, rng: random.Random) -> List['Penalty']:
        """
        Analyze race for track limits violations based on lap time volatility and position changes.
        Returns list of Penalty objects.
        """
        penalties = []
        
        # Get tier configuration
        tier_config = PENALTY_CONFIG.get(tier, PENALTY_CONFIG[1])
        threshold = tier_config['track_limits_threshold']
        
        # Analyze each driver's performance
        for driver_name, telemetry in result.telemetry.items():
            # Count "suspicious" laps (very fast laps that might indicate track limits abuse)
            avg_lap = telemetry.get('avg_lap_time', 100.0)
            fastest = telemetry.get('fastest_lap', avg_lap)
            
            # If fastest lap is >2 seconds faster than average, possible track limits abuse
            lap_improvement = avg_lap - fastest
            
            if lap_improvement > 2.0:
                # Estimate violations (very rough heuristic)
                estimated_violations = int(lap_improvement * 1.5)  # ~1.5 violations per second gained
                
                if estimated_violations >= threshold:
                    # Find team name
                    team_name = "Unknown"
                    for finish in result.final_positions:
                        if finish[0] == driver_name:
                            team_name = finish[1]
                            break
                    
                    # Issue penalty based on tier
                    if tier <= 3:
                        # Warning for lower tiers
                        penalty = Penalty(
                            race_id=race.get('race_id', 0),
                            team_name=team_name,
                            driver_name=driver_name,
                            penalty_type="warning",
                            magnitude=estimated_violations,
                            reason=f"Track limits violations ({estimated_violations} incidents) - Official Warning",
                            issued_by="Stewards",
                            appealable=False,
                            game_day=getattr(state, 'current_day', 0)
                        )
                    else:
                        # Time penalty for higher tiers
                        time_penalty_seconds = min(30, estimated_violations * 3)  # 3 seconds per violation, max 30
                        penalty = Penalty(
                            race_id=race.get('race_id', 0),
                            team_name=team_name,
                            driver_name=driver_name,
                            penalty_type="time_penalty",
                            magnitude=time_penalty_seconds,
                            reason=f"Track limits violations ({estimated_violations} incidents) - {time_penalty_seconds}s time penalty",
                            issued_by="Stewards",
                            appealable=True,
                            game_day=getattr(state, 'current_day', 0)
                        )
                    
                    penalties.append(penalty)
        
        return penalties
    
    @staticmethod
    def _apply_pending_grid_penalties(state: SimState, race_grid: List[tuple], tier: int) -> List[tuple]:
        """
        Apply unserved grid penalties to race starting positions.
        Modifies race_grid in place and marks penalties as applied.
        
        Args:
            race_grid: List of (team, driver, qual_score) tuples in qualifying order
            
        Returns:
            Modified race_grid with penalty-adjusted positions
        """
        # Find all unserved grid penalties for drivers in this race
        pending_grid_penalties = []
        
        for penalty in state.penalties:
            if penalty.penalty_type == "grid_penalty" and not getattr(penalty, 'applied', False):
                # Check if driver is in this race
                for i, (team, driver, qual_score) in enumerate(race_grid):
                    if driver.name == getattr(penalty, 'driver_name', '') and team.name == penalty.team_name:
                        pending_grid_penalties.append((i, penalty))
                        break
        
        # Apply penalties
        for original_pos, penalty in pending_grid_penalties:
            grid_penalty = penalty.magnitude
            
            # Move driver back by penalty positions
            affected_entry = race_grid[original_pos]
            race_grid.pop(original_pos)
            new_pos = min(len(race_grid), original_pos + grid_penalty)
            race_grid.insert(new_pos, affected_entry)
            
            # Mark penalty as applied
            penalty.applied = True
            
            _dbg(f"[FTB] GRID_PENALTY: {affected_entry[1].name} moved from P{original_pos+1} to P{new_pos+1} ({grid_penalty}-place penalty)")
        
        return race_grid
    
    @staticmethod
    def process_season_end_for_league(state: SimState, league: League) -> List[SimEvent]:
        """
        Per-league season end resolution: championship standings, promotion/relegation
        """
        events = []
        
        # Sort teams by championship points
        teams_sorted = sorted(
            league.championship_table.items(), 
            key=lambda x: x[1], 
            reverse=True
        )
        
        if not teams_sorted:
            _dbg(f"[FTB] WARNING: No standings for {league.name} at season end")
            return events
        
        # Emit championship standings event
        events.append(SimEvent(
            event_type="outcome",
            category="season_end",
            ts=state.tick,
            priority=95.0,
            severity="major",
            data={
                'league': league.name,
                'league_id': league.league_id,
                'tier': league.tier,
                'champion': teams_sorted[0][0],
                'champion_points': teams_sorted[0][1],
                'standings': teams_sorted[:10]  # Top 10
            }
        ))
        
        _dbg(f"[FTB] SEASON_CHAMPION: {teams_sorted[0][0]} wins {league.name} with {teams_sorted[0][1]} points")
        
        # Write season summary for player team (if they participated in this league)
        if state.player_team and state.player_team.league_id == league.league_id and state.state_db_path:
            try:
                import json
                from plugins import ftb_state_db
                
                # Find player team's final position
                player_position = None
                player_points = 0.0
                for idx, (team_name, points) in enumerate(teams_sorted):
                    if team_name == state.player_team.name:
                        player_position = idx + 1
                        player_points = points
                        break
                
                # Calculate season financial totals from transaction log
                transactions = ftb_state_db.query_financial_transactions(
                    state.state_db_path,
                    seasons=[state.season_number]
                )
                
                season_prize_money = sum(t['amount'] for t in transactions if t['type'] == 'income' and t['category'] == 'prize_money')
                season_sponsor_income = sum(t['amount'] for t in transactions if t['type'] == 'income' and t['category'] == 'sponsor_payment')
                season_expenses = sum(t['amount'] for t in transactions if t['type'] == 'expense')
                
                # Get starting balance (earliest transaction's balance minus amount)
                starting_balance = state.player_team.budget.cash
                if transactions:
                    first_txn = transactions[-1]  # Query returns newest first, so last is oldest
                    starting_balance = first_txn['balance_after'] - first_txn['amount'] if first_txn['type'] == 'expense' else first_txn['balance_after'] + first_txn['amount']
                
                # Get career stats for this season
                wins = 0
                podiums = 0
                poles = 0
                races_entered = 0
                
                # Query race results for this season
                season_races = ftb_state_db.query_race_results(
                    state.state_db_path,
                    seasons=[state.season_number]
                )
                
                races_entered = len(season_races)
                for race in season_races:
                    player_finishes = [pos for pos in race['finish_positions'] if pos['team'] == state.player_team.name]
                    for finish in player_finishes:
                        if finish['position'] == 1:
                            wins += 1
                        if finish['position'] <= 3:
                            podiums += 1
                    
                    if race['grid_position'] == 1:
                        poles += 1
                
                season_summary = {
                    'season': state.season_number,
                    'team_name': state.player_team.name,
                    'tier': f"T{state.player_team.tier}",
                    'league_id': league.league_id,
                    'championship_position': player_position,
                    'total_points': player_points,
                    'races_entered': races_entered,
                    'wins': wins,
                    'podiums': podiums,
                    'poles': poles,
                    'season_prize_money': season_prize_money,
                    'season_sponsor_income': season_sponsor_income,
                    'season_expenses': season_expenses,
                    'starting_balance': starting_balance,
                    'ending_balance': state.player_team.budget.cash,
                    'promoted': 0,  # Will be updated if promotion happens
                    'relegated': 0   # Will be updated if relegation happens
                }
                
                ftb_state_db.write_season_summary(state.state_db_path, season_summary)
                _dbg(f"[FTB] Wrote season {state.season_number} summary for {state.player_team.name}")
                
                # ═══════════════════════════════════════════════════════════════
                # PHASE 2: UPDATE HISTORICAL DATA AT SEASON END
                # ═══════════════════════════════════════════════════════════════
                try:
                    from plugins import ftb_historical_integration
                    
                    # Compile season data for historical update
                    season_data = {
                        'season': state.season_number,
                        'league_id': league.league_id,
                        'team_name': state.player_team.name,
                        'championship_position': player_position,
                        'total_points': player_points,
                        'races_entered': races_entered,
                        'wins': wins,
                        'podiums': podiums,
                        'poles': poles,
                        'promoted': False,  # Will be updated if promotion occurs
                        'relegated': False
                    }
                    
                    # Run bulk historical updates (career totals, peak/valley, etc.)
                    ftb_historical_integration.on_season_completed(
                        state.state_db_path,
                        state,
                        season_data
                    )
                    
                    _dbg(f"[FTB] ✓ Historical data updated for season {state.season_number}")
                    
                except Exception as e:
                    _dbg(f"[FTB] Warning: Could not update historical data at season end: {e}")
                    
            except Exception as e:
                _dbg(f"[FTB] Warning: Could not write season summary: {e}")
        
        # Apply infrastructure decay at season end
        for team_name in league.championship_table.keys():
            # Find the team object
            team = None
            if state.player_team and state.player_team.name == team_name:
                team = state.player_team
            else:
                team = next((t for t in state.ai_teams if t.name == team_name), None)
            
            if team:
                decay_events = FTBSimulation.apply_infrastructure_decay(state, team)
                events.extend(decay_events)
        
        # Reset for new season
        league.championship_table = {}
        league.driver_championship = {}
        league.races_this_season = 0
        
        # Reset team.standing_metrics['points'] to 0 for all teams
        for team in league.teams:
            team.standing_metrics['points'] = 0.0
        
        # Schedule next season (regenerate race schedule with tracks - tighter schedules)
        if league.tier == 5:
            weeks = 24  # Formula Z: 24 races
        elif league.tier == 4:
            weeks = 18  # Formula Y: 18 races
        elif league.tier == 3:
            weeks = 16  # Formula X: 16 races
        elif league.tier == 2:
            weeks = 14  # Formula V: 14 races
        else:
            weeks = 12  # Grassroots: 12 races
        start_week = state.tick + 14  # Start 14 ticks (2 weeks) after season end
        
        # Use proper schedule generation to maintain tuple format (tick, track_id)
        WorldBuilder._assign_tracks_to_schedule(state, league, weeks, start_week)
        
        return events
    
    @staticmethod
    def process_season_end(state: SimState) -> List[SimEvent]:
        """
        End-of-season resolution: championship final standings, promotion/relegation, 
        team exits, and standing metric shocks.
        (Legacy function - now handled per-league in tick_simulation)
        """
        events = []
        
        # Process each league
        for league_id, league in state.leagues.items():
            # Check if this league completed a full season (16 races)
            if league.races_this_season < 16:
                continue
            
            # Sort teams by championship points
            teams_sorted = sorted(
                league.championship_table.items(), 
                key=lambda x: x[1], 
                reverse=True
            )
            
            # Emit championship standings event
            events.append(SimEvent(
                event_type="outcome",
                category="season_end",
                ts=state.tick,
                priority=95.0,
                severity="major",
                data={
                    'league': league.name,
                    'tier': league.tier,
                    'champion': teams_sorted[0][0] if teams_sorted else None,
                    'champion_points': teams_sorted[0][1] if teams_sorted else 0,
                    'standings': teams_sorted[:10]  # Top 10
                }
            ))
            
            # ============================================================
            # PROMOTION ELIGIBILITY & INVITATIONS (Phase 3.3)
            # ============================================================
            # Top teams become ELIGIBLE for promotion but don't automatically move
            # System generates either:
            # - Invitation offers for exceptional performers
            # - Opportunity to apply for promotion (with fees)
            
            if league.tier < 5 and len(teams_sorted) >= 2:
                # Top 3 teams are considered for promotion opportunities
                for i in range(min(3, len(teams_sorted))):
                    team_name = teams_sorted[i][0]
                    team_obj = next((t for t in league.teams if t.name == team_name), None)
                    if not team_obj:
                        continue
                    
                    position = i + 1
                    final_points = teams_sorted[i][1]
                    
                    # Calculate promotion eligibility score
                    eligibility_score = FTBSimulation._calculate_promotion_eligibility(
                        state, team_obj, position, final_points, league
                    )
                    
                    # Exceptional teams (P1-P2 with strong metrics) get invitations
                    is_invited = (
                        position <= 2 and 
                        eligibility_score >= 75 and
                        team_obj.budget.cash >= 200000  # Must have financial stability
                    )
                    
                    # Good teams (P1-P3 with decent metrics) can apply
                    can_apply = (
                        position <= 3 and
                        eligibility_score >= 50
                    )
                    
                    if team_obj == state.player_team:
                        if is_invited:
                            # Send invitation to player
                            events.append(SimEvent(
                                event_type="opportunity",
                                category="promotion_invitation",
                                ts=state.tick,
                                priority=95.0,
                                severity="major",
                                data={
                                    'team': team_name,
                                    'from_tier': league.tier,
                                    'to_tier': league.tier + 1,
                                    'from_tier_name': league.tier_name,
                                    'to_tier_name': FTBSimulation._get_tier_name(league.tier + 1),
                                    'position': position,
                                    'points': final_points,
                                    'eligibility_score': eligibility_score,
                                    'entry_fee': 0,  # Invited = no fee
                                    'message': f'Congratulations! P{position} finish has earned an invitation to {FTBSimulation._get_tier_name(league.tier + 1)}!',
                                    'action_required': True,
                                    'expires_tick': state.tick + 42  # 6 weeks to respond
                                }
                            ))
                        elif can_apply:
                            # Player can apply (with entry fee)
                            entry_fee = FTBSimulation._calculate_promotion_fee(league.tier + 1, team_obj)
                            events.append(SimEvent(
                                event_type="opportunity",
                                category="promotion_application",
                                ts=state.tick,
                                priority=85.0,
                                severity="info",
                                data={
                                    'team': team_name,
                                    'from_tier': league.tier,
                                    'to_tier': league.tier + 1,
                                    'from_tier_name': league.tier_name,
                                    'to_tier_name': FTBSimulation._get_tier_name(league.tier + 1),
                                    'position': position,
                                    'points': final_points,
                                    'eligibility_score': eligibility_score,
                                    'entry_fee': entry_fee,
                                    'message': f'P{position} finish qualifies you to apply for promotion to {FTBSimulation._get_tier_name(league.tier + 1)}',
                                    'action_required': True,
                                    'expires_tick': state.tick + 42
                                }
                            ))
                        else:
                            # Not eligible yet - show what's needed
                            events.append(SimEvent(
                                event_type="outcome",
                                category="promotion_ineligible",
                                ts=state.tick,
                                priority=60.0,
                                severity="info",
                                data={
                                    'team': team_name,
                                    'position': position,
                                    'eligibility_score': eligibility_score,
                                    'threshold': 50,
                                    'message': f'P{position} finish - Not yet eligible for promotion (Score: {eligibility_score:.0f}/100)'
                                }
                            ))
                    else:
                        # AI teams: auto-decide based on eligibility
                        if is_invited or (can_apply and state.rng.random() > 0.3):
                            # AI accepts invitation or applies (70% chance if eligible)
                            # This will be processed in a separate promotion handler
                            if not hasattr(state, 'pending_promotions'):
                                state.pending_promotions = []
                            state.pending_promotions.append({
                                'team_name': team_name,
                                'team_obj': team_obj,
                                'from_league': league,
                                'to_tier': league.tier + 1,
                                'is_invited': is_invited,
                                'entry_fee': 0 if is_invited else FTBSimulation._calculate_promotion_fee(league.tier + 1, team_obj),
                                'process_tick': state.tick + 14  # Process in 2 weeks
                            })
            
            # ============================================================
            # RELEGATION EVALUATION (Phase 3.3)
            # ============================================================
            # Bottom teams face FORCED relegation or can VOLUNTARILY drop down
            
            if league.tier > 1 and len(teams_sorted) >= 2:
                # Bottom 3 teams face relegation pressure
                for i in range(min(3, len(teams_sorted))):
                    idx = -(i+1)  # Start from end
                    team_name = teams_sorted[idx][0]
                    team_obj = next((t for t in league.teams if t.name == team_name), None)
                    if not team_obj:
                        continue
                    
                    position = len(teams_sorted) - i
                    final_points = teams_sorted[idx][1]
                    
                    # Calculate relegation factors
                    relegation_factors = FTBSimulation._evaluate_relegation_risk(
                        state, team_obj, position, final_points, league
                    )
                    
                    # FORCED relegation: catastrophic failure on multiple fronts
                    force_relegation = (
                        relegation_factors['risk_score'] >= 80 or
                        (position >= len(teams_sorted) - 1 and relegation_factors['financial_crisis']) or
                        (final_points < 10 and team_obj.budget.cash < 50000)
                    )
                    
                    # VOLUNTARY opportunity: struggling teams can choose to drop down
                    can_volunteer = (
                        relegation_factors['risk_score'] >= 40 and
                        not force_relegation
                    )
                    
                    if team_obj == state.player_team:
                        if force_relegation:
                            # Player MUST be relegated (game over scenario or forced move)
                            events.append(SimEvent(
                                event_type="outcome",
                                category="forced_relegation",
                                ts=state.tick,
                                priority=98.0,
                                severity="critical",
                                data={
                                    'team': team_name,
                                    'from_tier': league.tier,
                                    'to_tier': league.tier - 1,
                                    'from_tier_name': league.tier_name,
                                    'to_tier_name': FTBSimulation._get_tier_name(league.tier - 1),
                                    'position': position,
                                    'points': final_points,
                                    'risk_score': relegation_factors['risk_score'],
                                    'reasons': relegation_factors['reasons'],
                                    'message': f'FORCED RELEGATION: {", ".join(relegation_factors["reasons"])}',
                                    'auto_execute': True  # Happens automatically
                                }
                            ))
                            
                            # Queue for automatic relegation processing
                            if not hasattr(state, 'pending_relegations'):
                                state.pending_relegations = []
                            state.pending_relegations.append({
                                'team_name': team_name,
                                'team_obj': team_obj,
                                'from_league': league,
                                'to_tier': league.tier - 1,
                                'forced': True,
                                'process_tick': state.tick + 7  # Process in 1 week
                            })
                            
                        elif can_volunteer:
                            # Player can CHOOSE to voluntarily relegate
                            events.append(SimEvent(
                                event_type="opportunity",
                                category="voluntary_relegation_offer",
                                ts=state.tick,
                                priority=80.0,
                                severity="warning",
                                data={
                                    'team': team_name,
                                    'from_tier': league.tier,
                                    'to_tier': league.tier - 1,
                                    'from_tier_name': league.tier_name,
                                    'to_tier_name': FTBSimulation._get_tier_name(league.tier - 1),
                                    'position': position,
                                    'points': final_points,
                                    'risk_score': relegation_factors['risk_score'],
                                    'reasons': relegation_factors['reasons'],
                                    'benefits': [
                                        'Lower operating costs',
                                        'Easier competition',
                                        'Time to rebuild',
                                        'Reduced pressure'
                                    ],
                                    'message': f'Struggling at P{position} - Consider voluntary relegation to rebuild?',
                                    'action_required': True,
                                    'expires_tick': state.tick + 28  # 4 weeks to decide
                                }
                            ))
                    else:
                        # AI teams: auto-decide based on circumstances
                        if force_relegation:
                            # AI automatically relegated
                            if not hasattr(state, 'pending_relegations'):
                                state.pending_relegations = []
                            state.pending_relegations.append({
                                'team_name': team_name,
                                'team_obj': team_obj,
                                'from_league': league,
                                'to_tier': league.tier - 1,
                                'forced': True,
                                'process_tick': state.tick + 7
                            })
                        elif can_volunteer and state.rng.random() > 0.7:
                            # 30% of struggling AI teams voluntarily relegate
                            if not hasattr(state, 'pending_relegations'):
                                state.pending_relegations = []
                            state.pending_relegations.append({
                                'team_name': team_name,
                                'team_obj': team_obj,
                                'from_league': league,
                                'to_tier': league.tier - 1,
                                'forced': False,
                                'process_tick': state.tick + 14
                            })
            
            # Team liquidation (catastrophic failure in tier 1)
            if league.tier == 1 and len(teams_sorted) >= 1:
                last_team_name = teams_sorted[-1][0]
                last_team_obj = next((t for t in league.teams if t.name == last_team_name), None)
                if last_team_obj and teams_sorted[-1][1] < 5:  # Fewer than 5 points = liquidation
                    events.append(SimEvent(
                        event_type="outcome",
                        category="team_liquidation",
                        ts=state.tick,
                        priority=95.0,
                        severity="critical",
                        data={
                            'team': last_team_name,
                            'tier': league.tier,
                            'final_points': teams_sorted[-1][1],
                            'reason': 'chronic_failure'
                        }
                    ))
                    # Remove from league and AI teams
                    league.teams.remove(last_team_obj)
                    if last_team_obj in state.ai_teams:
                        state.ai_teams.remove(last_team_obj)
            
            # ============================================================
            # SEASON-END STANDING METRIC SHOCKS (Phase 2.2)
            # ============================================================
            # Evaluate each team's performance vs expectations
            for team_name, final_points in teams_sorted:
                team_obj = next((t for t in league.teams if t.name == team_name), None)
                if not team_obj:
                    continue
                
                # Get expectations for this team
                expectations = FTBSimulation.infer_role_and_expectations(state, team_obj)
                expected_range = expectations.get('expected_range', (8, 12))
                points_target = expectations.get('points_target', 10)
                
                # Determine finish position in championship
                finish_position = next((i+1 for i, (name, _) in enumerate(teams_sorted) if name == team_name), len(teams_sorted))
                
                # Evaluate performance
                overachieved = finish_position < expected_range[0] - 2  # 3+ positions better
                met_expectations = expected_range[0] <= finish_position <= expected_range[1]
                underperformed = finish_position > expected_range[1] and finish_position <= expected_range[1] + 2
                failed_badly = finish_position > expected_range[1] + 2  # 3+ positions worse
                
                # Apply standing metric shocks
                if overachieved:
                    # Self-owned teams don't have owner pressure
                    if getattr(team_obj, 'ownership_type', 'hired_manager') != 'self_owned':
                        team_obj.standing_metrics['ownership_confidence'] = min(100, team_obj.standing_metrics['ownership_confidence'] + 15)
                    team_obj.standing_metrics['legitimacy'] = min(100, team_obj.standing_metrics['legitimacy'] + 10)
                    team_obj.standing_metrics['reputation'] = min(100, team_obj.standing_metrics['reputation'] + 8)
                    
                    if team_obj == state.player_team:
                        events.append(SimEvent(
                            event_type="outcome",
                            category="season_overachievement",
                            ts=state.tick,
                            priority=90.0,
                            severity="major",
                            data={
                                'team': team_name,
                                'finish_position': finish_position,
                                'expected_range': expected_range,
                                'points': final_points,
                                'message': 'Exceptional season results exceed all expectations'
                            }
                        ))
                elif met_expectations:
                    # Self-owned teams don't have owner pressure
                    if getattr(team_obj, 'ownership_type', 'hired_manager') != 'self_owned':
                        team_obj.standing_metrics['ownership_confidence'] = min(100, team_obj.standing_metrics['ownership_confidence'] + 5)
                    team_obj.standing_metrics['legitimacy'] = min(100, team_obj.standing_metrics['legitimacy'] + 5)
                    team_obj.standing_metrics['reputation'] = min(100, team_obj.standing_metrics['reputation'] + 5)
                elif underperformed:
                    # Self-owned teams don't have owner pressure
                    if getattr(team_obj, 'ownership_type', 'hired_manager') != 'self_owned':
                        team_obj.standing_metrics['ownership_confidence'] = max(0, team_obj.standing_metrics['ownership_confidence'] - 8)
                    team_obj.standing_metrics['legitimacy'] = max(0, team_obj.standing_metrics['legitimacy'] - 5)
                    
                    if team_obj == state.player_team:
                        events.append(SimEvent(
                            event_type="pressure",
                            category="season_underperformance",
                            ts=state.tick,
                            priority=85.0,
                            severity="major",
                            data={
                                'team': team_name,
                                'finish_position': finish_position,
                                'expected_range': expected_range,
                                'points': final_points,
                                'message': 'Season results disappoint ownership - pressure mounting'
                            }
                        ))
                elif failed_badly:
                    # Self-owned teams don't have owner pressure
                    if getattr(team_obj, 'ownership_type', 'hired_manager') != 'self_owned':
                        team_obj.standing_metrics['ownership_confidence'] = max(0, team_obj.standing_metrics['ownership_confidence'] - 20)
                    team_obj.standing_metrics['legitimacy'] = max(0, team_obj.standing_metrics['legitimacy'] - 15)
                    team_obj.standing_metrics['reputation'] = max(0, team_obj.standing_metrics['reputation'] - 10)
                    
                    if team_obj == state.player_team:
                        events.append(SimEvent(
                            event_type="pressure",
                            category="ownership_ultimatum",
                            ts=state.tick,
                            priority=95.0,
                            severity="critical",
                            data={
                                'team': team_name,
                                'finish_position': finish_position,
                                'expected_range': expected_range,
                                'points': final_points,
                                'message': 'Catastrophic season failure triggers ownership emergency meeting',
                                'ultimatum': 'Immediate improvement required or face termination'
                            }
                        ))
            
            # ============================================================
            # PRIZE MONEY & INCOME DISTRIBUTION (Phase 3.2)
            # ============================================================
            # Award prize money based on championship position
            # Championship finish payout structure with hype drift influence
            
            # Define tier-specific prize structures with position-based payouts
            # Structure: {position: base_payout} for positions 1-10+
            tier_prize_structures = {
                1: {  # Tier 1 (Grassroots)
                    1: 150000,
                    2: 110000,
                    3: 85000,
                    4: 70000,
                    5: 60000,
                    6: 55000,
                    7: 45000,
                    8: 35000,
                    9: 25000,
                    10: 15000  # 10th+ all get this
                },
                2: {  # Tier 2 (Formula V)
                    1: 400000,
                    2: 300000,
                    3: 230000,
                    4: 180000,
                    5: 150000,
                    6: 130000,
                    7: 110000,
                    8: 90000,
                    9: 70000,
                    10: 50000
                },
                3: {  # Tier 3 (Formula X)
                    1: 1200000,
                    2: 900000,
                    3: 700000,
                    4: 550000,
                    5: 450000,
                    6: 380000,
                    7: 320000,
                    8: 260000,
                    9: 200000,
                    10: 150000
                },
                4: {  # Tier 4 (Formula Y)
                    1: 3000000,
                    2: 2200000,
                    3: 1700000,
                    4: 1300000,
                    5: 1100000,
                    6: 950000,
                    7: 800000,
                    8: 650000,
                    9: 500000,
                    10: 400000
                },
                5: {  # Tier 5 (Formula Z)
                    1: 8000000,
                    2: 6000000,
                    3: 4500000,
                    4: 3500000,
                    5: 2900000,
                    6: 2500000,
                    7: 2100000,
                    8: 1700000,
                    9: 1400000,
                    10: 1100000
                }
            }
            
            prize_structure = tier_prize_structures.get(league.tier, tier_prize_structures[1])
            
            for position, (team_name, points) in enumerate(teams_sorted, 1):
                team_obj = next((t for t in league.teams if t.name == team_name), None)
                if not team_obj:
                    continue
                
                # Get base prize for position (positions 10+ all get position 10 payout)
                base_prize = prize_structure.get(min(position, 10), prize_structure[10])
                
                # Apply hype drift modifier: ±15% based on league hype
                # Hype ranges from ~0.5 to ~2.0, so hype_modifier ranges from ~0.85 to ~1.15
                league_hype = league.hype
                hype_modifier = 0.85 + (min(max(league_hype, 0.5), 2.0) - 0.5) * 0.2  # Maps 0.5-2.0 → 0.85-1.15
                
                prize_money = base_prize * hype_modifier
                
                # Award the prize money
                team_obj.budget.cash += prize_money
                
                # Update income streams for next season (media broadcasting rights based on media standing)
                media_standing = team_obj.standing_metrics.get('media_standing', 50.0)
                base_media_rights = 100000
                media_bonus = max(0, (media_standing - 50) / 10) * 50000  # +50k per 10 points over 50
                
                # Apply league hype multiplier to media rights
                league_hype_multiplier = league.hype
                media_rights_payment = (base_media_rights + media_bonus) * league_hype_multiplier
                
                # Clear old income streams and add new ones
                team_obj.budget.income_streams = []
                team_obj.budget.income_streams.append(
                    IncomeSource(name="Media Rights", amount=media_rights_payment, frequency="season")
                )
                
                if team_obj == state.player_team:
                    hype_status = ""
                    prize_hype_status = ""
                    
                    # Show hype modifier for prize money
                    if hype_modifier != 1.0:
                        if hype_modifier > 1.0:
                            prize_hype_status = f" [+{(hype_modifier - 1.0) * 100:.1f}% hype bonus]"
                        else:
                            prize_hype_status = f" [{(hype_modifier - 1.0) * 100:.1f}% hype penalty]"
                    
                    # Show hype multiplier for media rights
                    if league_hype_multiplier > 1.0:
                        hype_status = f" [{league_hype_multiplier:.2f}x league hype!]"
                    
                    events.append(SimEvent(
                        event_type="outcome",
                        category="prize_money",
                        ts=state.tick,
                        priority=80.0,
                        severity="info",
                        data={
                            'team': team_name,
                            'position': position,
                            'prize': prize_money,
                            'base_prize': base_prize,
                            'hype_modifier': hype_modifier,
                            'media_rights': media_rights_payment,
                            'media_bonus': media_bonus,
                            'league_hype': league_hype_multiplier,
                            'message': f'Championship P{position} Prize: ${prize_money:,.0f}{prize_hype_status} + ${media_rights_payment:,.0f} media rights{hype_status}'
                        }
                    ))
            
            # ML TRAINING: Log season outcomes BEFORE resetting championship table
            if hasattr(state, 'state_db_path') and state.state_db_path and league.championship_table:
                try:
                    from plugins.ftb_state_db import log_team_outcome
                    
                    teams_sorted = sorted(league.championship_table.items(), key=lambda x: x[1], reverse=True)
                    
                    for team_name, points in teams_sorted:
                        team_obj = next((t for t in league.teams if t.name == team_name), None)
                        if not team_obj or not hasattr(team_obj, 'team_id'):
                            continue
                        
                        # Get starting budget from team attribute if tracked
                        starting_budget = getattr(team_obj, '_season_start_budget', team_obj.budget.cash)
                        ending_budget = team_obj.budget.cash
                        
                        # Calculate seasons survived
                        seasons_survived = getattr(team_obj, 'seasons_active', 1)
                        
                        # Determine position
                        position = next((i for i, (tn, _) in enumerate(teams_sorted, 1) if tn == team_name), 99)
                        
                        log_team_outcome(
                            db_path=state.state_db_path,
                            team_id=team_obj.team_id,
                            team_name=team_name,
                            season=state.season_number,
                            championship_position=position,
                            total_points=points,
                            starting_budget=starting_budget,
                            ending_budget=ending_budget,
                            survival_flag=True,
                            folded_tick=None,
                            seasons_survived=seasons_survived
                        )
                        
                        # Track starting budget for next season
                        team_obj._season_start_budget = ending_budget
                except Exception as e:
                    _dbg(f"[FTB ML] Warning: Failed to log season outcomes for {league_id}: {e}")
            
            # ============================================================
            # PER-LEAGUE SEASON ROLLOVER
            # ============================================================
            # Each league runs on its own season cycle - no global synchronization
            # Track per-league season numbers for historical tracking
            if not hasattr(league, 'season_number'):
                league.season_number = 1
            
            league.season_number += 1
            
            # Only increment global season_number when player's league completes
            if state.player_team and state.player_team.league_id == league.league_id:
                state.season_number += 1
                state.manager_career_stats.seasons_managed += 1
                state.races_completed_this_season = 0
                state.in_offseason = True
                state.offseason_ticks_remaining = 56  # 8 weeks
                state.phase = "offseason"
                _dbg(f"[FTB] PLAYER_SEASON_ROLLOVER: {league.name} complete, advancing to Season {state.season_number}")
                
                events.append(SimEvent(
                    event_type="time",
                    category="season_rollover",
                    ts=state.tick,
                    priority=98.0,
                    severity="major",
                    data={
                        'new_season': state.season_number,
                        'league': league.name,
                        'message': f'{league.name} Season {league.season_number} begins!'
                    }
                ))
            else:
                _dbg(f"[FTB] LEAGUE_SEASON_COMPLETE: {league.name} finished season {league.season_number - 1}, starting season {league.season_number}")
            
            # Reset championship table for new season
            league.championship_table = {}
            league.races_this_season = 0
            
            # Apply hype decay - gradually return to baseline over off-season
            if league.hype > 1.0:
                decay_factor = 0.3  # Lose 30% of excess hype per season
                league.hype = 1.0 + (league.hype - 1.0) * (1.0 - decay_factor)
                _dbg(f"[FTB] HYPE_DECAY: {league.name} hype decayed to {league.hype:.2f}x")
            league.hype_events_this_season = 0
            
            # Soft reset team morale - move 35% toward neutral (50) for off-season refresh
            for team_obj in league.teams:
                if team_obj and 'morale' in team_obj.standing_metrics:
                    current_morale = team_obj.standing_metrics['morale']
                    # Pull toward 50 by 35%
                    team_obj.standing_metrics['morale'] = current_morale + (50.0 - current_morale) * 0.35
                    
                    # Soft reset driver morale too
                    for driver in team_obj.drivers:
                        if driver and hasattr(driver, 'morale'):
                            current_driver_morale = driver.morale
                            driver.morale = current_driver_morale + (50.0 - current_driver_morale) * 0.35
        
        # Update manager career stats at season end
        if state.player_team and state.manager_career_stats:
            # Find player's championship finish
            for league in state.leagues.values():
                if state.player_team in league.teams:
                    teams_sorted = sorted(league.championship_table.items(), key=lambda x: x[1], reverse=True)
                    for position, (team_name, points) in enumerate(teams_sorted, 1):
                        if team_name == state.player_team.name:
                            # Update best championship finish
                            if position < state.manager_career_stats.best_championship_finish:
                                state.manager_career_stats.best_championship_finish = position
                            
                            # Check for championship win
                            if position == 1:
                                state.manager_career_stats.championships += 1
                            
                            # Add season history entry
                            season_wins = state.manager_career_stats.wins  # Cumulative, would need per-season tracking
                            season_podiums = state.manager_career_stats.podiums  # Cumulative, would need per-season tracking
                            state.manager_career_stats.season_history.append({
                                'year': state.sim_year,
                                'team': state.player_team.name,
                                'position': position,
                                'points': points,
                                'wins': 0,  # Would need per-season tracking
                                'podiums': 0  # Would need per-season tracking
                            })
                            break
                    break
            
            # Mark manager career as dirty to trigger UI refresh
            state.mark_dirty('manager_career')
        
        # Reset global season counter
        state.races_completed_this_season = 0
        state.season_number += 1
        state.manager_career_stats.seasons_managed += 1
        state.in_offseason = True
        state.offseason_ticks_remaining = 56  # 8 weeks
        state.phase = "offseason"  # Enter between-season break
        
        return events
    
    @staticmethod
    def simulate_development_cycle(state: SimState, team: Team) -> Dict[str, Any]:
        """Car development resolution: correlation risk, regression, etc."""
        # Engineer stats determine success probability
        # Simplified for MVP
        return {'success': state.rng.random() > 0.5}
    
    @staticmethod
    def update_entity_growth_decay(state: SimState) -> None:
        """Apply potential progression and decline pressure"""
        # All entities age and evolve
        # Drivers peak earlier, engineers peak later
        context = {'week': state.tick, 'team_stability': 0.5}
        
        # Collect all entities from all teams
        all_teams = [state.player_team] + state.ai_teams if state.player_team else state.ai_teams
        
        for team in all_teams:
            if team is None:
                continue
            
            # Process all entity types
            entities_to_process = (
                team.drivers + 
                team.engineers + 
                team.mechanics + 
                ([team.strategist] if team.strategist else []) +
                ([team.principal] if team.principal else [])
            )
            
            for entity in entities_to_process:
                if entity is None:
                    continue
                
                # Calculate domain-specific infrastructure quality for this entity type
                # Different roles benefit from different facility categories
                entity_type = type(entity).__name__
                
                if entity_type == 'Driver':
                    # Drivers benefit from simulator, fitness, and driver development facilities
                    relevant_facilities = ['basic_simulator', 'improved_simulator', 'driver_fitness', 
                                          'fitness_program', 'driver_development', 'simulator']
                elif entity_type == 'Engineer':
                    # Engineers benefit from engineering support, specialized teams, and R&D
                    relevant_facilities = ['engineering_desk', 'engineering_roles', 'rd_department', 
                                          'specialized_teams', 'data_analysis', 'cfd_limited', 'cfd_advanced']
                elif entity_type == 'Mechanic':
                    # Mechanics benefit from workshop, fabrication, and QA facilities
                    relevant_facilities = ['workshop', 'fabrication', 'reliability_qa', 
                                          'maintenance_program', 'factory_quality']
                elif entity_type == 'Strategist':
                    # Strategists benefit from data systems and regulation analysis
                    relevant_facilities = ['data_logging', 'data_analysis', 'regulation_analysis', 
                                          'commercial_department']
                else:
                    # Default: use average of all infrastructure
                    relevant_facilities = list(team.infrastructure.keys())
                
                # Calculate average quality of relevant facilities (only _unlocked ones)
                relevant_quality_values = []
                for fac in relevant_facilities:
                    if fac in team.infrastructure:
                        # Check if unlocked (if unlock key exists)
                        unlock_key = f"{fac}_unlocked"
                        if unlock_key in team.infrastructure:
                            if team.infrastructure[unlock_key]:
                                relevant_quality_values.append(team.infrastructure[fac])
                        else:
                            # No unlock key means facility is always active
                            relevant_quality_values.append(team.infrastructure[fac])
                
                domain_infrastructure = sum(relevant_quality_values) / len(relevant_quality_values) if relevant_quality_values else 50.0
                
                # Apply growth and decay with domain-specific infrastructure modifier
                entity.update_growth(context, infrastructure_quality=domain_infrastructure)
                entity.apply_decay(infrastructure_quality=domain_infrastructure)
                # Note: current_ratings are already updated in place by these methods
    
    @staticmethod
    def apply_financial_flows(state: SimState) -> List[SimEvent]:
        """Budget ticks: per-tick income and infrastructure upkeep.
        
        NOTE: Payroll is handled separately by process_salary_payouts() every 14 ticks.
        Do NOT deduct payroll here to avoid double-charging.
        """
        events = []
        all_teams = [state.player_team] + state.ai_teams if state.player_team else state.ai_teams
        
        for team in all_teams:
            if team is None:
                continue
            
            # Ensure staff salaries are populated (defensive - handles both new games and loaded saves)
            team.ensure_staff_salaries()
            
            # Calculate income (per-tick from season total)
            # Income is distributed evenly across ~112 ticks per season (16 races × 7 ticks)
            tick_income = 0.0
            for income_stream in team.budget.income_streams:
                tick_income += income_stream.amount / 112.0  # Distribute across season
            
            # Infrastructure upkeep costs (only for unlocked facilities)
            # NOTE: Payroll is NOT included here — it is paid bi-weekly via process_salary_payouts()
            infrastructure_cost = 0.0
            for facility, quality in team.infrastructure.items():
                # Skip if this is an unlock flag (e.g., 'factory_unlocked')
                if facility.endswith('_unlocked'):
                    continue
                # Only charge upkeep if facility is unlocked
                unlock_key = f"{facility}_unlocked"
                is_unlocked = team.infrastructure.get(unlock_key, False)
                if is_unlocked and facility in INFRASTRUCTURE_UPKEEP_COST:
                    infrastructure_cost += INFRASTRUCTURE_UPKEEP_COST[facility](quality)
            
            # Apply income and infrastructure costs (no payroll — that's bi-weekly)
            team.budget.cash += tick_income
            team.budget.cash -= infrastructure_cost
            
            # Log operational expenses (only for player team)
            if team == state.player_team and infrastructure_cost > 0:
                state.log_transaction(
                    type="expense",
                    category="infrastructure_upkeep",
                    amount=infrastructure_cost,
                    description=f"Infrastructure upkeep: ${infrastructure_cost:.0f}",
                    balance_after=team.budget.cash
                )
            
            # Apply standard budget tick (burn rate + commitments)
            team.budget.advance_tick(state.tick)
            
            # Check for economic crisis (only for player team)
            if team == state.player_team:
                crisis_events = FTBSimulation.check_economic_crisis(state, team)
                events.extend(crisis_events)
        
        return events
    
    @staticmethod
    def apply_infrastructure_decay(state: SimState, team: Team) -> List[SimEvent]:
        """
        Apply gradual quality degradation to all infrastructure facilities at season end.
        Decay rate modified by maintenance_program and redundant_infrastructure quality.
        """
        events = []
        
        # Base decay per season from constants
        base_decay = INFRASTRUCTURE_EFFECTS['facility_decay_per_season']
        
        # Maintenance program reduces decay (if unlocked)
        maintenance_quality = 0.0
        if team.infrastructure.get('maintenance_program_unlocked', False):
            maintenance_quality = team.infrastructure.get('maintenance_program', 50.0)
        
        # Redundant infrastructure also reduces decay (Formula Z facility)
        redundant_quality = 0.0
        if team.infrastructure.get('redundant_infrastructure_unlocked', False):
            redundant_quality = team.infrastructure.get('redundant_infrastructure', 50.0)
        
        # Calculate decay modifier: maintenance + redundant systems reduce decay
        # At 70+ combined quality, decay reduced by ~40%
        combined_protection = (maintenance_quality + redundant_quality) / 2.0
        decay_modifier = 1.0 - ((combined_protection - 50.0) / 100.0) * 0.8
        decay_modifier = max(0.3, min(1.5, decay_modifier))  # Clamp to 30%-150%
        
        actual_decay = base_decay * decay_modifier
        
        # Apply decay to all quality values (not unlock flags)
        decayed_facilities = []
        critical_facilities = []  # Facilities that drop below 40
        
        for facility_key, value in team.infrastructure.items():
            # Skip unlock flags and non-numeric values
            if '_unlocked' in facility_key or not isinstance(value, (int, float)):
                continue
            
            # Skip if facility isn't unlocked
            unlock_key = f"{facility_key}_unlocked"
            if unlock_key in team.infrastructure and not team.infrastructure[unlock_key]:
                continue
            
            old_value = value
            new_value = max(20.0, value - actual_decay)  # Floor at 20 (catastrophic failure threshold)
            
            if new_value != old_value:
                team.infrastructure[facility_key] = new_value
                decayed_facilities.append({
                    'facility': facility_key,
                    'old_quality': round(old_value, 1),
                    'new_quality': round(new_value, 1),
                    'decay_amount': round(old_value - new_value, 1)
                })
                
                # Check for critical low quality
                if new_value < 40.0:
                    critical_facilities.append(facility_key)
        
        # Emit decay event if any facilities degraded
        if decayed_facilities:
            events.append(SimEvent(
                event_type="structural",
                category="infrastructure_decay",
                ts=state.tick,
                priority=60.0 if critical_facilities else 40.0,
                severity="warning" if critical_facilities else "info",
                data={
                    'team': team.name,
                    'decay_modifier': round(decay_modifier, 2),
                    'facilities_decayed': decayed_facilities,
                    'critical_facilities': critical_facilities,
                    'maintenance_quality': round(maintenance_quality, 1),
                    'redundant_quality': round(redundant_quality, 1)
                }
            ))
        
        # Emit catastrophic failure events for critically low facilities
        for facility in critical_facilities:
            quality = team.infrastructure[facility]
            if quality <= 25.0:
                events.append(SimEvent(
                    event_type="pressure",
                    category="infrastructure_crisis",
                    ts=state.tick,
                    priority=85.0,
                    severity="danger",
                    data={
                        'team': team.name,
                        'facility': facility,
                        'quality': round(quality, 1),
                        'message': f"{facility} in critical condition - immediate attention required"
                    }
                ))
        
        return events
    
    @staticmethod
    def check_economic_crisis(state: SimState, team: Team) -> List[SimEvent]:
        """
        Multi-stage bankruptcy pipeline with escalating severity.
        Returns events triggered by cash runway thresholds.
        """
        events = []
        cash_runway = FTBSimulation.calculate_cash_runway(team)
        
        # Threshold 0: < 3 weeks (21 ticks) - Bailout Opportunity (if eligible)
        if cash_runway < 21 and not hasattr(team, '_bailout_offered_this_crisis'):
            # Check for bailout savior sponsors
            bailout_sponsor = None
            if team.name in state.sponsorships:
                for sponsor in state.sponsorships[team.name]:
                    # Parse narrative hooks to check bailout_savior flag
                    try:
                        import json
                        if sponsor.narrative_hooks_json:
                            hooks = json.loads(sponsor.narrative_hooks_json)
                            if hooks.get('bailout_savior', False):
                                # Check if sponsor has already bailed out (both per-sponsor and per-team limits)
                                if not getattr(sponsor, 'has_bailed_out', False):
                                    # Check team-level bailout count
                                    team_bailout_count = getattr(team, '_bailout_count', 0)
                                    if team_bailout_count < 2:  # Max 2 bailouts per save
                                        # Check sponsor confidence and loyalty
                                        if sponsor.confidence >= 60.0:  # Must have decent relationship
                                            behavior = json.loads(sponsor.contract_behavior_json) if sponsor.contract_behavior_json else {}
                                            loyalty = behavior.get('loyalty', 0.5)
                                            if loyalty > 0.65:  # Must be loyal
                                                bailout_sponsor = sponsor
                                                break
                    except Exception as e:
                        _dbg(f"[FTB] Error checking bailout savior: {e}")
                        continue
            
            if bailout_sponsor:
                # 30% chance per tick to trigger bailout offer
                import random
                rng = random.Random(state.seed + state.tick + hash(team.name))
                if rng.random() < 0.30:
                    team._bailout_offered_this_crisis = True
                    
                    # Calculate bailout terms
                    months_runway = max(3, min(6, int(21 - cash_runway) / 7 + 3))  # 3-6 months based on severity
                    weekly_burn = abs(team.budget.cash / cash_runway) if cash_runway > 0 else 50000
                    bailout_amount = int(weekly_burn * months_runway * 4.345)  # weeks to months conversion
                    payment_increase = 0.20 + (rng.random() * 0.10)  # 20-30% increase
                    
                    # Create bailout decision
                    options = [
                        DecisionOption(
                            id="accept_bailout",
                            label=f"Accept {bailout_sponsor.sponsor_name} Bailout",
                            cost=-bailout_amount,  # Negative cost = cash injection
                            description=f"Emergency capital injection: ${bailout_amount:,}. Payment +{payment_increase*100:.0f}% for remainder of contract.",
                            consequence_preview=f"Immediate cash relief, {bailout_sponsor.sponsor_name} gains equity stake (cosmetic)"
                        ),
                        DecisionOption(
                            id="decline_bailout",
                            label="Decline and find another way",
                            cost=0,
                            description="Refuse the bailout offer and manage crisis independently",
                            consequence_preview="Maintain full ownership, crisis continues"
                        )
                    ]
                    
                    decision = FTBSimulation.create_decision(
                        state,
                        category="sponsor_bailout",
                        prompt=f"{bailout_sponsor.sponsor_name} offers emergency capital injection to save {team.name} from insolvency",
                        options=options,
                        deadline_ticks=14,  # 2 weeks to decide (before fire sale)
                        auto_resolve_id="decline_bailout"  # Default: decline
                    )
                    
                    events.append(SimEvent(
                        event_type="opportunity",
                        category="sponsor_bailout_offer",
                        ts=state.tick,
                        priority=98.0,
                        severity="major",
                        data={
                            'decision_id': decision.decision_id,
                            'sponsor_name': bailout_sponsor.sponsor_name,
                            'bailout_amount': bailout_amount,
                            'payment_increase_pct': int(payment_increase * 100),
                            'cash_runway_weeks': cash_runway / 7,
                            'message': f'{bailout_sponsor.sponsor_name} offers emergency bailout to save team'
                        }
                    ))
        
        # Reset bailout flag if cash situation improves
        if cash_runway >= 21 and hasattr(team, '_bailout_offered_this_crisis'):
            delattr(team, '_bailout_offered_this_crisis')
        
        # Threshold 1: < 20 weeks (140 ticks) - Warning
        if 135 < cash_runway < 140:  # Narrow window to avoid spam
            # Create notification for player team financial warning
            if team == state.player_team:
                try:
                    import plugins.ftb_notifications as ftb_notif
                    ftb_notif.create_notification(
                        category='financial',
                        title=f"💰 Financial Warning",
                        message=f"{team.name} has {cash_runway/7:.1f} weeks of cash remaining. Monitor burn rate carefully.",
                        priority=70,
                        metadata={'cash_runway_weeks': cash_runway/7, 'cash': team.budget.cash},
                        db_path=getattr(state, 'state_db_path', None)
                    )
                except Exception as e:
                    _dbg(f"[FTB] Failed to create financial warning notification: {e}")
            
            events.append(SimEvent(
                event_type="pressure",
                category="economic_warning",
                ts=state.tick,
                priority=70.0,
                severity="warning",
                data={
                    'team': team.name,
                    'cash_runway_weeks': cash_runway / 7,
                    'cash': team.budget.cash,
                    'message': 'Cash reserves declining - monitor burn rate carefully'
                }
            ))
        
        # Threshold 2: < 10 weeks (70 ticks) - Hiring Freeze
        if cash_runway < 70 and not hasattr(team, '_hiring_freeze_active'):
            team._hiring_freeze_active = True
            
            # Create critical financial notification for player team
            if team == state.player_team:
                try:
                    import plugins.ftb_notifications as ftb_notif
                    ftb_notif.create_notification(
                        category='financial',
                        title=f"🚨 CRITICAL: Low Cash Reserves!",
                        message=f"{team.name} has only {cash_runway/7:.1f} weeks of cash left. Hiring freeze in effect!",
                        priority=95,
                        metadata={'cash_runway_weeks': cash_runway/7, 'cash': team.budget.cash},
                        db_path=getattr(state, 'state_db_path', None)
                    )
                except Exception as e:
                    _dbg(f"[FTB] Failed to create critical financial notification: {e}")
            
            events.append(SimEvent(
                event_type="consequence",
                category="hiring_freeze",
                ts=state.tick,
                priority=85.0,
                severity="major",
                data={
                    'team': team.name,
                    'cash_runway_weeks': cash_runway / 7,
                    'cash': team.budget.cash,
                    'message': 'Hiring freeze imposed - all recruitment actions blocked'
                }
            ))
        elif cash_runway >= 70 and hasattr(team, '_hiring_freeze_active'):
            # Lift hiring freeze if runway improves
            delattr(team, '_hiring_freeze_active')
        
        # Threshold 3: < 5 weeks (35 ticks) - Forced Development Cancellation
        if cash_runway < 35 and not hasattr(team, '_dev_cancelled'):
            team._dev_cancelled = True
            # Cancel all pending developments for this team
            cancelled_count = 0
            for dev in state.pending_developments[:]:
                if dev.get('team_name') == team.name:
                    state.pending_developments.remove(dev)
                    cancelled_count += 1
            
            if cancelled_count > 0:
                events.append(SimEvent(
                    event_type="consequence",
                    category="development_cancellation",
                    ts=state.tick,
                    priority=90.0,
                    severity="critical",
                    data={
                        'team': team.name,
                        'cash_runway_weeks': cash_runway / 7,
                        'developments_cancelled': cancelled_count,
                        'message': f'Cash crisis forces cancellation of {cancelled_count} development projects'
                    }
                ))
        elif cash_runway >= 35 and hasattr(team, '_dev_cancelled'):
            delattr(team, '_dev_cancelled')
        
        # Threshold 4: < 2 weeks (14 ticks) - Fire Sale Decision Required
        if cash_runway < 14 and not hasattr(team, '_fire_sale_triggered'):
            team._fire_sale_triggered = True
            
            # SAFETY CHECK: Skip auto-decisions for player team in human control mode
            is_player_team = state.player_team and team.name == state.player_team.name
            if is_player_team and state.control_mode == 'human':
                _dbg(f"[FTB CASH_CRISIS] ⚠️ BLOCKED: Fire sale decision skipped for player team '{team.name}' in human control mode")
                events.append(SimEvent(
                    event_type="pressure",
                    category="cash_crisis",
                    ts=state.tick,
                    priority=90.0,
                    severity="critical",
                    data={
                        'cash_runway_weeks': cash_runway / 7,
                        'message': f'CRITICAL: Team {team.name} cash crisis! Manual intervention required.'
                    }
                ))
                return events  # Exit early, don't create auto-fire sale decision
            
            # Create fire sale decision - focus on selling facilities (NOT firing staff)
            options = []
            
            # REMOVED: Firing staff during cash crisis is counterproductive
            # - Firing costs money (severance, contract buyouts)
            # - Team is already broke, can't afford more expenses
            # - Better to sell facilities which generate immediate cash
            
            # Offer multiple facility sales based on what team has
            sellable_facilities = []
            
            # Prioritize high-value Formula Z facilities first
            z_tier_facilities = [
                ('wind_tunnel_advanced', 'Advanced Wind Tunnel'),
                ('cfd_advanced', 'Advanced CFD System'),
                ('talent_pipeline', 'Talent Pipeline'),
                ('redundant_infrastructure', 'Redundant Infrastructure'),
            ]
            for fac_key, fac_name in z_tier_facilities:
                if fac_key in team.infrastructure and team.infrastructure.get(fac_key, 0) >= 10:
                    unlock_key = f"{fac_key}_unlocked"
                    if team.infrastructure.get(unlock_key, False):
                        quality = team.infrastructure[fac_key]
                        # Estimate recovery
                        base_cost = get_facility_base_cost_per_point(fac_key)
                        est_recovery = (quality / 100.0) * base_cost * ((quality / 50.0) ** 1.4) * 0.40 * 0.85
                        sellable_facilities.append({
                            'key': fac_key,
                            'name': fac_name,
                            'quality': quality,
                            'recovery': est_recovery,
                            'tier': 'Formula Z',
                            'warning': '⚠️ CRITICAL ASSET'
                        })
            
            # Then Formula Y facilities
            y_tier_facilities = [
                ('wind_tunnel_entry', 'Wind Tunnel'),
                ('factory_quality', 'Factory Quality'),
                ('rd_department', 'R&D Department'),
                ('driver_development', 'Driver Development'),
            ]
            for fac_key, fac_name in y_tier_facilities:
                if fac_key in team.infrastructure and team.infrastructure.get(fac_key, 0) >= 10:
                    unlock_key = f"{fac_key}_unlocked"
                    if team.infrastructure.get(unlock_key, False):
                        quality = team.infrastructure[fac_key]
                        base_cost = get_facility_base_cost_per_point(fac_key)
                        est_recovery = (quality / 100.0) * base_cost * ((quality / 50.0) ** 1.4) * 0.45
                        sellable_facilities.append({
                            'key': fac_key,
                            'name': fac_name,
                            'quality': quality,
                            'recovery': est_recovery,
                            'tier': 'Formula Y',
                            'warning': ''
                        })
            
            # Add Formula V facilities if desperate
            if len(sellable_facilities) < 3:
                v_tier_facilities = [
                    ('improved_simulator', 'Improved Simulator'),
                    ('fabrication', 'Fabrication'),
                    ('engineering_roles', 'Engineering Roles'),
                ]
                for fac_key, fac_name in v_tier_facilities:
                    if fac_key in team.infrastructure and team.infrastructure.get(fac_key, 0) >= 10:
                        unlock_key = f"{fac_key}_unlocked"
                        if team.infrastructure.get(unlock_key, False):
                            quality = team.infrastructure[fac_key]
                            base_cost = get_facility_base_cost_per_point(fac_key)
                            est_recovery = (quality / 100.0) * base_cost * ((quality / 50.0) ** 1.4) * 0.50
                            sellable_facilities.append({
                                'key': fac_key,
                                'name': fac_name,
                                'quality': quality,
                                'recovery': est_recovery,
                                'tier': 'Formula V',
                                'warning': ''
                            })
            
            # Create decision options for top 5 facilities
            for fac_data in sellable_facilities[:5]:
                warning_str = f"{fac_data['warning']} " if fac_data['warning'] else ""
                options.append(DecisionOption(
                    id=f"sell_facility_{fac_data['key']}",
                    label=f"Sell {fac_data['name']}",
                    cost=0,
                    description=f"{warning_str}Quality {fac_data['quality']:.0f} ({fac_data['tier']})",
                    consequence_preview=f"+${fac_data['recovery']:,.0f} cash, lose facility benefits"
                ))
            
            # Fallback if no facilities available to sell
            if not options:
                options.append(DecisionOption(
                    id="emergency_loan",
                    label="Emergency Loan",
                    cost=0,
                    description="Last resort high-interest loan",
                    consequence_preview="Emergency funding, high interest debt"
                ))
            
            if options:
                decision = FTBSimulation.create_decision(
                    state,
                    category="fire_sale",
                    prompt="Team on brink of insolvency - immediate action required to raise cash",
                    options=options,
                    deadline_ticks=7,  # 1 week to decide
                    auto_resolve_id=options[0].id
                )
                
                events.append(SimEvent(
                    event_type="pressure",
                    category="decision_required",
                    ts=state.tick,
                    priority=95.0,
                    severity="critical",
                    data={
                        'decision_id': decision.decision_id,
                        'cash_runway_weeks': cash_runway / 7,
                        'message': 'CRITICAL: Fire sale decision required'
                    }
                ))
        elif cash_runway >= 14 and hasattr(team, '_fire_sale_triggered'):
            delattr(team, '_fire_sale_triggered')
        
        # Threshold 5: < 0 cash for 15+ consecutive ticks - Team Fold
        # ML ECONOMIC REALISM: Also check new bankruptcy system
        if team.budget.cash < 0:
            if not hasattr(team, '_negative_cash_ticks'):
                team._negative_cash_ticks = 0
            team._negative_cash_ticks += 1
            
            # Check new ML bankruptcy system first
            if team.budget.check_bankruptcy():
                # Trigger team fold via new bankruptcy system
                fold_event = FTBSimulation.execute_team_fold(
                    state, team, 
                    fold_reason='bankruptcy_ml_economic_realism',
                    championship_position=team.standing_metrics.get('championship_position', 99)
                )
                if fold_event:
                    events.append(fold_event)
            # Check for fold condition (15 ticks = ~2.5 weeks of insolvency)
            elif team._negative_cash_ticks >= 15:
                # Check if team should fold
                should_fold = True
                
                # Player team gets more grace (game over is dramatic, so delay it)
                if team == state.player_team:
                    should_fold = team._negative_cash_ticks >= 21  # 3 weeks for player
                
                # Additional fold triggers
                has_minimal_staff = len(team.drivers) < 1 or len(team.engineers) < 1
                reputation_collapse = team.standing_metrics.get('reputation', 50) < 15
                morale_collapse = team.standing_metrics.get('morale', 50) < 10
                
                if has_minimal_staff or (reputation_collapse and morale_collapse):
                    should_fold = True
                
                if should_fold:
                    # Trigger team fold
                    fold_event = FTBSimulation.execute_team_fold(
                        state, team, 
                        fold_reason='insolvency',
                        championship_position=team.standing_metrics.get('championship_position', 99)
                    )
                    if fold_event:
                        events.append(fold_event)
            elif team._negative_cash_ticks >= 3:
                # Warning at 3 ticks (administration imminent)
                events.append(SimEvent(
                    event_type="outcome",
                    category="administration_warning",
                    ts=state.tick,
                    priority=100.0,
                    severity="critical",
                    data={
                        'team': team.name,
                        'cash': team.budget.cash,
                        'ticks_negative': team._negative_cash_ticks,
                        'message': 'Team in critical insolvency - fold imminent if situation does not improve',
                        'consequence': f'Team will fold in {15 - team._negative_cash_ticks} ticks without cash injection'
                    }
                ))
        else:
            if hasattr(team, '_negative_cash_ticks'):
                team._negative_cash_ticks = 0
        
        return events
    
    @staticmethod
    def execute_team_fold(state: SimState, team: Team, fold_reason: str, championship_position: int = 99) -> Optional[SimEvent]:
        """
        Execute team fold/collapse - removes team from competition and archives to history.
        Returns fold event if successful, None if fold is prevented (e.g., player team).
        """
        import sqlite3
        import json
        
        # Prevent folding the player team (this would be game over)
        if team == state.player_team:
            _dbg(f"[FTB] Player team {team.name} reached fold condition - triggering game over state")
            # TODO: Implement proper game over handling
            return SimEvent(
                event_type="outcome",
                category="game_over_insolvency",
                ts=state.tick,
                priority=100.0,
                severity="critical",
                data={
                    'team': team.name,
                    'fold_reason': fold_reason,
                    'message': f'Game Over: {team.name} has collapsed due to insolvency'
                }
            )
        
        # Archive team to folded_teams table
        team_id = f"TEAM_{state.seed}_{hash(team.name) % 100000}"
        seasons_active = getattr(team, 'seasons_active', 1)
        
        # ML TRAINING: Log failed team outcome
        if hasattr(state, 'state_db_path') and state.state_db_path and hasattr(team, 'team_id'):
            try:
                from plugins.ftb_state_db import log_team_outcome
                
                starting_budget = getattr(team, '_season_start_budget', 0.0)
                
                log_team_outcome(
                    db_path=state.state_db_path,
                    team_id=team.team_id,
                    team_name=team.name,
                    season=state.season_number,
                    championship_position=championship_position,
                    total_points=0.0,  # Folded teams get 0 points
                    starting_budget=starting_budget,
                    ending_budget=team.budget.cash,
                    survival_flag=False,
                    folded_tick=state.tick,
                    seasons_survived=seasons_active
                )
            except Exception as e:
                _dbg(f"[FTB ML] Warning: Failed to log team fold outcome: {e}")
        
        try:
            db_path = getattr(state, 'state_db_path', None)
            if db_path:
                conn = sqlite3.connect(db_path)
                cursor = conn.cursor()
                
                # Archive to folded_teams
                metadata = {
                    'tier': team.tier,
                    'ownership_type': team.ownership_type,
                    'principal': team.principal_name,
                    'bailout_history': getattr(team, '_bailout_history', [])
                }
                
                cursor.execute("""
                    INSERT INTO folded_teams 
                    (id, team_name, fold_tick, fold_season, final_budget_cash, final_reputation, 
                     fold_reason, championship_position, seasons_active, metadata_json)
                    VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?)
                """, (
                    team_id,
                    team.name,
                    state.tick,
                    getattr(state, 'season', 1),
                    team.budget.cash,
                    team.standing_metrics.get('reputation', 0),
                    fold_reason,
                    championship_position,
                    seasons_active,
                    json.dumps(metadata)
                ))
                
                conn.commit()
                conn.close()
                _dbg(f"[FTB] Team {team.name} archived to folded_teams table")
        except Exception as e:
            _dbg(f"[FTB] Error archiving folded team: {e}")
        
        # Release staff and drivers to market
        released_staff = []
        for driver in team.drivers[:]:
            driver.is_free_agent = True
            driver.team_name = None
            driver.former_team_folded = True
            released_staff.append(('Driver', driver.name))
        
        for engineer in team.engineers[:]:
            engineer.is_free_agent = True
            engineer.team_name = None
            engineer.former_team_folded = True
            released_staff.append(('Engineer', engineer.name))
        
        for mechanic in team.mechanics[:]:
            mechanic.is_free_agent = True
            mechanic.team_name = None
            mechanic.former_team_folded = True
            released_staff.append(('Mechanic', mechanic.name))
        
        # Remove all sponsors
        if team.name in state.sponsorships:
            del state.sponsorships[team.name]
        if team.name in state.pending_sponsor_offers:
            del state.pending_sponsor_offers[team.name]
        
        # Mark team as folded (don't remove from league yet, that happens in cleanup)
        team.status = 'folded'
        team.folded_tick = state.tick
        
        # Schedule new team creation to fill grid slot
        if not hasattr(state, '_teams_to_spawn'):
            state._teams_to_spawn = []
        state._teams_to_spawn.append({
            'tier': team.tier,
            'replaced_team_name': team.name,
            'spawn_after_tick': state.tick + 90  # Spawn new team after 90 ticks
        })
        
        # Create fold event
        fold_event = SimEvent(
            event_type="consequence",
            category="team_fold",
            ts=state.tick,
            priority=100.0,
            severity="critical",
            data={
                'team': team.name,
                'tier': team.tier,
                'fold_reason': fold_reason,
                'championship_position': championship_position,
                'seasons_active': seasons_active,
                'final_cash': team.budget.cash,
                'final_reputation': team.standing_metrics.get('reputation', 0),
                'released_staff': released_staff,
                'message': f'{team.name} has folded due to {fold_reason} - grid slot will be filled by new entrant'
            }
        )
        
        _dbg(f"[FTB] Team {team.name} (Tier {team.tier}) has folded: {fold_reason}")
        return fold_event
    
    @staticmethod
    def spawn_new_team(state: SimState, tier: int, replaced_team_name: str = None) -> Optional[Team]:
        """
        Spawn a new team to fill a grid slot (typically after a fold).
        Returns the new team if successful.
        """
        import random
        from plugins.ftb_names import generate_team_name
        
        # Generate team name (avoid collision with existing teams)
        existing_names = [t.name for league in state.leagues.values() for t in league.teams]
        new_name = None
        attempts = 0
        while not new_name or new_name in existing_names:
            seed_offset = state.tick + attempts
            new_name = generate_team_name(state.seed + seed_offset, tier)
            attempts += 1
            if attempts > 100:
                _dbg(f"[FTB] Failed to generate unique team name after 100 attempts")
                return None
        
        # Create new team
        new_team = Team(new_name)
        new_team.tier = tier
        new_team.entry_season = getattr(state, 'season', 1)
        new_team.entry_tick = state.tick
        if replaced_team_name:
            new_team.replaced_team_id = replaced_team_name
        
        # Set ownership type (varied archetypes)
        rng = random.Random(state.seed + state.tick + hash(new_name))
        archetype_roll = rng.random()
        if archetype_roll < 0.30:
            new_team.ownership_type = "cash_rich_startup"
            budget_percentile = 0.65  # Well-funded but inexperienced
        elif archetype_roll < 0.55:
            new_team.ownership_type = "family_funded"
            budget_percentile = 0.50  # Median budget
        elif archetype_roll < 0.75:
            new_team.ownership_type = "investor_group"
            budget_percentile = 0.60  # Above median
        elif archetype_roll < 0.90:
            new_team.ownership_type = "scrappy_independent"
            budget_percentile = 0.35  # Below median but ambitious
        else:
            new_team.ownership_type = "manufacturer_works"
            budget_percentile = 0.75  # Top quartile (manufacturer backing)
        
        # Set starting budget based on tier and archetype
        tier_budget_ranges = {
            1: (40000, 130000),
            2: (200000, 800000),
            3: (1500000, 10000000),
            4: (15000000, 60000000),
            5: (80000000, 250000000)
        }
        min_budget, max_budget = tier_budget_ranges.get(tier, (100000, 500000))
        starting_budget = int(min_budget + (max_budget - min_budget) * budget_percentile)
        
        # Deduct entry fee (20-30% of tier median)
        entry_fee_pct = 0.20 + rng.random() * 0.10
        entry_fee = int((min_budget + max_budget) / 2 * entry_fee_pct)
        new_team.budget.cash = starting_budget - entry_fee
        
        # Set reputation (new entrant)
        new_team.standing_metrics['reputation'] = 30 + rng.randint(0, 15)  # 30-45
        new_team.standing_metrics['legitimacy'] = 25 + rng.randint(0, 20)  # 25-45
        new_team.standing_metrics['morale'] = 60 + rng.randint(0, 20)  # 60-80 (optimistic new team)
        
        # Set league
        # Find league matching tier
        target_league = None
        for league in state.leagues.values():
            if league.tier == tier:
                target_league = league
                break
        
        if not target_league:
            _dbg(f"[FTB] Could not find league for tier {tier}, cannot spawn team")
            return None
        
        new_team.league_id = target_league.league_id
        
        # Generate starter sponsors
        if ftb_sponsors:
            starter_count = 2 if tier <= 2 else 3
            starter_offers = generate_sponsor_offers(state, new_team, rng, count=starter_count)
            
            # Auto-accept starter sponsors
            if new_team.name not in state.sponsorships:
                state.sponsorships[new_team.name] = []
            
            for offer in starter_offers:
                offer.signed_tick = state.tick
                offer.seasons_active = 0
                state.sponsorships[new_team.name].append(offer)
        
        # Generate starter staff (minimal crew)
        # TODO: Flesh this out with actual staff generation
        # For now, just create basic placeholders
        new_team.principal_name = f"{new_name} Owner"
        
        # Add to league
        target_league.teams.append(new_team)
        
        _dbg(f"[FTB] Spawned new team: {new_name} (Tier {tier}, {new_team.ownership_type}, ${new_team.budget.cash:,})")
        
        return new_team
    
    @staticmethod
    def infer_role_and_expectations(state: SimState, team: Team) -> Dict[str, Any]:
        """Numerical inference from budget, resources, history"""
        # Find team's league
        team_league = None
        for league in state.leagues.values():
            if team in league.teams:
                team_league = league
                break
        
        if not team_league:
            # Default for unassigned teams
            return {
                "role": "survivor",
                "expected_range": (8, 12),
                "points_target": 10,
                "patience_weeks": 20,
                "ownership_sensitivity": 1.0
            }
        
        # Calculate budget percentile within league
        league_budgets = [t.budget.cash for t in team_league.teams]
        league_budgets.sort()
        team_budget_rank = league_budgets.index(team.budget.cash) if team.budget.cash in league_budgets else len(league_budgets) // 2
        budget_percentile = team_budget_rank / max(1, len(league_budgets) - 1)
        
        # Calculate recent race average (last 5 races)
        recent_positions = []
        for event in reversed(state.event_history[-50:]):
            if event.category == 'race_result' and event.data.get('team') == team.name:
                pos = event.data.get('position', 0)
                if pos > 0:
                    recent_positions.append(pos)
                if len(recent_positions) >= 5:
                    break
        
        avg_finish = sum(recent_positions) / len(recent_positions) if recent_positions else len(team_league.teams) / 2
        
        # Calculate infrastructure quality score (0-100)
        infra_score = 0.0
        if team.infrastructure:
            wt_quality = team.infrastructure.get('wind_tunnel_quality', 0)
            sim_quality = team.infrastructure.get('simulator_quality', 0)
            factory_quality = team.infrastructure.get('factory_quality', 0)
            infra_score = (wt_quality * 0.4 + sim_quality * 0.3 + factory_quality * 0.3)
        
        # Calculate championship position percentile
        champ_percentile = 0.5  # Default mid-pack
        if team.name in team_league.championship_table:
            teams_sorted = sorted(team_league.championship_table.items(), key=lambda x: x[1], reverse=True)
            team_champ_rank = next((i for i, (name, _) in enumerate(teams_sorted) if name == team.name), len(teams_sorted) // 2)
            champ_percentile = team_champ_rank / max(1, len(teams_sorted) - 1)
        
        # Composite role score (0-100): higher = better expected performance
        role_score = (
            budget_percentile * 40 +  # Budget is primary driver
            (1.0 - (avg_finish / len(team_league.teams))) * 30 +  # Results matter
            (infra_score / 100.0) * 20 +  # Infrastructure supports development
            (1.0 - champ_percentile) * 10  # Championship position
        )
        
        # Map role_score to role bands
        num_teams = len(team_league.teams)
        if role_score >= 80:
            role = "favorite"
            expected_range = (1, 3)
            points_target = num_teams * 18  # Expect consistent podiums
            patience_weeks = 12
            ownership_sensitivity = 1.5
        elif role_score >= 60:
            role = "aspirant"
            expected_range = (3, 6)
            points_target = num_teams * 10
            patience_weeks = 16
            ownership_sensitivity = 1.3
        elif role_score >= 40:
            role = "contender"
            expected_range = (5, 10)
            points_target = num_teams * 5
            patience_weeks = 20
            ownership_sensitivity = 1.1
        elif role_score >= 25:
            role = "survivor"
            expected_range = (8, 12)
            points_target = num_teams * 2
            patience_weeks = 24
            ownership_sensitivity = 0.9
        else:
            role = "backmarker"
            expected_range = (10, num_teams)
            points_target = max(5, num_teams)
            patience_weeks = 30
            ownership_sensitivity = 0.7
        
        # Formula Z pressure amplification
        if team_league.tier == 5:
            patience_weeks = int(patience_weeks * 0.5)
            ownership_sensitivity *= 1.5
            # Tighten ranges
            mid = (expected_range[0] + expected_range[1]) // 2
            spread = max(1, (expected_range[1] - expected_range[0]) // 2)
            expected_range = (mid - spread, mid + spread)
        
        return {
            "role": role,
            "expected_range": expected_range,
            "points_target": points_target,
            "patience_weeks": patience_weeks,
            "ownership_sensitivity": ownership_sensitivity
        }
    
    @staticmethod
    def update_standing_metrics(state: SimState, team: Team, results: Dict, role: str) -> List[SimEvent]:
        """
        Time × Results × Role continuous update with hard gates and threshold triggers.
        Returns events triggered by metric thresholds.
        """
        events = []
        
        # Passive decay
        for metric in team.standing_metrics:
            team.standing_metrics[metric] *= 0.999  # Slow continuous decay
            team.standing_metrics[metric] = max(0, min(100, team.standing_metrics[metric]))
        
        # Results impact (simplified)
        if 'race_position' in results:
            position = results['race_position']
            if position <= 3:
                team.standing_metrics['reputation'] += 0.5
            elif position <= 10:
                team.standing_metrics['reputation'] += 0.1
        
        # Wire race results to standing metrics
        # Parse recent race_result events from event history
        recent_positions = []
        for event in state.event_history[-10:]:  # Check last 10 events
            if event.category == 'race_result':
                event_team = event.data.get('team', '')
                position = event.data.get('position', 0)
                
                # Only update if this event is for the current team
                if event_team == team.name and position > 0:
                    recent_positions.append(position)
                    
                    # Update media_standing based on finish position
                    if position <= 3:
                        team.standing_metrics['media_standing'] += 1.5
                    elif position <= 7:
                        team.standing_metrics['media_standing'] += 0.5
                    elif position <= 10:
                        team.standing_metrics['media_standing'] -= 0.2
                    else:
                        team.standing_metrics['media_standing'] -= 0.8
                    
                    # Update ownership_confidence (skip for self-owned teams)
                    if getattr(team, 'ownership_type', 'hired_manager') != 'self_owned':
                        if position <= 3:
                            team.standing_metrics['ownership_confidence'] += 0.05
                        elif position >= 11:
                            team.standing_metrics['ownership_confidence'] -= 0.02
        
        # Calculate legitimacy dynamically
        # Find budget percentile
        budget_percentile = 50.0  # Default
        league_for_team = None
        for league in state.leagues.values():
            if team in league.teams:
                league_for_team = league
                budgets = sorted([t.budget.cash for t in league.teams])
                if team.budget.cash in budgets:
                    rank = budgets.index(team.budget.cash)
                    budget_percentile = (rank / max(1, len(budgets) - 1)) * 100
                break
        
        # Average finish position for last 5 races
        avg_finish = sum(recent_positions[-5:]) / len(recent_positions[-5:]) if recent_positions else 10
        num_teams = len(league_for_team.teams) if league_for_team else 16
        finish_score = max(0, 100 * (1 - avg_finish / num_teams))
        
        # Years in tier (approximation from season number)
        years_in_tier = min(3, state.season_number)
        
        # Championship position score
        champ_score = 50.0
        if league_for_team and team.name in league_for_team.championship_table:
            teams_sorted = sorted(league_for_team.championship_table.items(), key=lambda x: x[1], reverse=True)
            team_rank = next((i for i, (name, _) in enumerate(teams_sorted) if name == team.name), len(teams_sorted) // 2)
            champ_score = max(0, 100 * (1 - team_rank / max(1, len(teams_sorted))))
        
        # Composite legitimacy calculation
        new_legitimacy = (
            budget_percentile * 0.3 +
            finish_score * 0.4 +
            (years_in_tier * 10) * 0.2 +
            champ_score * 0.1
        )
        team.standing_metrics['legitimacy'] = new_legitimacy
        
        # Morale decay when cash runway < 10 weeks
        cash_runway = FTBSimulation.calculate_cash_runway(team)
        if cash_runway < 70:  # 10 weeks = 70 ticks
            team.standing_metrics['morale'] -= 0.5
        
        # Clamp all values
        for metric in team.standing_metrics:
            team.standing_metrics[metric] = max(0, min(100, team.standing_metrics[metric]))
        
        # ============================================================
        # THRESHOLD-TRIGGERED EVENTS (Hard Gates)
        # ============================================================
        
        # Only generate these events for player team to avoid spam
        if team != state.player_team:
            return events
        
        ownership_conf = team.standing_metrics['ownership_confidence']
        legitimacy = team.standing_metrics['legitimacy']
        reputation = team.standing_metrics['reputation']
        media_standing = team.standing_metrics['media_standing']
        morale = team.standing_metrics['morale']
        political_capital = team.standing_metrics.get('political_capital', 50.0)
        
        # Ownership Confidence Thresholds
        if ownership_conf < 20 and ownership_conf > 18:  # Small window to avoid spam
            events.append(SimEvent(
                event_type="pressure",
                category="ownership_ultimatum",
                ts=state.tick,
                priority=95.0,
                severity="critical",
                data={
                    'team': team.name,
                    'ownership_confidence': ownership_conf,
                    'message': 'Ownership demands immediate improvement or face termination',
                    'expected_results': 'P8+ in next 3 races'
                }
            ))
        elif ownership_conf < 10:
            events.append(SimEvent(
                event_type="consequence",
                category="forced_asset_sale",
                ts=state.tick,
                priority=90.0,
                severity="major",
                data={
                    'team': team.name,
                    'ownership_confidence': ownership_conf,
                    'asset': 'wind_tunnel_quality',
                    'degradation': -5,
                    'cash_injection': 200000,
                    'message': 'Ownership forces sale of infrastructure to raise cash'
                }
            ))
            # Apply the forced sale
            if 'wind_tunnel_quality' in team.infrastructure:
                team.infrastructure['wind_tunnel_quality'] = max(0, team.infrastructure['wind_tunnel_quality'] - 5)
                team.budget.cash += 200000
        
        # Morale Thresholds
        if morale < 30 and morale > 28:
            events.append(SimEvent(
                event_type="pressure",
                category="staff_morale_crisis",
                ts=state.tick,
                priority=80.0,
                severity="major",
                data={
                    'team': team.name,
                    'morale': morale,
                    'message': 'Staff morale at critical levels - performance penalties active',
                    'penalty': -5
                }
            ))
        
        if morale < 15:
            # Risk of staff resignation
            rng = state.get_rng("morale", state.tick)
            all_staff = team.drivers + team.engineers + team.mechanics
            staff_to_resign = []  # Track who's resigning to avoid modifying lists during iteration
            
            for staff in all_staff:
                if rng.random() < 0.05:  # 5% chance per staff member
                    staff_to_resign.append(staff)
                    events.append(SimEvent(
                        event_type="consequence",
                        category="staff_resignation",
                        ts=state.tick,
                        priority=85.0,
                        severity="critical",
                        data={
                            'team': team.name,
                            'entity_name': staff.name,
                            'entity_type': type(staff).__name__,
                            'morale': morale,
                            'message': f'{staff.name} resigned due to poor working conditions'
                        }
                    ))
            
            # Actually remove resigned staff from the team
            for staff in staff_to_resign:
                if staff in team.drivers:
                    team.drivers.remove(staff)
                    team.budget.remove_staff_salary(staff.name)
                elif staff in team.engineers:
                    team.engineers.remove(staff)
                    team.budget.remove_staff_salary(staff.name)
                elif staff in team.mechanics:
                    team.mechanics.remove(staff)
                    team.budget.remove_staff_salary(staff.name)
                
                # Remove contract if exists
                if hasattr(staff, 'entity_id') and staff.entity_id in state.contracts:
                    del state.contracts[staff.entity_id]
                
                # Add to free agent pool with reduced asking salary (fired status)
                per_tick_salary = estimate_salary_expectation(staff, team_tier=team.tier, fired=True)
                asking_salary = per_tick_salary * 365  # Annual salary
                state.add_to_free_agent_pool(staff, "resigned", asking_salary)
            
            # Normalize roster if anyone resigned
            if staff_to_resign:
                team.normalize_roster()
        
        # Media Standing Rewards/Penalties
        if media_standing > 70 and media_standing < 72:  # One-time windfall check
            events.append(SimEvent(
                event_type="outcome",
                category="sponsorship_windfall",
                ts=state.tick,
                priority=75.0,
                severity="info",
                data={
                    'team': team.name,
                    'media_standing': media_standing,
                    'bonus': 50000,
                    'message': 'Strong media presence attracts surprise sponsor bonus'
                }
            ))
            team.budget.cash += 50000
        
        if media_standing < 30:
            events.append(SimEvent(
                event_type="consequence",
                category="media_blackout",
                ts=state.tick,
                priority=60.0,
                severity="info",
                data={
                    'team': team.name,
                    'media_standing': media_standing,
                    'message': 'Media interest wanes - reduced coverage and sponsor visibility'
                }
            ))
        
        # Reputation Effects on Hiring Costs
        # (Implementation note: this will be checked in Action.hire_driver/hire_engineer legality)
        
        return events
    
    @staticmethod
    def generate_opportunities(state: SimState) -> List[SimEvent]:
        """Contract expiries, job board updates"""
        events = []
        rng = state.get_rng("opportunities", state.tick)
        
        # Job vacancy creation (15% chance per tick)
        if rng.random() < 0.15:
            # Find underperforming AI teams (legitimacy < 40 or low standing metrics)
            struggling_teams = [
                t for t in state.ai_teams 
                if t.standing_metrics.get('legitimacy', 50) < 40 
                or t.standing_metrics.get('reputation', 50) < 35
            ]
            
            if struggling_teams:
                team = rng.choice(struggling_teams)
                
                # Determine role (weighted toward driver/engineer)
                role_weights = [
                    ('Driver', 0.4),
                    ('Engineer', 0.3),
                    ('Team_Principal', 0.2),
                    ('Strategist', 0.1)
                ]
                role = rng.choices(
                    [r for r, w in role_weights],
                    weights=[w for r, w in role_weights]
                )[0]
                
                # Find team's tier name
                tier = team.tier_name if hasattr(team, 'tier_name') else "grassroots"
                
                expectation_band = rng.choices(
                    ["low", "mid", "high"],
                    weights=[0.4, 0.4, 0.2]
                )[0]
                
                # Create job listing
                job = JobListing(
                    team=team,
                    team_name=team.name,
                    role=role.replace("_", " "),
                    tier=tier,
                    expectation_band=expectation_band,
                    patience_profile=rng.uniform(0.3, 0.8),
                    risk_profile=rng.uniform(0.2, 0.8),
                    created_tick=state.tick
                )
                
                state.job_board.vacancies.append(job)
                
                events.append(SimEvent(
                    event_type="opportunity",
                    category="job_listing",
                    ts=state.tick,
                    priority=50.0,
                    severity="info",
                    data={
                        'role': role,
                        'team': team.name,
                        'tier': tier
                    }
                ))
        
        # Job vacancy removal (5% chance per tick per vacancy)
        vacancies_to_remove = []
        for job in state.job_board.vacancies:
            if rng.random() < 0.05:
                vacancies_to_remove.append(job)
                
                events.append(SimEvent(
                    event_type="opportunity",
                    category="job_removed",
                    ts=state.tick,
                    priority=20.0,
                    severity="info",
                    data={
                        'role': job.role,
                        'team': job.team_name,
                        'reason': 'position filled'
                    }
                ))
        
        for job in vacancies_to_remove:
            state.job_board.vacancies.remove(job)
        
        return events
    
    @staticmethod
    def create_decision(state: SimState, category: str, prompt: str, options: List[DecisionOption], 
                       deadline_ticks: int = 20, auto_resolve_id: str = None) -> DecisionEvent:
        """Create a new decision event and add to pending decisions"""
        decision_id = f"decision_{state.tick}_{category}"
        auto_id = auto_resolve_id or options[0].id  # Default to first option
        
        decision = DecisionEvent(
            decision_id=decision_id,
            category=category,
            prompt=prompt,
            options=options,
            deadline_tick=state.tick + deadline_ticks,
            auto_resolve_option_id=auto_id,
            created_tick=state.tick,
            resolved=False
        )
        
        state.pending_decisions.append(decision)
        return decision
    
    @staticmethod
    def resolve_decision(state: SimState, decision_id: str, chosen_option_id: str) -> List[SimEvent]:
        """Resolve a decision and apply its consequences"""
        events = []
        
        # Find the decision
        decision = next((d for d in state.pending_decisions if d.decision_id == decision_id), None)
        if not decision or decision.resolved:
            return events
        
        # Mark as resolved
        decision.resolved = True
        decision.chosen_option_id = chosen_option_id
        
        # Find the chosen option
        chosen_option = next((opt for opt in decision.options if opt.id == chosen_option_id), None)
        if not chosen_option:
            return events
        
        # Log decision to history
        if state.state_db_path:
            try:
                import json
                from plugins import ftb_state_db
                
                decision_record = {
                    'decision_id': decision_id,
                    'tick': state.tick,
                    'season': state.season_number,
                    'game_day': state.sim_day_of_year,
                    'category': decision.category,
                    'decision_text': decision.prompt,
                    'options_json': json.dumps([{'id': opt.id, 'label': opt.label, 'cost': opt.cost, 'description': opt.description} 
                                               for opt in decision.options]),
                    'chosen_option_id': chosen_option_id,
                    'chosen_option_label': chosen_option.label,
                    'immediate_cost': chosen_option.cost,
                    'rationale': None,  # Will be populated by delegate AI if applicable
                    'resolved_by': 'player' if state.control_mode == 'human' else 'delegate'
                }
                
                ftb_state_db.write_decision_history(state.state_db_path, decision_record)
            except Exception as e:
                _dbg(f"[FTB] Warning: Could not log decision to history: {e}")
        
        # Apply costs
        if state.player_team and chosen_option.cost > 0:
            state.player_team.budget.cash -= chosen_option.cost
            
            # Log transaction for decision cost
            state.log_transaction(
                type="expense",
                category="decision",
                amount=chosen_option.cost,
                description=f"Decision: {chosen_option.label}",
                balance_after=state.player_team.budget.cash,
                metadata={'decision_id': decision_id, 'category': decision.category}
            )
        
        # Emit resolution event
        events.append(SimEvent(
            event_type="outcome",
            category=f"decision_resolved_{decision.category}",
            ts=state.tick,
            priority=85.0,
            severity="major",
            data={
                'decision_id': decision_id,
                'category': decision.category,
                'chosen_option': chosen_option.label,
                'cost': chosen_option.cost,
                'message': f'Decision made: {chosen_option.label}'
            }
        ))
        
        # Apply specific consequence logic based on category
        consequence_events = FTBSimulation._apply_decision_consequences(state, decision.category, chosen_option_id)
        events.extend(consequence_events)
        
        return events
    
    @staticmethod
    def _apply_decision_consequences(state: SimState, category: str, option_id: str) -> List[SimEvent]:
        """Apply specific consequences for different decision types"""
        events = []
        team = state.player_team
        if not team:
            return events
        
        # Ownership Ultimatum
        if category == "ownership_ultimatum":
            if option_id == "accept_terms":
                team.standing_metrics['reputation'] = max(0, team.standing_metrics['reputation'] - 10)
                team.standing_metrics['ownership_confidence'] = 60.0  # Reset to stable level
            elif option_id == "seek_investor":
                team.budget.cash += 100000
                team.standing_metrics['ownership_confidence'] = 55.0
                # TODO: Add debt tracking
            elif option_id == "resign":
                # TODO: Trigger job search or game over
                pass
        
        # Fire Sale - emergency facility liquidation
        elif category == "fire_sale":
            # REMOVED: Firing staff during fire sale (economically backwards)
            # Fire sales should focus on selling facilities to raise immediate cash
            # Firing staff costs money (severance/buyouts) when you're already broke
            
            if option_id.startswith("sell_facility_"):
                # Extract facility key from option_id
                facility_key = option_id.replace("sell_facility_", "")
                result = team.sell_facility(facility_key)
                if result['success']:
                    # Log major infrastructure sales
                    if result['tier'] >= 4:
                        state.event_history.append(SimEvent(
                            event_type="team_alert",
                            participant=team.name,
                            description=f"{team.name} forced to sell {facility_key} facility for ${result['recovery_cash']:,.0f}",
                            data={'facility': facility_key, 'tier': result['tier'], 'recovery': result['recovery_cash']}
                        ))
            elif option_id == "emergency_loan":
                # Provide emergency loan with high interest
                loan_amount = 50000  # Enough to survive a few more weeks
                team.budget.cash += loan_amount
                # Track as high-interest debt (simplified)
                if not hasattr(team.budget, 'emergency_debt'):
                    team.budget.emergency_debt = 0
                team.budget.emergency_debt += loan_amount * 1.5  # 50% penalty
                
                events.append(SimEvent(
                    event_type="financial",
                    category="emergency_loan",
                    ts=state.tick,
                    priority=85.0,
                    severity="warning",
                    data={
                        'team': team.name,
                        'loan_amount': loan_amount,
                        'debt_incurred': loan_amount * 1.5,
                        'message': f'{team.name} takes emergency loan of ${loan_amount:,} (total debt: ${loan_amount * 1.5:,})'
                    }
                ))
            else:
                # Unknown fire sale option
                _dbg(f"[FTB] Unknown fire sale option: {option_id}")
        
        # Sponsor Bailout
        elif category == "sponsor_bailout":
            if option_id == "accept_bailout":
                # Find the bailout event to get details
                bailout_event = next((e for e in reversed(state.event_history) 
                                     if e.category == "sponsor_bailout_offer"), None)
                if bailout_event:
                    bailout_amount = bailout_event.data.get('bailout_amount', 0)
                    sponsor_name = bailout_event.data.get('sponsor_name', '')
                    payment_increase = bailout_event.data.get('payment_increase_pct', 20) / 100.0
                    
                    # Apply cash injection
                    team.budget.cash += bailout_amount
                    
                    # Find and update the sponsor
                    if team.name in state.sponsorships:
                        for sponsor in state.sponsorships[team.name]:
                            if sponsor.sponsor_name == sponsor_name:
                                # Mark sponsor as having bailed out
                                sponsor.has_bailed_out = True
                                sponsor.bailout_count = getattr(sponsor, 'bailout_count', 0) + 1
                                
                                # Increase base payment
                                sponsor.base_payment_per_season = int(sponsor.base_payment_per_season * (1 + payment_increase))
                                
                                # Boost confidence
                                sponsor.confidence = min(100.0, sponsor.confidence + 15)
                                
                                # Track team bailout count
                                team._bailout_count = getattr(team, '_bailout_count', 0) + 1
                                
                                # Add narrative tag
                                if not hasattr(team, '_bailout_history'):
                                    team._bailout_history = []
                                team._bailout_history.append({
                                    'sponsor_name': sponsor_name,
                                    'tick': state.tick,
                                    'amount': bailout_amount
                                })
                                
                                events.append(SimEvent(
                                    event_type="outcome",
                                    category="sponsor_bailout_accepted",
                                    ts=state.tick,
                                    priority=90.0,
                                    severity="major",
                                    data={
                                        'sponsor_name': sponsor_name,
                                        'bailout_amount': bailout_amount,
                                        'message': f'{sponsor_name} saves {team.name} with emergency capital injection'
                                    }
                                ))
                                break
            elif option_id == "decline_bailout":
                # No direct consequences, crisis continues
                events.append(SimEvent(
                    event_type="outcome",
                    category="sponsor_bailout_declined",
                    ts=state.tick,
                    priority=75.0,
                    severity="info",
                    data={
                        'message': f'{team.name} declines bailout offer, maintaining full ownership'
                    }
                ))
        
        # Development Risk Choice
        elif category == "development_risk":
            # Store chosen risk profile for use in resolve_development
            # This would be referenced when the development completes
            pass
        
        return events
    
    @staticmethod
    def check_pending_decisions(state: SimState) -> List[SimEvent]:
        """Check for expired decisions and auto-resolve them"""
        events = []
        
        for decision in state.pending_decisions[:]:
            if not decision.resolved and state.tick >= decision.deadline_tick:
                # SAFETY CHECK: Don't auto-resolve decisions for player team in human control mode
                if (state.control_mode == 'human' and 
                    decision.category in ['fire_sale', 'ownership_ultimatum'] and
                    state.player_team):
                    _dbg(f"[FTB DECISIONS] ⚠️ BLOCKED: Auto-resolution of {decision.category} decision blocked for player team in human control mode")
                    # Mark as resolved but don't apply consequences
                    decision.resolved = True
                    events.append(SimEvent(
                        event_type="consequence",
                        category="decision_blocked",
                        ts=state.tick,
                        priority=85.0,
                        severity="warning",
                        data={
                            'decision_id': decision.decision_id,
                            'category': decision.category,
                            'message': f'Player intervention required - {decision.category} decision blocked'
                        }
                    ))
                    continue
                
                # Auto-resolve with default option
                auto_events = FTBSimulation.resolve_decision(
                    state, 
                    decision.decision_id, 
                    decision.auto_resolve_option_id
                )
                events.extend(auto_events)
                
                events.append(SimEvent(
                    event_type="consequence",
                    category="decision_auto_resolved",
                    ts=state.tick,
                    priority=75.0,
                    severity="warning",
                    data={
                        'decision_id': decision.decision_id,
                        'message': 'Decision deadline passed - automatically resolved'
                    }
                ))
        
        # Remove resolved decisions
        state.pending_decisions = [d for d in state.pending_decisions if not d.resolved]
        
        return events
    
    @staticmethod
    def evaluate_action(action: Action, team: Team, state: SimState) -> float:
        """
        Pure numerical action scoring for AI teams and delegated player teams.
        Evaluates multi-dimensional impact: financial, team performance, risk, timeline.
        Principal stats applied via apply_tendency_weights() after base evaluation.
        
        Returns: Base score 0-100 (higher = better action)
        """
        # Financial viability check
        if not action.is_legal(team.budget, team):
            return 0.0
        
        # ML ECONOMIC REALISM: Heavy penalty for bankruptcy-causing actions
        if team.budget.will_cause_bankruptcy(action.cost, state.tick):
            return 0.0  # Never choose actions that lead to forecasted bankruptcy
        
        base_score = 50.0  # Neutral baseline
        
        # Get team context
        cash = team.budget.cash
        budget_ratio = action.cost / max(cash, 1.0) if action.cost > 0 else 0.0
        
        # Additional financial prudence for low-cash situations
        if cash < 100000 and action.cost > 0:
            # Penalize spending when in cash crisis
            crisis_penalty = (100000 - cash) / 10000 * 5  # Up to -50 penalty
            base_score -= crisis_penalty
        
        # ===== ACTION TYPE-SPECIFIC EVALUATION =====
        
        # HIRING ACTIONS
        if action.name.startswith("hire_"):
            role = action.name.replace("hire_", "")
            
            # Need assessment: how urgently do we need this role?
            current_staff = {
                'driver': len(team.drivers),
                'engineer': len(team.engineers),
                'mechanic': len(team.mechanics),
                'strategist': 1 if team.strategist else 0
            }
            
            role_needs = {
                'driver': 2,  # Standard grid size
                'engineer': 3,  # Typical engineering dept
                'mechanic': 4,  # Pit crew minimum
                'strategist': 1
            }
            
            need_urgency = max(0, role_needs.get(role, 0) - current_staff.get(role, 0))
            base_score += need_urgency * 15  # +15 per missing role member
            
            # Financial prudence: penalize if hire costs >20% of cash
            if budget_ratio > 0.2:
                base_score -= (budget_ratio - 0.2) * 100
            
            # Team quality factor: hiring is better when team is weak
            avg_team_rating = team.overall_rating if hasattr(team, 'overall_rating') else 50.0
            if avg_team_rating < 45:
                base_score += 10  # Boost hiring when team needs improvement
                
        # FIRING ACTIONS
        elif action.name.startswith("fire_"):
            role = action.name.replace("fire_", "")
            
            # Find the target entity's rating
            entity_rating = 50.0  # Default
            if role == "driver":
                target = next((d for d in team.drivers if d.name == action.target), None)
                if target:
                    entity_rating = target.overall_rating
            elif role == "engineer":
                target = next((e for e in team.engineers if e.name == action.target), None)
                if target:
                    entity_rating = target.overall_rating
            elif role == "mechanic":
                target = next((m for m in team.mechanics if m.name == action.target), None)
                if target:
                    entity_rating = target.overall_rating
            
            # Score based on underperformance (fire low performers)
            performance_deficit = 50.0 - entity_rating
            base_score += performance_deficit * 0.8  # Higher score if significantly underperforming
            
            # Penalty for firing when team is already thin
            current_count = {
                'driver': len(team.drivers),
                'engineer': len(team.engineers),
                'mechanic': len(team.mechanics)
            }
            
            if current_count.get(role, 0) <= 1:
                base_score -= 30  # Don't fire your last person
                
            # Small financial benefit (save salary)
            base_score += 5  # Firing always saves money
            
        # R&D PROJECTS
        elif action.name == "rd_project":
            # Long-term investment scoring
            base_score = 55.0  # Slightly favorable baseline
            
            # Penalize based on financial strain
            base_score -= budget_ratio * 50
            
            # Boost if team has good infrastructure for R&D
            facilities_quality = sum(team.infrastructure.values()) / max(len(team.infrastructure), 1)
            if facilities_quality > 60:
                base_score += 15
            
            # Boost if car is underdeveloped (big gains possible)
            if team.car and team.car.overall_rating < 55:
                base_score += 12
                
        # UPGRADE PACKAGES
        elif action.name == "purchase_upgrade":
            # Medium-term performance boost
            base_score = 58.0  # Favorable baseline (direct performance gain)
            
            # Financial prudence
            base_score -= budget_ratio * 40
            
            # Boost if team is competitive (upgrades matter more in close fights)
            team_standing = team.standing_metrics.get('championship_position', 10)
            if team_standing <= 5:
                base_score += 10
                
        # PART PURCHASES
        elif action.name == "purchase_part":
            base_score = 52.0
            
            # Check if this part type is needed (missing or obsolete)
            # TODO: Would need part catalog lookup
            base_score -= budget_ratio * 35
            
        # INFRASTRUCTURE UPGRADES
        elif action.name == "upgrade_infrastructure":
            # Very long-term investment
            base_score = 48.0  # Slightly below neutral (long payback period)
            
            # Strong penalty if cash-strapped
            if cash < 100000:
                base_score -= 25
            
            # Boost if infrastructure is poor
            current_infra_avg = sum(team.infrastructure.values()) / max(len(team.infrastructure), 1)
            if current_infra_avg < 40:
                base_score += 20  # High value when infrastructure is weak
            elif current_infra_avg > 70:
                base_score -= 10  # Lower priority when already good
                
        # POACHING (stealing staff from other teams)
        elif action.name == "poach_staff":
            base_score = 45.0  # Risky, expensive, but high reward
            
            # Financial barrier
            base_score -= budget_ratio * 60  # Very expensive
            
            # Tier advantage: poaching works best from lower tiers
            if team.tier <= 3:
                base_score += 15
            
        # CAR DEVELOPMENT (general development spend)
        elif action.name == "develop_car":
            base_score = 55.0  # Generally good action
            
            # Financial prudence
            base_score -= budget_ratio * 45
            
            # Boost if car needs work
            if team.car and team.car.overall_rating < 50:
                base_score += 15
            elif team.car and team.car.overall_rating > 70:
                base_score -= 8  # Diminishing returns
        
        # JOB BOARD APPLICATIONS
        elif action.name == "apply_for_job":
            base_score = 25.0  # Generally risky/disruptive baseline
            
            # Only worthwhile if current situation is bad
            team_morale = team.standing_metrics.get('morale', 50.0)
            if team_morale < 30:
                base_score += 30  # Desperate times
            elif team_morale < 45:
                base_score += 15  # Moderately dissatisfied
            else:
                base_score -= 20  # Content teams shouldn't job hunt
            
            # Financial situation matters
            if cash < 30000:
                base_score += 20  # Need better financial situation
            
            # Check if target job is actually better
            if hasattr(action.target, 'tier'):
                tier_improvement = action.target.tier - team.tier
                base_score += tier_improvement * 25  # Big boost for tier upgrades
            
            # Small cost consideration
            base_score -= budget_ratio * 10
        
        # SPONSOR MANAGEMENT ACTIONS
        elif action.name == "accept_sponsor":
            base_score = 60.0  # Generally positive (income)
            
            # No direct cost, but evaluate the sponsor offer quality
            if isinstance(action.target, int) and team.name in state.pending_sponsor_offers:
                offers = state.pending_sponsor_offers[team.name]
                if action.target < len(offers):
                    sponsor_offer = offers[action.target]
                    
                    # Payment quality relative to budget needs
                    monthly_income = sponsor_offer.base_payment_per_season / 12
                    if cash < 50000:  # Desperate for money
                        base_score += monthly_income / 1000  # Big boost per 1k monthly
                    else:
                        base_score += monthly_income / 2000  # Moderate boost when comfortable
                    
                    # Tier appropriateness (don't accept deals way below tier)
                    if hasattr(sponsor_offer, 'financial_tier'):
                        if sponsor_offer.financial_tier == 'micro' and team.tier >= 3:
                            base_score -= 25  # High-tier teams avoid micro sponsors
                        elif sponsor_offer.financial_tier == 'global' and team.tier <= 2:
                            base_score += 20  # Low-tier teams love premium sponsors
        
        elif action.name == "reject_sponsor":
            base_score = 30.0  # Neutral, but preserves options
            
            # Slightly higher if team already has good sponsors
            current_sponsors = state.sponsorships.get(team.name, [])
            if current_sponsors:
                avg_payment = sum(s.base_payment_per_season for s in current_sponsors) / len(current_sponsors)
                if avg_payment > 100000:  # Well-funded already
                    base_score += 10
        
        elif action.name == "negotiate_renewal":
            base_score = 55.0  # Generally good to retain sponsors
            
            # Evaluate based on sponsor confidence/relationship
            if isinstance(action.target, int) and team.name in state.sponsorships:
                sponsors = state.sponsorships[team.name]
                if action.target < len(sponsors):
                    sponsor = sponsors[action.target]
                    
                    # High confidence sponsors more likely to renew favorably
                    confidence_bonus = (sponsor.confidence - 50.0) / 5.0  # -10 to +10 range
                    base_score += confidence_bonus
                    
                    # Value ongoing relationship
                    base_score += sponsor.seasons_active * 2  # Loyalty bonus
        
        # ===== UNIVERSAL MODIFIERS =====
        
        # Cash crisis penalty: heavily penalize expensive actions when low on cash
        if cash < 50000 and action.cost > 10000:
            base_score -= 20
        
        # Morale factor: spending boosts morale, cutting doesn't
        if action.name.startswith("fire_"):
            base_score -= 5  # Morale cost of firing
        elif action.cost > 0:
            base_score += 2  # Small morale boost from investment
        
        # Clamp final score to valid range
        return max(0.0, min(100.0, base_score))
    
    @staticmethod
    def apply_tendency_weights(score: float, tendencies: AIPrincipal, action: Action, team: Team, state: SimState) -> float:
        """
        Apply principal tendency modifiers to action score.
        This is where manager personality shapes decision-making.
        
        Different stats influence different action types:
        - aggression, risk_tolerance: risky actions, poaching
        - patience, long_term_orientation: R&D, infrastructure
        - financial_discipline, liquidity_conservatism: expensive actions
        - ruthlessness vs staff_loyalty_bias: firing decisions
        - short_term_pressure_response: crisis decisions
        """
        # Get principal stats (all centered at 50.0 = neutral)
        stats = tendencies.current_ratings
        
        # Normalize stats to modifiers (-0.5 to +0.5 range, 0 = neutral)
        def normalize_stat(stat_name: str) -> float:
            return (stats.get(stat_name, 50.0) - 50.0) / 100.0
        
        aggression = normalize_stat('aggression')
        risk = normalize_stat('risk_tolerance')
        patience = normalize_stat('patience')
        long_term = normalize_stat('long_term_orientation')
        financial_discipline = normalize_stat('financial_discipline')
        liquidity = normalize_stat('liquidity_conservatism')
        ruthlessness = normalize_stat('ruthlessness')
        loyalty = normalize_stat('staff_loyalty_bias')
        pressure_handling = normalize_stat('short_term_pressure_response')
        
        # Start with base score
        weighted_score = score
        
        # ===== ACTION TYPE-SPECIFIC TENDENCY WEIGHTING =====
        
        # HIRING: influenced by talent evaluation, financial discipline
        if action.name.startswith("hire_"):
            talent_eval = normalize_stat('talent_evaluation_accuracy')
            
            # High talent evaluation → boost hiring (confident in picks)
            weighted_score *= (1.0 + talent_eval * 0.2)
            
            # Financial discipline reduces hiring score when expensive
            budget_ratio = action.cost / max(team.budget.cash, 1.0)
            if budget_ratio > 0.15:
                weighted_score *= (1.0 - financial_discipline * 0.15)
        
        # FIRING: influenced by ruthlessness vs loyalty, crisis management
        elif action.name.startswith("fire_"):
            # Ruthless managers fire more readily
            weighted_score *= (1.0 + ruthlessness * 0.3)
            
            # Loyal managers resist firing
            weighted_score *= (1.0 - loyalty * 0.25)
            
            # In crisis (low cash), pressure handling matters
            if team.budget.cash < 75000:
                crisis = normalize_stat('crisis_management')
                weighted_score *= (1.0 + crisis * 0.15)
        
        # R&D PROJECTS: influenced by patience, long-term orientation, risk
        elif action.name == "rd_project":
            # Patient, long-term managers favor R&D
            weighted_score *= (1.0 + patience * 0.25)
            weighted_score *= (1.0 + long_term * 0.3)
            
            # Risk-tolerant managers more willing to invest
            weighted_score *= (1.0 + risk * 0.15)
            
            # Conservative financial managers penalize expensive R&D
            weighted_score *= (1.0 - liquidity * 0.2)
        
        # INFRASTRUCTURE: influenced by patience, long-term, financial discipline
        elif action.name == "upgrade_infrastructure":
            # Very long-term investment: patience and long-term orientation critical
            weighted_score *= (1.0 + patience * 0.3)
            weighted_score *= (1.0 + long_term * 0.35)
            
            # Conservative cash management resists large infrastructure spend
            weighted_score *= (1.0 - liquidity * 0.25)
        
        # POACHING: influenced by aggression, risk, political instinct
        elif action.name == "poach_staff":
            # Aggressive managers poach more
            weighted_score *= (1.0 + aggression * 0.4)
            
            # Risk-tolerant managers embrace the gamble
            weighted_score *= (1.0 + risk * 0.3)
            
            # Political skill helps poaching success perception
            political = normalize_stat('political_instinct')
            weighted_score *= (1.0 + political * 0.2)
        
        # UPGRADE PACKAGES: medium-term, influenced by aggression, financial discipline
        elif action.name == "purchase_upgrade":
            # Aggressive managers push for performance upgrades
            weighted_score *= (1.0 + aggression * 0.2)
            
            # Financial discipline moderates spending
            budget_ratio = action.cost / max(team.budget.cash, 1.0)
            if budget_ratio > 0.1:
                weighted_score *= (1.0 - financial_discipline * 0.15)
        
        # PART PURCHASES: influenced by financial discipline, supplier relationship
        elif action.name == "purchase_part":
            supplier_mgmt = normalize_stat('supplier_relationship_management')
            
            # Good supplier relationships boost part purchasing confidence
            weighted_score *= (1.0 + supplier_mgmt * 0.15)
            
            # Financial discipline moderates
            weighted_score *= (1.0 - financial_discipline * 0.1)
        
        # JOB BOARD APPLICATIONS: influenced by ambition, risk tolerance, career opportunism
        elif action.name == "apply_for_job":
            ambition = normalize_stat('ambition')
            career_opportunism = normalize_stat('career_opportunism')
            
            # Ambitious managers more likely to seek new opportunities
            weighted_score *= (1.0 + ambition * 0.4)
            
            # Career opportunists actively job hunt
            weighted_score *= (1.0 + career_opportunism * 0.3)
            
            # Risk tolerance affects willingness to leave stable position
            weighted_score *= (1.0 + risk * 0.25)
            
            # Pressure response: desperate managers more likely to jump ship
            if team.budget.cash < 50000 or team.standing_metrics.get('morale', 50) < 35:
                weighted_score *= (1.0 + (1.0 - pressure_handling) * 0.2)  # Poor pressure handling = panic moves
        
        # SPONSOR MANAGEMENT: influenced by relationship skills, financial acumen
        elif action.name in ["accept_sponsor", "reject_sponsor", "negotiate_renewal"]:
            relationship_mgmt = normalize_stat('relationship_management')
            sponsor_relations = normalize_stat('sponsor_relationship_cultivation')
            negotiation = normalize_stat('negotiation_effectiveness')
            
            # Strong relationship managers better at sponsor decisions
            weighted_score *= (1.0 + relationship_mgmt * 0.2)
            weighted_score *= (1.0 + sponsor_relations * 0.25)
            
            # Negotiation skills particularly important for renewals
            if action.name == "negotiate_renewal":
                weighted_score *= (1.0 + negotiation * 0.3)
            
            # Financial discipline affects acceptance thresholds
            if action.name == "accept_sponsor":
                # Disciplined managers more selective about sponsor quality
                weighted_score *= (1.0 + financial_discipline * 0.15)
            elif action.name == "reject_sponsor":
                # Disciplined managers willing to reject poor deals
                weighted_score *= (1.0 + financial_discipline * 0.1)
        
        # ===== UNIVERSAL TENDENCY OVERLAYS =====
        
        # Short-term pressure response: when in crisis, affects all decisions
        if team.budget.cash < 50000:
            # High pressure handling = calm decisions, low = panic
            weighted_score *= (1.0 + pressure_handling * 0.15)
        
        # Aggression: general bias toward action over inaction
        # Already applied to specific action types above, skip universal modifier
        
        # Clamp final score
        return max(0.0, min(150.0, weighted_score))  # Allow scores to go above 100 after weighting
    
    @staticmethod
    def apply_personality_inflection(base_score: float, principal: 'AIPrincipal', action: Action, team: Team, state: SimState) -> float:
        """
        ML PERSONALITY INFLECTION: Modulate ML baseline scores based on context-activated personality traits.
        Inflections only activate in specific contexts (crisis, competition, youth) for interpretability.
        
        Args:
            base_score: Score from ML policy or rule-based evaluation
            principal: Team principal with personality stats
            action: Action being scored
            team: Team state
            state: Simulation state
        
        Returns:
            Inflected score
        """
        inflected_score = base_score
        
        # Helper to normalize stats 0-100 → 0-1
        def normalize(stat_name):
            return (getattr(principal, stat_name, 50.0) - 50.0) / 50.0
        
        # Helper for sigmoid activation function
        def sigmoid_activation(value, threshold=0.0, sensitivity=10.0):
            """Smooth 0-1 activation centered at threshold"""
            import math
            return 1.0 / (1.0 + math.exp(-sensitivity * (value - threshold)))
        
        # CONTEXT 1: Cash Crisis - activate financial stats
        budget_ratio = team.budget.cash / 100000.0  # Relative to $100k baseline
        if budget_ratio < 0.3:  # Crisis mode
            crisis_activation = sigmoid_activation(0.3 - budget_ratio, threshold=0.0, sensitivity=20.0)
            
            # Conservative principals amplify safe actions during crisis
            if action.cost < 10000:  # Low-cost actions
                financial_discipline = normalize('financial_discipline')
                conservatism = normalize('liquidity_conservatism')
                inflection = 1.0 + (financial_discipline + conservatism) * 0.5 * crisis_activation
                inflected_score *= inflection
            
            # Risk-takers still willing to spend in crisis
            elif action.cost > 50000:  # High-cost actions
                risk_tolerance = normalize('risk_tolerance')
                aggression = normalize('aggression')
                inflection = 1.0 + (risk_tolerance + aggression) * 0.3 * crisis_activation
                inflected_score *= inflection
        
        # CONTEXT 2: Competitive Position - activate risk stats
        championship_pos = team.standing_metrics.get('championship_position', 99)
        if championship_pos <= 3:  # In contention
            competition_activation = sigmoid_activation(3 - championship_pos, threshold=0.0, sensitivity=2.0)
            
            # Aggressive principals amplify bold moves when competing
            if 'hire' in action.name or 'develop' in action.name or 'rd_project' in action.name:
                risk_tolerance = normalize('risk_tolerance')
                aggression = normalize('aggression')
                inflection = 1.0 + (risk_tolerance + aggression) * 0.4 * competition_activation
                inflected_score *= inflection
        
        # CONTEXT 3: Young Team - activate patience/long-term stats
        seasons_active = getattr(team, 'seasons_active', 1)
        if seasons_active < 3:  # New team
            youth_activation = sigmoid_activation(3 - seasons_active, threshold=0.0, sensitivity=1.5)
            
            # Patient principals amplify infrastructure/development when young
            if 'infrastructure' in action.name or 'develop' in action.name or 'rd_project' in action.name:
                patience = normalize('patience')
                long_term = normalize('long_term_orientation')
                inflection = 1.0 + (patience + long_term) * 0.5 * youth_activation
                inflected_score *= inflection
        
        # CONTEXT 4: Roster Quality Gap - activate ruthlessness stats
        roster_quality = team.overall_rating if hasattr(team, 'overall_rating') else 50.0
        # Get median quality for tier (simplified)
        tier_median = {1: 40.0, 2: 45.0, 3: 50.0, 4: 55.0, 5: 60.0}.get(team.tier, 50.0)
        quality_gap = tier_median - roster_quality
        
        if quality_gap > 10:  # Behind the competition
            gap_activation = sigmoid_activation(quality_gap - 10, threshold=0.0, sensitivity=0.5)
            
            # Ruthless principals amplify firing/upgrading when behind
            if 'fire' in action.name:
                ruthlessness = normalize('ruthlessness')
                pressure_response = 1.0 - normalize('short_term_pressure_response')  # Inverse: low pressure = decisive
                inflection = 1.0 + (ruthlessness + pressure_response) * 0.6 * gap_activation
                inflected_score *= inflection
            
            # Loyal principals resist firing even when behind
            elif 'fire' in action.name:
                loyalty_bias = normalize('staff_loyalty_bias')
                inflection = 1.0 - loyalty_bias * 0.4 * gap_activation
                inflected_score *= max(0.1, inflection)  # Don't zero out completely
        
        return inflected_score
    
    @staticmethod
    def ai_team_decide(team: Team, state: SimState) -> Optional[Action]:
        """AI team decision: evaluate + weight + select (with optional ML policy and personality inflection)"""
        # SAFETY CHECK: Never make AI decisions for player team (even if accidentally called)
        if state.player_team and team.team_id == state.player_team.team_id:
            return None
        
        actions = FTBSimulation.get_available_actions(team, state)
        
        if not actions:
            return None
        
        # Check if ML policy is enabled
        use_ml_policy = getattr(state, 'ml_policy_enabled', False)
        ml_policy = getattr(state, '_ml_policy_model', None)
        
        # Evaluate all actions and store scores for ML logging
        scored_actions = []
        action_scores_dict = {}  # For ML logging
        
        if use_ml_policy and ml_policy:
            # ML-based scoring
            try:
                # Encode team state
                team_state = {
                    'budget': float(team.budget.cash),
                    'budget_ratio': float(team.budget.cash / 100000.0),
                    'num_drivers': len(team.drivers),
                    'num_engineers': len(team.engineers),
                    'num_mechanics': len(team.mechanics),
                    'has_strategist': 1 if team.strategist else 0,
                    'tier': team.tier,
                    'championship_position': team.standing_metrics.get('championship_position', 99),
                    'morale': float(team.standing_metrics.get('morale', 50.0)),
                    'reputation': float(team.standing_metrics.get('reputation', 50.0))
                }
                
                # Convert actions to format ML policy expects
                ml_actions = [{'name': a.name, 'cost': a.cost, 'target': a.target} for a in actions]
                
                # Get principal stats if available
                principal_stats = None
                if team.principal:
                    principal_stats = {attr: float(getattr(team.principal, attr, 50.0)) 
                                     for attr in ['financial_discipline', 'risk_tolerance', 'patience']}
                
                # Score actions using ML policy
                ml_scores = ml_policy.score_actions(team_state, ml_actions, principal_stats)
                
                for action, ml_score in zip(actions, ml_scores):
                    score = ml_score
                    # Apply personality inflection to ML scores
                    if team.principal:
                        score = FTBSimulation.apply_personality_inflection(score, team.principal, action, team, state)
                    scored_actions.append((action, score))
                    action_scores_dict[action.name] = float(score)
            
            except Exception as e:
                _dbg(f"[FTB ML] Warning: ML policy failed, falling back to rule-based: {e}")
                use_ml_policy = False  # Fall back to rule-based
        
        if not use_ml_policy:
            # Rule-based scoring (original system)
            for action in actions:
                score = FTBSimulation.evaluate_action(action, team, state)
                if team.principal:
                    score = FTBSimulation.apply_tendency_weights(score, team.principal, action, team, state)
                    # Apply personality inflection to rule-based scores
                    score = FTBSimulation.apply_personality_inflection(score, team.principal, action, team, state)
                scored_actions.append((action, score))
                action_scores_dict[action.name] = float(score)
        
        # Select best
        scored_actions.sort(key=lambda x: x[1], reverse=True)
        best_action = scored_actions[0][0] if scored_actions else None
        
        # ML TRAINING: Log this decision if database is available
        if best_action and hasattr(state, 'state_db_path') and state.state_db_path and team.principal:
            try:
                from plugins.ftb_state_db import log_ai_decision
                
                # Build state vector for ML
                state_vector = {
                    'budget': float(team.budget.cash),
                    'budget_ratio': float(team.budget.cash / 100000.0),  # Normalized to $100k
                    'num_drivers': len(team.drivers),
                    'num_engineers': len(team.engineers),
                    'num_mechanics': len(team.mechanics),
                    'has_strategist': 1 if team.strategist else 0,
                    'tier': team.tier,
                    'championship_position': team.standing_metrics.get('championship_position', 99),
                    'morale': float(team.standing_metrics.get('morale', 50.0)),
                    'reputation': float(team.standing_metrics.get('reputation', 50.0))
                }
                
                # Build action description
                action_chosen = {
                    'name': best_action.name,
                    'cost': float(best_action.cost),
                    'target': str(best_action.target) if best_action.target else None
                }
                
                # Extract principal stats as dict
                principal_stats = {attr: float(getattr(team.principal, attr, 50.0)) 
                                 for attr in ['financial_discipline', 'budget_forecasting_accuracy', 
                                            'talent_evaluation_accuracy', 'risk_tolerance', 'patience',
                                            'ruthlessness', 'aggression', 'long_term_orientation']}
                
                budget_before = float(team.budget.cash)
                
                log_ai_decision(
                    db_path=state.state_db_path,
                    tick=state.tick,
                    season=state.season_number,
                    team_id=team.team_id,
                    team_name=team.name,
                    state_vector=state_vector,
                    action_chosen=action_chosen,
                    action_scores=action_scores_dict,
                    principal_stats=principal_stats,
                    budget_before=budget_before,
                    budget_after=budget_before,  # Will be updated after action applies
                    championship_position=state_vector['championship_position']
                )
            except Exception as e:
                # Don't break simulation if logging fails
                _dbg(f"[FTB ML] Warning: Failed to log AI decision: {e}")
        
        return best_action
    
    @staticmethod
    def get_available_actions(team: Team, state: SimState) -> List[Action]:
        """Enumerate legal actions based on budget, phase, contracts"""
        actions = []
        
        # Hiring actions
        actions.append(Action("hire_driver", cost=50000, target=None))
        actions.append(Action("hire_engineer", cost=30000, target=None))
        
        # Firing actions (one per current employee)
        for driver in team.drivers:
            # Small cost for severance
            actions.append(Action("fire_driver", cost=5000, target=driver.name))
        
        for engineer in team.engineers:
            actions.append(Action("fire_engineer", cost=3000, target=engineer.name))
        
        # Development
        actions.append(Action("develop_car", cost=100000, target=None))
        
        # Part purchasing (Phase 6.5 - player UI)
        if team == state.player_team:
            # Group parts by type and show only latest generation per type
            parts_by_type = {}
            for part in state.parts_catalog.values():
                # Filter by tier access
                if team.tier < part.tier_minimum or team.tier > part.tier_maximum:
                    continue
                # Exclude already owned
                if part.part_id in team.parts_inventory:
                    continue
                # Exclude already equipped
                if part.part_id in [p.part_id for p in team.equipped_parts.values()]:
                    continue
                
                part_type = part.part_type
                if part_type not in parts_by_type:
                    parts_by_type[part_type] = []
                parts_by_type[part_type].append(part)
            
            # For each type, show top 3 newest/best parts
            for part_type, parts_list in parts_by_type.items():
                # Sort by generation descending, then performance
                sorted_parts = sorted(parts_list, key=lambda p: (p.generation, p.performance_score), reverse=True)
                for part in sorted_parts[:3]:  # Show top 3 options per type
                    part_cost = FTBSimulation.calculate_part_cost(part)
                    actions.append(Action('purchase_part', cost=part_cost, target=part.part_id))
            
            # Equip actions for all inventory parts
            for part_id in team.parts_inventory:
                if part_id in state.parts_catalog:
                    actions.append(Action('equip_part', cost=0, target=part_id))
            
            # Upgrade package browsing (Phase 5.6 - player UI)
            for upgrade_id, template in UPGRADE_PACKAGE_CATALOG.items():
                # Filter by tier availability
                if team.tier not in template['tier_availability']:
                    continue
                # Exclude already installed
                if upgrade_id in team.installed_upgrades:
                    continue
                # Check incompatibilities
                incompatible = template.get('incompatible_upgrades', [])
                if any(installed_id in incompatible for installed_id in team.installed_upgrades):
                    continue
                # Check required parts
                required_parts = template.get('required_parts', [])
                if not all(part_type in team.equipped_parts for part_type in required_parts):
                    continue
                # Check minimum car stats
                min_stats = template.get('min_car_stat', {})
                meets_requirements = True
                for stat_name, min_value in min_stats.items():
                    current_value = team.car.current_ratings.get(stat_name, 50.0)
                    if current_value < min_value:
                        meets_requirements = False
                        break
                if not meets_requirements:
                    continue
                
                # Add upgrade purchase action
                actions.append(Action('purchase_upgrade', cost=template['cost'], target=upgrade_id))
        
        # Job applications (for all teams, but AI teams will use this rarely)
        visible_jobs = state.job_board.filter_visible_to_player(team.standing_metrics)
        for job in visible_jobs:
            # Application fee (small)
            actions.append(Action("apply_for_job", cost=1000, target=job))
        
        # Sponsor management actions (for all teams)
        # Accept pending sponsor offers
        if team.name in state.pending_sponsor_offers:
            for idx, sponsor_offer in enumerate(state.pending_sponsor_offers[team.name]):
                actions.append(Action("accept_sponsor", cost=0, target=idx))
                actions.append(Action("reject_sponsor", cost=0, target=idx))
        
        # Negotiate renewal with existing sponsors
        if team.name in state.sponsorships:
            for idx, sponsor in enumerate(state.sponsorships[team.name]):
                # Only allow renewal negotiation near contract end
                if sponsor.seasons_active >= sponsor.duration_seasons - 1:
                    actions.append(Action("negotiate_renewal", cost=0, target=idx))
        
        # Filter to legal only (budget check)
        return [a for a in actions if a.is_legal(team.budget, team)]
    
    @staticmethod
    def apply_origin_modifiers(state: SimState, origin: str) -> None:
        """Apply disclosed origin effects (starting cash, perception)"""
        if not state.player_team:
            return
        
        # Origin stories now ADJUST budget rather than replace it
        origin_effects = {
            'game_show_winner': {'cash_bonus': 50000, 'media_standing': 60, 'legitimacy': 40},
            'grassroots_hustler': {'cash_bonus': 0, 'media_standing': 40, 'legitimacy': 60},
            'former_driver': {'cash_bonus': 30000, 'media_standing': 55, 'legitimacy': 55},
            'corporate_spinout': {'cash_bonus': 300000, 'media_standing': 50, 'legitimacy': 45},
            'engineering_savant': {'cash_bonus': 70000, 'media_standing': 45, 'legitimacy': 50},
        }
        
        effects = origin_effects.get(origin, {})
        # Add bonus to existing budget (don't replace it)
        state.player_team.budget.cash += effects.get('cash_bonus', 0)
        state.player_team.standing_metrics['media_standing'] = effects.get('media_standing', 50)
        state.player_team.standing_metrics['legitimacy'] = effects.get('legitimacy', 50)
    
    @staticmethod
    def create_new_save(origin_story: str, player_identity: List[str], save_mode: str, 
                       tier: str = "grassroots", seed: Optional[int] = None,
                       team_name: Optional[str] = None, ownership: str = "hired_manager",
                       manager_age: int = 32, manager_first_name: str = "",
                       manager_last_name: str = "") -> SimState:
        """Initialize a new game save"""
        state = SimState()
        state.save_mode = save_mode
        state.player_identity = player_identity
        state.player_age = manager_age
        state.manager_first_name = manager_first_name
        state.manager_last_name = manager_last_name
        state.manager_career_stats = ManagerCareerStats(career_start_year=1)
        
        # Set seed for deterministic mode
        if seed is None:
            seed = int(time.time())
            
        state.seed = seed
        
        # 1. Generate Full World
        WorldBuilder.generate_world(state)
        
        _dbg(f"[FTB] WORLD_GEN: Created {len(state.leagues)} leagues, {len(state.ai_teams)} teams, {len(state.tracks)} tracks")
        
        # 1.5 Initialize starting sponsors for all teams
        FTBSimulation._initialize_starting_sponsors(state)
        _dbg(f"[FTB] SPONSOR_INIT: All teams now have initial sponsors and offers")
        
        # 1.6 Initialize income streams for all teams based on tier (FINANCE FIX)
        all_teams = state.ai_teams + ([state.player_team] if state.player_team else [])
        for team in all_teams:
            if team is None:
                continue
            # Base media broadcasting rights by tier
            tier_media_rights = {
                1: 75000,   # Grassroots
                2: 150000,   # Formula V
                3: 300000,   # Formula X
                4: 600000,  # Formula Y
                5: 1250000   # Formula Z
            }
            base_media_income = tier_media_rights.get(team.tier, 150000)
            
            # Initialize media rights income stream for the season
            team.budget.income_streams = []
            team.budget.income_streams.append(
               IncomeSource(name="Media Rights", amount=base_media_income, frequency="season")
            )
        _dbg(f"[FTB] FINANCE_INIT: Media broadcasting rights initialized for all teams")
        
        # 2. Assign Player (Take over team in specified tier)
        # Map tier parameter to league tier name
        tier_map = {
            'grassroots': 'grassroots',
            'formula_v': 'formula_v',
            'formula_x': 'formula_x',
            'formula_y': 'formula_y',
            'formula_z': 'formula_z',
        }
        tier_name_str = tier_map.get(tier.lower(), 'grassroots')
        target_league_id = f'{tier_name_str}_1'
        
        _dbg(f"[FTB] Player starting in tier: {tier} → league: {target_league_id}")
        
        if target_league_id in state.leagues:
            league = state.leagues[target_league_id]
            _dbg(f"[FTB] Found league '{league.name}' with {len(league.teams)} teams")
            if league.teams:
                p_team = league.teams[0]
                
                _dbg(f"[FTB] Taking over team: {p_team.name}")
                _dbg(f"[FTB]   - Budget: ${p_team.budget.cash:,.0f}")
                _dbg(f"[FTB]   - Drivers: {len(p_team.drivers)}")
                _dbg(f"[FTB]   - Engineers: {len(p_team.engineers)}")
                _dbg(f"[FTB]   - Mechanics: {len(p_team.mechanics)}")
                _dbg(f"[FTB]   - Strategist: {'Yes' if p_team.strategist else 'No'}")
                _dbg(f"[FTB]   - Principal: {p_team.principal.name if p_team.principal else 'None'}")
                
                # Apply custom team name if provided, otherwise generate
                old_team_name = p_team.name  # Save old name for unregistering
                if team_name and team_name.strip():
                    p_team.name = team_name.strip()
                elif generate_team_name:
                    p_team.name = generate_team_name(state.seed, 1, 0, 999)  # Custom seed offset
                else:
                    p_team.name = "Player Racing"
                
                # Unregister old name and register new name
                state.unregister_team_name(old_team_name)
                state.register_team_name(p_team.name)
                
                # Apply ownership model
                p_team.ownership_type = ownership
                
                # Create player's manager entity from their identity
                # This creates an AIPrincipal that represents the player's management style
                # The LLM translates personality → stats ONCE here, then all decisions use simulation
                _dbg(f"[FTB] Creating player manager profile from identity...")
                player_manager_stats = translate_player_identity_to_stats(player_identity)
                
                # Create the player's AIPrincipal entity
                player_principal_id = state._next_entity_id
                state._next_entity_id += 1
                
                manager_display_name = f"{manager_first_name} {manager_last_name}".strip() or "Your Manager"
                player_principal = AIPrincipal(name=manager_display_name)
                player_principal.entity_id = player_principal_id
                player_principal.display_name = manager_display_name
                player_principal.age = manager_age
                player_principal.current_ratings = player_manager_stats
                
                # Assign player principal to team (replaces AI principal or None)
                p_team.principal = player_principal
                
                # No contract for player principal (doesn't pay themselves, can't be fired)
                # No salary entry created
                
                _dbg(f"[FTB]   - Player manager created: {manager_display_name}")
                _dbg(f"[FTB]   - Manager stats avg: {player_principal.overall_rating:.1f}")
                _dbg(f"[FTB]   - Ownership: {ownership}")
                
                state.player_team = p_team
                # Remove player team from ai_teams by name to ensure it works even if object references differ
                state.ai_teams = [t for t in state.ai_teams if t.name != p_team.name]
                
                # Initialize career stats with first team
                state.manager_career_stats.teams_managed.append(p_team.name)
            else:
                _dbg(f"[FTB] ERROR: League '{league.name}' has no teams!")
                # Fallback
                fallback_name = team_name if team_name and team_name.strip() else "Player Racing"
                state.player_team = Team(fallback_name)
                state.player_team.ownership_type = ownership
                
                # Create player principal even in fallback
                player_manager_stats = translate_player_identity_to_stats(player_identity)
                player_principal_id = state._next_entity_id
                state._next_entity_id += 1
                manager_display_name = f"{manager_first_name} {manager_last_name}".strip() or "Your Manager"
                player_principal = AIPrincipal(name=manager_display_name)
                player_principal.entity_id = player_principal_id
                player_principal.display_name = manager_display_name
                player_principal.age = manager_age
                player_principal.current_ratings = player_manager_stats
                state.player_team.principal = player_principal
                
                state.manager_career_stats.teams_managed.append(fallback_name)
        else:
             _dbg(f"[FTB] ERROR: League '{target_league_id}' not found in {list(state.leagues.keys())[:5]}")
             # Fallback
             fallback_name = team_name if team_name and team_name.strip() else "Player Racing"
             state.player_team = Team(fallback_name)
             state.player_team.ownership_type = ownership
             
             # Create player principal even in fallback
             player_manager_stats = translate_player_identity_to_stats(player_identity)
             player_principal_id = state._next_entity_id
             state._next_entity_id += 1
             manager_display_name = f"{manager_first_name} {manager_last_name}".strip() or "Your Manager"
             player_principal = AIPrincipal(name=manager_display_name)
             player_principal.entity_id = player_principal_id
             player_principal.display_name = manager_display_name
             player_principal.age = manager_age
             player_principal.current_ratings = player_manager_stats
             state.player_team.principal = player_principal
             
             state.manager_career_stats.teams_managed.append(fallback_name)
        
        # Apply origin effects (budget adjustments etc)
        FTBSimulation.apply_origin_modifiers(state, origin_story)
        
        # Ensure player team has sponsors (if it was an AI team it already does, otherwise initialize)
        if state.player_team and state.player_team.name not in state.sponsorships:
            state.sponsorships[state.player_team.name] = []
            state.pending_sponsor_offers[state.player_team.name] = []
            
            # Generate starting sponsor(s) for player team
            rng_player = state.get_rng("world", "player_sponsors")
            starting_sponsors = generate_sponsor_offers(state, state.player_team, rng_player, count=1)
            for sponsor in starting_sponsors:
                sponsor.signed_tick = 0
                sponsor.last_evaluated_tick = 0
                sponsor.last_payment_tick = 0
                state.sponsorships[state.player_team.name].append(sponsor)
            
            # Generate pending offers
            offers = generate_sponsor_offers(state, state.player_team, rng_player, count=2)
            state.pending_sponsor_offers[state.player_team.name].extend(offers)
            
            _dbg(f"[FTB] PLAYER_SPONSORS: Generated {len(starting_sponsors)} starting sponsors and {len(offers)} pending offers")
        
        _dbg(f"[FTB] After origin modifiers:")
        _dbg(f"[FTB]   - Budget: ${state.player_team.budget.cash:,.0f}")
        _dbg(f"[FTB]   - Drivers: {[d.name for d in state.player_team.drivers]}")
        _dbg(f"[FTB]   - Engineers: {[e.name for e in state.player_team.engineers]}")
        _dbg(f"[FTB]   - Mechanics: {[m.name for m in state.player_team.mechanics]}")
        _dbg(f"[FTB]   - Car: {state.player_team.car.overall_rating if state.player_team.car else 'None'}")
        _dbg(f"[FTB]   - Morale: {state.player_team.standing_metrics.get('morale', 0):.1f}")
        _dbg(f"[FTB]   - Is same object as in league? {state.player_team in state.leagues.get('grassroots_1', type('', (), {'teams': []})()).teams}")
        
        # Initialize game phase - start at day 0
        state.tick = 0  # Starting fresh at day 0
        state.sim_day_of_year = 0  # Sync calendar
        state.phase = "development"  # Will become race_weekend when race triggers
        state.in_offseason = False  # Not in between-season offseason
        state.offseason_ticks_remaining = 0
        state.races_completed_this_season = 0  # Season just starting
        
        # Debug log
        _dbg(f"[FTB] Career initialized: team={state.player_team.name if state.player_team else 'None'}")
        _dbg(f"[FTB] Initial state: phase={state.phase}, in_offseason={state.in_offseason}, tick={state.tick}")
        _dbg(f"[FTB] Starting at day 0 - first race will trigger in ~7-14 days")
        
        return state
    
    @staticmethod
    def _initialize_starting_sponsors(state: SimState) -> None:
        """
        Generate initial sponsor deals for all teams at game start.
        Teams begin with 1-2 active sponsors (based on tier) plus 1-2 pending offers.
        """
        rng = state.get_rng("world", "initial_sponsors")
        
        all_teams = state.ai_teams  # Player team assigned later
        
        for team in all_teams:
            # Initialize empty sponsor lists
            state.sponsorships[team.name] = []
            state.pending_sponsor_offers[team.name] = []
            
            # Generate 1-2 starting sponsors based on tier
            # Tier 1-2: 1 sponsor, Tier 3+: 1-2 sponsors
            tier = team.tier
            if tier <= 2:
                num_starting_sponsors = 1
            else:
                num_starting_sponsors = rng.randint(1, 2)
            
            starting_sponsors = generate_sponsor_offers(state, team, rng, count=num_starting_sponsors)
            
            # Auto-accept these starting sponsors (they're already "signed")
            for sponsor in starting_sponsors:
                sponsor.signed_tick = 0
                sponsor.last_evaluated_tick = 0
                sponsor.last_payment_tick = 0
                state.sponsorships[team.name].append(sponsor)
            
            # Generate 1-2 pending offers
            pending_offers = generate_sponsor_offers(state, team, rng, count=rng.randint(1, 2))
            state.pending_sponsor_offers[team.name].extend(pending_offers)
        
        total_active = sum(len(sponsors) for sponsors in state.sponsorships.values())
        total_pending = sum(len(offers) for offers in state.pending_sponsor_offers.values())
        _dbg(f"[FTB] Initialized {total_active} active sponsors and {total_pending} pending offers across {len(all_teams)} teams")
    
    @staticmethod
    def _generate_event_id(state: SimState) -> int:
        """Generate unique event ID and increment counter"""
        event_id = state._next_event_id
        state._next_event_id += 1
        return event_id
    
    @staticmethod
    def validate_part_access_for_tier(part: Part, team_tier: int) -> bool:
        """Check if team tier allows access to this part (Phase 2.6)"""
        return team_tier >= part.tier_minimum and team_tier <= part.tier_maximum
    
    @staticmethod
    def validate_action_for_tier(action_name: str, team_tier: int, team: Team = None) -> Tuple[bool, str]:
        """Check if team tier allows this action (Phase 3.2)"""
        features = TIER_FEATURES.get(team_tier, TIER_FEATURES[1])
        
        # Strategist hiring
        if action_name == 'hire_strategist' and not features['can_hire_strategist']:
            return False, f"Strategists only available in Tier {2}+ (Formula V and above)"
        
        # R&D projects
        if action_name.startswith('rd_project_') and not features['can_rd_projects']:
            return False, f"R&D projects only available in Tier {4}+ (Formula Y and above)"
        
        # Manufacturer contracts
        if action_name == 'manufacturer_contract' and not features['can_manufacturer_contracts']:
            return False, f"Manufacturer partnerships available in Tier {2}+ (Formula V and above)"
        
        # Staff limits (if team provided)
        if team:
            if action_name == 'hire_driver' and len(team.drivers) >= features['max_drivers']:
                return False, f"Tier {team_tier} teams limited to {features['max_drivers']} drivers"
            
            if action_name == 'hire_engineer' and len(team.engineers) >= features['max_engineers']:
                return False, f"Tier {team_tier} teams limited to {features['max_engineers']} engineers"
            
            if action_name == 'hire_mechanic' and len(team.mechanics) >= features['max_mechanics']:
                return False, f"Tier {team_tier} teams limited to {features['max_mechanics']} mechanics"
            
            # Development cost cap
            if action_name == 'develop_car':
                # Check action cost against tier limit (would need cost from Action object)
                pass
        
        return True, ""
    
    @staticmethod
    def apply_action(action: Action, team: Team, state: SimState) -> List[SimEvent]:
        """
        Apply an action to the simulation state and return consequence events.
        This creates stateful multi-system side effects.
        """
        events = []
        
        # Validate action is legal
        if not action.is_legal(team.budget, team):
            return events  # Silently fail if illegal
        
        # Validate tier restrictions (Phase 3.3)
        tier_allowed, rejection_reason = FTBSimulation.validate_action_for_tier(action.name, team.tier, team)
        if not tier_allowed:
            events.append(SimEvent(
                event_type="outcome",
                category="action_rejected_tier",
                ts=state.tick,
                priority=60.0,
                severity="warning",
                data={
                    'team': team.name,
                    'action': action.name,
                    'tier': team.tier,
                    'tier_name': team.tier_name,
                    'reason': rejection_reason
                }
            ))
            return events
        
        # Deduct cost immediately
        team.budget.cash -= action.cost
        
        # Route to specific action handlers
        if action.name == "hire_driver":
            events.extend(FTBSimulation._apply_hire_driver(action, team, state))
        elif action.name == "fire_driver":
            events.extend(FTBSimulation._apply_fire_driver(action, team, state))
        elif action.name == "hire_engineer":
            events.extend(FTBSimulation._apply_hire_engineer(action, team, state))
        elif action.name == "fire_engineer":
            events.extend(FTBSimulation._apply_fire_engineer(action, team, state))
        elif action.name == "develop_car":
            events.extend(FTBSimulation._apply_develop_car(action, team, state))
        elif action.name == "apply_for_job":
            events.extend(FTBSimulation._apply_job_application(action, team, state))
        elif action.name == "purchase_part":
            events.extend(FTBSimulation._apply_purchase_part(action, team, state))
        elif action.name == "equip_part":
            events.extend(FTBSimulation._apply_equip_part(action, team, state))
        elif action.name == "sell_part":
            events.extend(FTBSimulation._apply_sell_part(action, team, state))
        elif action.name.startswith("rd_"):
            # R&D project actions
            if action.name == "rd_start":
                events.extend(FTBSimulation._apply_start_rd_project(action, team, state))
            elif action.name == "rd_cancel":
                events.extend(FTBSimulation._apply_cancel_rd_project(action, team, state))
        elif action.name.startswith("start_rd_"):
            events.extend(FTBSimulation._apply_start_rd_project(action, team, state))
        elif action.name == "purchase_upgrade":
            events.extend(FTBSimulation._apply_purchase_upgrade(action, team, state))
        elif action.name == "install_upgrade":
            events.extend(FTBSimulation._apply_install_upgrade(action, team, state))
        elif action.name == "accept_sponsor":
            events.extend(FTBSimulation._apply_accept_sponsor(action, team, state))
        elif action.name == "reject_sponsor":
            events.extend(FTBSimulation._apply_reject_sponsor(action, team, state))
        elif action.name == "negotiate_renewal":
            events.extend(FTBSimulation._apply_negotiate_renewal(action, team, state))
        elif action.name == "terminate_sponsor":
            events.extend(FTBSimulation._apply_terminate_sponsor(action, team, state))
        
        # Assign event IDs
        for event in events:
            if event.event_id == 0:
                event.event_id = FTBSimulation._generate_event_id(state)
        
        return events
    
    @staticmethod
    def _apply_hire_driver(action: Action, team: Team, state: SimState) -> List[SimEvent]:
        """Hire a driver from the job market or generate new one"""
        events = []
        
        # If target is a driver entity, use it; otherwise generate new driver
        if action.target and isinstance(action.target, Driver):
            driver = action.target
        else:
            # Generate new driver with tier-appropriate stats
            rng = state.get_rng("hiring", f"driver_{state.tick}")
            tier_base = 30 + rng.randint(0, 20)
            
            # Generate entity with human name
            driver_id = state._next_entity_id
            state._next_entity_id += 1
            
            if generate_name:
                driver_name = generate_name(state.seed, "Driver", driver_id)
            else:
                driver_name = f"Driver_{state.tick}"
            
            # Age based on team tier (use tier envelope if available)
            tier_name = TIER_DISPLAY_NAMES.get(team.tier, 'grassroots')
            age_range = WorldBuilder.TIER_ENVELOPES.get(tier_name, {}).get('driver_age_range', (18, 28))
            driver = Driver(name=driver_name, age=rng.randint(*age_range))
            driver.entity_id = driver_id
            driver.display_name = driver_name
            
            # Initialize ratings around tier base
            for stat in driver.current_ratings:
                driver.current_ratings[stat] = tier_base + rng.uniform(-10, 10)
        
        # Add to roster
        team.drivers.append(driver)
        
        # Calculate salary (base * overall rating / 50)
        salary = estimate_salary_expectation(driver, team_tier=team.tier)
        team.budget.add_staff_salary(driver.name, salary)
        
        # Create contract (2-3 years, 104-156 weeks)
        rng = state.get_rng("contracts", f"hire_{state.tick}")
        contract_duration_days = int(rng.uniform(104, 156) * 7)  # 2-3 years in days
        contract = Contract(
            entity_id=driver.entity_id,
            entity_name=driver.name,
            team_name=team.name,
            role="Driver",
            start_day=state.sim_day_of_year,
            duration_days=contract_duration_days,
            base_salary=int(salary * 365)  # Convert per-tick to per-season
        )
        state.contracts[driver.entity_id] = contract
        
        # Create events
        hire_event = SimEvent(
            event_type="structural",
            category="driver_hired",
            ts=state.tick,
            priority=60.0,
            severity="info",
            data={
                'team': team.name,
                'driver': driver.name,
                'age': driver.age,
                'overall_rating': driver.overall_rating,
                'salary': salary,
                'cost': action.cost,
                'contract_years': round(contract_duration_days / 365.0, 1)
            }
        )
        events.append(hire_event)
        
        # Morale boost from new hire (slight)
        team.standing_metrics['morale'] = min(100, team.standing_metrics['morale'] + 2.0)
        
        morale_event = SimEvent(
            event_type="outcome",
            category="morale_change",
            ts=state.tick,
            priority=30.0,
            severity="info",
            data={
                'team': team.name,
                'change': +2.0,
                'reason': f"New driver {driver.name} joins team",
                'new_morale': team.standing_metrics['morale']
            },
            caused_by=hire_event.event_id  # Will be set in apply_action
        )
        events.append(morale_event)
        
        # Reputation shift based on hire quality
        rep_change = (driver.overall_rating - 50.0) * 0.1
        team.standing_metrics['reputation'] = max(0, min(100, team.standing_metrics['reputation'] + rep_change))
        
        # Mark team data as dirty to trigger UI refresh
        state.mark_dirty('team')
        state.mark_dirty('finance')
        
        return events
    
    @staticmethod
    def _apply_fire_driver(action: Action, team: Team, state: SimState) -> List[SimEvent]:
        """Fire a driver from the roster"""
        events = []
        
        # Find driver by name (action.target should be driver name)
        driver_name = action.target
        driver = next((d for d in team.drivers if d.name == driver_name), None)
        
        if not driver:
            return events  # No-op if driver not found
        
        # Calculate seniority penalty (years with team approximated by performance_history length)
        seniority = len(driver.performance_history)
        rep_penalty = min(5.0, seniority * 0.5)
        
        # Remove from roster and payroll
        team.drivers.remove(driver)
        team.budget.remove_staff_salary(driver_name)
        team.normalize_roster()
        
        # Remove contract if exists
        buyout_payout = 0
        if hasattr(driver, 'entity_id') and driver.entity_id in state.contracts:
            contract = state.contracts.get(driver.entity_id)
            buyout_payout = state.apply_contract_buyout(team, contract, driver_name)
            del state.contracts[driver.entity_id]
        
        # Add to free agent pool (convert per-tick to annual)
        per_tick_salary = estimate_salary_expectation(driver, team_tier=team.tier, fired=True)
        asking_salary = per_tick_salary * 365  # Annual salary
        state.add_to_free_agent_pool(driver, "fired", asking_salary)
        
        # Create events
        fire_event = SimEvent(
            event_type="structural",
            category="driver_fired",
            ts=state.tick,
            priority=70.0,
            severity="warning",
            data={
                'team': team.name,
                'driver': driver_name,
                'seniority': seniority,
                'overall_rating': driver.overall_rating,
                'entered_free_agency': True,
                'buyout_payout': buyout_payout
            }
        )
        events.append(fire_event)
        
        # Morale hit
        team.standing_metrics['morale'] = max(0, team.standing_metrics['morale'] - 5.0)
        
        morale_event = SimEvent(
            event_type="outcome",
            category="morale_change",
            ts=state.tick,
            priority=50.0,
            severity="warning",
            data={
                'team': team.name,
                'change': -5.0,
                'reason': f"Driver {driver_name} fired",
                'new_morale': team.standing_metrics['morale']
            },
            caused_by=fire_event.event_id
        )
        events.append(morale_event)
        
        # Reputation penalty
        team.standing_metrics['reputation'] = max(0, team.standing_metrics['reputation'] - rep_penalty)
        
        rep_event = SimEvent(
            event_type="outcome",
            category="reputation_change",
            ts=state.tick,
            priority=50.0,
            severity="warning",
            data={
                'team': team.name,
                'change': -rep_penalty,
                'reason': f"Firing {driver_name} with {seniority} years tenure",
                'new_reputation': team.standing_metrics['reputation']
            },
            caused_by=fire_event.event_id
        )
        events.append(rep_event)
        
        # Mark team data as dirty to trigger UI refresh
        state.mark_dirty('team')
        state.mark_dirty('finance')
        
        return events
    
    @staticmethod
    def _apply_hire_engineer(action: Action, team: Team, state: SimState) -> List[SimEvent]:
        """Hire an engineer"""
        events = []
        
        # Generate new engineer with human name
        rng = state.get_rng("hiring", f"engineer_{state.tick}")
        tier_base = 30 + rng.randint(0, 20)
        
        engineer_id = state._next_entity_id
        state._next_entity_id += 1
        
        if generate_name:
            engineer_name = generate_name(state.seed, "Engineer", engineer_id)
        else:
            engineer_name = f"Engineer_{state.tick}"
        
        # Age based on team tier (use tier envelope if available)
        tier_name = TIER_DISPLAY_NAMES.get(team.tier, 'grassroots')
        age_range = WorldBuilder.TIER_ENVELOPES.get(tier_name, {}).get('staff_age_range', (22, 40))
        engineer = Engineer(name=engineer_name, age=rng.randint(*age_range))
        engineer.entity_id = engineer_id
        engineer.display_name = engineer_name
        
        for stat in engineer.current_ratings:
            engineer.current_ratings[stat] = tier_base + rng.uniform(-10, 10)
        
        team.engineers.append(engineer)
        
        salary = estimate_salary_expectation(engineer, team_tier=team.tier)
        team.budget.add_staff_salary(engineer.name, salary)
        
        events.append(SimEvent(
            event_type="structural",
            category="engineer_hired",
            ts=state.tick,
            priority=50.0,
            severity="info",
            data={
                'team': team.name,
                'engineer': engineer.name,
                'overall_rating': engineer.overall_rating,
                'salary': salary
            }
        ))
        
        team.standing_metrics['morale'] = min(100, team.standing_metrics['morale'] + 1.0)
        
        # Mark team data as dirty to trigger UI refresh
        state.mark_dirty('team')
        state.mark_dirty('finance')
        
        return events
    
    @staticmethod
    def _apply_fire_engineer(action: Action, team: Team, state: SimState) -> List[SimEvent]:
        """Fire an engineer"""
        events = []
        
        engineer_name = action.target
        engineer = next((e for e in team.engineers if e.name == engineer_name), None)
        
        if not engineer:
            return events
        
        team.engineers.remove(engineer)
        team.budget.remove_staff_salary(engineer_name)
        team.normalize_roster()
        
        # Remove contract if exists
        buyout_payout = 0
        if hasattr(engineer, 'entity_id') and engineer.entity_id in state.contracts:
            contract = state.contracts.get(engineer.entity_id)
            buyout_payout = state.apply_contract_buyout(team, contract, engineer_name)
            del state.contracts[engineer.entity_id]
        
        # Add to free agent pool (convert per-tick to annual)
        per_tick_salary = estimate_salary_expectation(engineer, team_tier=team.tier, fired=True)
        asking_salary = per_tick_salary * 365  # Annual salary
        state.add_to_free_agent_pool(engineer, "fired", asking_salary)
        
        events.append(SimEvent(
            event_type="structural",
            category="engineer_fired",
            ts=state.tick,
            priority=50.0,
            severity="info",
            data={
                'team': team.name,
                'engineer': engineer_name,
                'overall_rating': engineer.overall_rating,
                'entered_free_agency': True,
                'buyout_payout': buyout_payout
            }
        ))
        
        team.standing_metrics['morale'] = max(0, team.standing_metrics['morale'] - 3.0)
        
        # Mark team data as dirty to trigger UI refresh
        state.mark_dirty('team')
        state.mark_dirty('finance')
        
        return events
    
    @staticmethod
    def _apply_develop_car(action: Action, team: Team, state: SimState) -> List[SimEvent]:
        """
        Initiate car development with delayed resolution.
        Creates a pending development that resolves after N ticks.
        """
        events = []
        
        # Calculate engineer bonus (average technical depth of all engineers)
        engineer_bonus = 0.0
        if team.engineers:
            engineer_bonus = sum(e.technical_depth_score for e in team.engineers) / len(team.engineers)
        
        # Development resolves in 14 ticks (2 weeks) by default
        resolve_tick = state.tick + 14
        
        # Record pending development
        state.pending_developments.append({
            'team_name': team.name,
            'resolve_tick': resolve_tick,
            'cost': action.cost,
            'engineer_bonus': engineer_bonus,
            'initiated_tick': state.tick
        })
        
        # Immediate event
        events.append(SimEvent(
            event_type="structural",
            category="development_initiated",
            ts=state.tick,
            priority=60.0,
            severity="info",
            data={
                'team': team.name,
                'cost': action.cost,
                'resolve_tick': resolve_tick,
                'engineer_bonus': engineer_bonus
            }
        ))
        
        return events
    
    @staticmethod
    def _apply_job_application(action: Action, team: Team, state: SimState) -> List[SimEvent]:
        """
        Apply for a job opening. If accepted, transfer player team.
        """
        events = []
        
        # action.target should be a JobListing
        job = action.target
        
        if not job or not isinstance(job, JobListing):
            return events
        
        # Check acceptance probability based on standing metrics
        acceptance_prob = state.job_board.get_acceptance_chance(team.standing_metrics, job)
        
        rng = state.get_rng("jobs", f"application_{state.tick}")
        accepted = rng.random() < acceptance_prob
        
        if accepted:
            # Find the AI team and transfer player to it
            target_team = job.team if job.team else next((t for t in state.ai_teams if t.name == job.team_name), None)
            
            if target_team:
                # Transfer player identity to new team
                old_team_name = state.player_team.name
                state.player_team = target_team
                # Remove by name to ensure it works even if object references differ
                state.ai_teams = [t for t in state.ai_teams if t.name != target_team.name]
                
                events.append(SimEvent(
                    event_type="structural",
                    category="job_accepted",
                    ts=state.tick,
                    priority=90.0,
                    severity="info",
                    data={
                        'old_team': old_team_name,
                        'new_team': target_team.name,
                        'role': job.role,
                        'tier': job.tier
                    }
                ))
                
                # Remove job from board
                if job in state.job_board.vacancies:
                    state.job_board.vacancies.remove(job)
        else:
            events.append(SimEvent(
                event_type="opportunity",
                category="job_rejected",
                ts=state.tick,
                priority=60.0,
                severity="warning",
                data={
                    'team': team.name,
                    'target_team': job.team_name,
                    'role': job.role,
                    'acceptance_prob': acceptance_prob
                }
            ))
        
        return events
    
    @staticmethod
    def _apply_purchase_part(action: Action, team: Team, state: SimState) -> List[SimEvent]:
        """Purchase a part and add it to team inventory (Phase 2.5)"""
        events = []
        
        # action.target should be a part_id string
        part_id = action.target
        if not part_id or part_id not in state.parts_catalog:
            return events  # No-op if part not found
        
        catalog_part = state.parts_catalog[part_id]
        
        # CRITICAL: Create a deep copy of the part so each purchase is independent
        # This prevents issues where multiple teams share the same Part object reference
        from copy import deepcopy
        part = deepcopy(catalog_part)
        
        # Generate a unique part_id for this specific instance
        part.part_id = f"{catalog_part.part_id}_{uuid.uuid4().hex[:8]}"
        
        # Defensive: Ensure the copied part has proper current_ratings
        if not part.current_ratings or len(part.current_ratings) == 0:
            if 'Part' in STATS_SCHEMAS:
                part.current_ratings = STATS_SCHEMAS['Part'].copy()
        
        # Defensive: Ensure effectiveness_modifier is set
        if not hasattr(part, 'effectiveness_modifier') or part.effectiveness_modifier is None:
            part.effectiveness_modifier = 1.0
        
        # Defensive: Ensure regulatory_exposure exists
        if not hasattr(part, 'regulatory_exposure') or not part.regulatory_exposure:
            part.regulatory_exposure = {
                'structural_margin': 0.5,
                'aero_freedom': 0.5,
                'power_ceiling': 0.5,
                'reliability_mandate': 0.5,
                'cost_cap_friendly': 0.5
            }
        
        # Validate tier access
        if not FTBSimulation.validate_part_access_for_tier(part, team.tier):
            events.append(SimEvent(
                event_type="outcome",
                category="purchase_rejected",
                ts=state.tick,
                priority=60.0,
                severity="warning",
                data={
                    'team': team.name,
                    'part_id': part_id,
                    'part_name': part.name,
                    'reason': f"Tier {team.tier} teams cannot use tier {part.tier_minimum}-{part.tier_maximum} parts",
                    'team_tier': team.tier,
                    'part_tier_min': part.tier_minimum,
                    'part_tier_max': part.tier_maximum
                }
            ))
            return events
        
        # Validate sponsor exclusivity clauses
        if hasattr(state, 'sponsorships') and team.name in state.sponsorships:
            for sponsor in state.sponsorships.get(team.name, []):
                if sponsor.exclusivity_clauses:
                    # Check for manufacturer-specific exclusivity
                    if f"no_competitor_{sponsor.sub_industry}_parts" in sponsor.exclusivity_clauses:
                        # Block parts from competitor manufacturers in same sub-industry
                        if part.manufacturer_id and sponsor.sub_industry.lower() in part.manufacturer_id.lower():
                            events.append(SimEvent(
                                event_type="outcome",
                                category="purchase_rejected",
                                ts=state.tick,
                                priority=65.0,
                                severity="warning",
                                data={
                                    'team': team.name,
                                    'part_id': part_id,
                                    'part_name': part.name,
                                    'manufacturer': part.manufacturer_id,
                                    'reason': f"Sponsor exclusivity: {sponsor.sponsor_name} requires exclusive {sponsor.sub_industry} partnership",
                                    'blocking_sponsor': sponsor.sponsor_name,
                                    'exclusivity_clause': f"no_competitor_{sponsor.sub_industry}_parts"
                                }
                            ))
                            return events
                    
                    # Check for category-wide exclusivity (automotive, energy)
                    if "exclusive_automotive_category" in sponsor.exclusivity_clauses and sponsor.industry == "Automotive":
                        if part.part_type in ["engine", "transmission", "suspension", "brakes"]:
                            # Check if part manufacturer doesn't match sponsor
                            if part.manufacturer_id and sponsor.sponsor_name.split()[0].lower() not in part.manufacturer_id.lower():
                                events.append(SimEvent(
                                    event_type="outcome",
                                    category="purchase_rejected",
                                    ts=state.tick,
                                    priority=65.0,
                                    severity="warning",
                                    data={
                                        'team': team.name,
                                        'part_id': part_id,
                                        'part_name': part.name,
                                        'part_type': part.part_type,
                                        'reason': f"Sponsor exclusivity: {sponsor.sponsor_name} requires using their automotive parts",
                                        'blocking_sponsor': sponsor.sponsor_name,
                                        'exclusivity_clause': 'exclusive_automotive_category'
                                    }
                                ))
                                return events
                    
                    if "exclusive_energy_sponsor" in sponsor.exclusivity_clauses and sponsor.industry == "Energy":
                        if part.part_type in ["fuel_system", "battery"]:
                            if part.manufacturer_id and sponsor.sponsor_name.split()[0].lower() not in part.manufacturer_id.lower():
                                events.append(SimEvent(
                                    event_type="outcome",
                                    category="purchase_rejected",
                                    ts=state.tick,
                                    priority=65.0,
                                    severity="warning",
                                    data={
                                        'team': team.name,
                                        'part_id': part_id,
                                        'part_name': part.name,
                                        'part_type': part.part_type,
                                        'reason': f"Sponsor exclusivity: {sponsor.sponsor_name} requires using their energy technology",
                                        'blocking_sponsor': sponsor.sponsor_name,
                                        'exclusivity_clause': 'exclusive_energy_sponsor'
                                    }
                                ))
                                return events
        
        # Deduct cost from team budget
        team.budget.cash -= action.cost
        
        # Add part to inventory
        team.parts_inventory.append(part)
        
        # Log transaction (only for player team)
        if team == state.player_team:
            state.log_transaction(
                type='expense',
                category='part_purchase',
                amount=action.cost,
                description=f"Purchased {part.name} ({part.part_type})",
                balance_after=team.budget.cash,
                related_entity=part.manufacturer_id,
                metadata={
                    'part_id': part_id,
                    'part_name': part.name,
                    'part_type': part.part_type,
                    'manufacturer': part.manufacturer_id,
                    'performance_score': round(part.performance_score, 2)
                }
            )
        
        # Create purchase event
        events.append(SimEvent(
            event_type="structural",
            category="part_purchased",
            ts=state.tick,
            priority=60.0,
            severity="info",
            data={
                'team': team.name,
                'part_id': part_id,
                'part_name': part.name,
                'part_type': part.part_type,
                'manufacturer': part.manufacturer_id,
                'performance_score': round(part.performance_score, 2),
                'cost': action.cost,
                'generation': part.generation,
                'tier_availability': part.tier_availability
            }
        ))
        
        return events
    
    @staticmethod
    def _apply_equip_part(action: Action, team: Team, state: SimState) -> List[SimEvent]:
        """Equip a part from inventory onto the car (Phase 2.5)"""
        events = []
        
        # action.target should be a part_id string
        part_id = action.target
        if not part_id:
            return events
        
        # Find part in team inventory
        part = next((p for p in team.parts_inventory if p.part_id == part_id), None)
        if not part:
            return events  # No-op if part not in inventory
        
        # Remove from inventory
        team.parts_inventory.remove(part)
        
        # Calculate installation quality based on infrastructure
        # Relevant facilities: workshop, fabrication, reliability_qa, factory_quality
        install_facilities = ['workshop', 'fabrication', 'reliability_qa', 'factory_quality']
        install_quality_values = []
        
        for fac in install_facilities:
            if fac in team.infrastructure:
                unlock_key = f"{fac}_unlocked"
                if unlock_key in team.infrastructure:
                    if team.infrastructure[unlock_key]:
                        install_quality_values.append(team.infrastructure[fac])
                else:
                    # No unlock key means always active
                    install_quality_values.append(team.infrastructure[fac])
        
        # Calculate weighted average: workshop 40%, fabrication 30%, reliability_qa 30%
        if len(install_quality_values) >= 3:
            workshop_q = team.infrastructure.get('workshop', 50.0) if team.infrastructure.get('workshop_unlocked', True) else 50.0
            fabrication_q = team.infrastructure.get('fabrication', 50.0) if team.infrastructure.get('fabrication_unlocked', False) else 50.0
            reliability_qa_q = team.infrastructure.get('reliability_qa', 50.0) if team.infrastructure.get('reliability_qa_unlocked', False) else 50.0
            install_quality = workshop_q * 0.4 + fabrication_q * 0.3 + reliability_qa_q * 0.3
        elif install_quality_values:
            install_quality = sum(install_quality_values) / len(install_quality_values)
        else:
            install_quality = 50.0  # Default if no infrastructure data
        
        # Set installation quality on the part
        part.install_quality = install_quality
        
        # If a part is already equipped in that slot, unequip it to inventory
        old_part = None
        if part.part_type in team.equipped_parts:
            old_part = team.equipped_parts[part.part_type]
            team.parts_inventory.append(old_part)
        
        # Equip new part
        team.equipped_parts[part.part_type] = part
        
        # Update car ratings with new parts configuration
        # Use car's base_ratings (tier-specific), not schema defaults!
        if hasattr(team.car, 'base_ratings') and team.car.base_ratings:
            base_ratings = team.car.base_ratings.copy()
        else:
            # Fallback for old saves or initialization issues
            base_ratings = team.car.current_ratings.copy()
        team.car.update_ratings(base_ratings, team.equipped_parts)
        
        # Create equip event
        event_data = {
            'team': team.name,
            'part_id': part_id,
            'part_name': part.name,
            'part_type': part.part_type,
            'manufacturer': part.manufacturer_id,
            'performance_score': round(part.performance_score, 2),
            'new_car_rating': round(team.car.overall_rating, 2)
        }
        
        if old_part:
            event_data['replaced_part_id'] = old_part.part_id
            event_data['replaced_part_name'] = old_part.name
            event_data['performance_delta'] = round(part.performance_score - old_part.performance_score, 2)
        
        events.append(SimEvent(
            event_type="structural",
            category="part_equipped",
            ts=state.tick,
            priority=70.0,
            severity="info",
            data=event_data
        ))
        
        # Small morale boost from upgrade
        if not old_part or part.performance_score > old_part.performance_score:
            morale_boost = min(3.0, (part.performance_score - (old_part.performance_score if old_part else 50.0)) * 0.1)
            team.standing_metrics['morale'] = min(100, team.standing_metrics['morale'] + morale_boost)
        
        return events
    
    @staticmethod
    def _apply_sell_part(action: Action, team: Team, state: SimState) -> List[SimEvent]:
        """Sell a part from inventory for cash (Phase 2.7)"""
        events = []
        
        # action.target should be a part_id string
        part_id = action.target
        if not part_id:
            return events
        
        # Find part in team inventory
        part = next((p for p in team.parts_inventory if p.part_id == part_id), None)
        if not part:
            return events  # No-op if part not in inventory
        
        # Can't sell equipped parts
        if part_id in [p.part_id for p in team.equipped_parts.values()]:
            events.append(SimEvent(
                event_type="outcome",
                category="sale_rejected",
                ts=state.tick,
                priority=50.0,
                severity="warning",
                data={
                    'team': team.name,
                    'part_id': part_id,
                    'part_name': part.name,
                    'reason': "Cannot sell equipped parts. Unequip first."
                }
            ))
            return events
        
        # Calculate sale price (40-60% of original cost depending on condition and obsolescence)
        # Base depreciation: 50%
        # - Obsolescence penalty: -20% if obsolete
        # - Condition bonus: +10% if performance_score > 70
        
        base_discount = 0.50
        obsolescence_penalty = 0.20 if part.is_obsolete else 0.0
        condition_bonus = 0.10 if part.performance_score > 70.0 else 0.0
        
        sale_multiplier = base_discount - obsolescence_penalty + condition_bonus
        sale_multiplier = max(0.30, min(0.60, sale_multiplier))  # Clamp between 30-60%
        
        # Get original cost from action or estimate based on performance
        original_cost = getattr(action, 'original_cost', None) or (part.performance_score * 100)
        sale_price = original_cost * sale_multiplier
        
        # Add funds to team budget
        team.budget.cash += sale_price
        
        # Remove from inventory
        team.parts_inventory.remove(part)
        
        # Log transaction (only for player team)
        if team == state.player_team:
            state.log_transaction(
                type='income',
                category='part_sale',
                amount=sale_price,
                description=f"Sold {part.name} ({part.part_type})",
                balance_after=team.budget.cash,
                related_entity=part.manufacturer_id,
                metadata={
                    'part_id': part_id,
                    'part_name': part.name,
                    'part_type': part.part_type,
                    'manufacturer': part.manufacturer_id,
                    'performance_score': round(part.performance_score, 2),
                    'original_cost': original_cost,
                    'sale_price': sale_price,
                    'sale_multiplier': round(sale_multiplier, 2)
                }
            )
        
        # Create sale event
        events.append(SimEvent(
            event_type="structural",
            category="part_sold",
            ts=state.tick,
            priority=55.0,
            severity="info",
            data={
                'team': team.name,
                'part_id': part_id,
                'part_name': part.name,
                'part_type': part.part_type,
                'manufacturer': part.manufacturer_id,
                'performance_score': round(part.performance_score, 2),
                'sale_price': sale_price,
                'sale_multiplier': round(sale_multiplier, 2),
                'was_obsolete': part.is_obsolete
            }
        ))
        
        return events
    
    @staticmethod
    def _apply_start_rd_project(action: Action, team: Team, state: SimState) -> List[SimEvent]:
        """Start an R&D project (Phase 4.4)"""
        events = []
        
        # action.target should be a project_id from RD_PROJECT_CATALOG
        project_id = action.target
        if not project_id or project_id not in RD_PROJECT_CATALOG:
            return events
        
        project_template = RD_PROJECT_CATALOG[project_id]
        
        # Validate tier access
        min_tier = project_template.get('min_tier', 4)
        if team.tier < min_tier:
            events.append(SimEvent(
                event_type="outcome",
                category="rd_project_rejected",
                ts=state.tick,
                priority=60.0,
                severity="warning",
                data={
                    'team': team.name,
                    'project_id': project_id,
                    'reason': f"R&D project requires tier {min_tier}+",
                    'team_tier': team.tier
                }
            ))
            return events
        
        # Check for duplicate active projects
        if any(p.project_id == project_id and not p.completed and not p.cancelled for p in team.active_rd_projects):
            events.append(SimEvent(
                event_type="outcome",
                category="rd_project_rejected",
                ts=state.tick,
                priority=60.0,
                severity="warning",
                data={
                    'team': team.name,
                    'project_id': project_id,
                    'reason': 'Project already in progress'
                }
            ))
            return events
        
        # Check staff skill requirements
        required_skills = project_template.get('required_engineer_skills', {})
        if required_skills and team.engineers:
            # Check if at least one engineer meets all requirements
            has_qualified_engineer = False
            for engineer in team.engineers:
                meets_requirements = True
                for skill, min_value in required_skills.items():
                    if engineer.current_ratings.get(skill, 0.0) < min_value:
                        meets_requirements = False
                        break
                if meets_requirements:
                    has_qualified_engineer = True
                    break
            
            if not has_qualified_engineer:
                # Find which skill is the biggest gap
                skill_gaps = []
                for skill, min_value in required_skills.items():
                    max_team_skill = max((e.current_ratings.get(skill, 0.0) for e in team.engineers), default=0.0)
                    if max_team_skill < min_value:
                        skill_gaps.append((skill, min_value, max_team_skill))
                
                events.append(SimEvent(
                    event_type="outcome",
                    category="rd_project_rejected",
                    ts=state.tick,
                    priority=60.0,
                    severity="warning",
                    data={
                        'team': team.name,
                        'project_id': project_id,
                        'reason': 'No engineer meets skill requirements',
                        'required_skills': required_skills,
                        'skill_gaps': skill_gaps
                    }
                ))
                return events
        
        # Get assigned engineers and risk level from action params
        assigned_engineer_ids = action.params.get('assigned_engineers', []) if hasattr(action, 'params') and action.params else []
        risk_level = action.params.get('risk_level', 0.5) if hasattr(action, 'params') and action.params else 0.5
        
        # Calculate success rate based on engineer stats (Phase 4.8)
        engineer_bonus = 0.0
        if assigned_engineer_ids:
            # Use only assigned engineers for bonus calculation
            assigned_engineers = [e for e in team.engineers if e.entity_id in assigned_engineer_ids]
            if assigned_engineers:
                # Average of innovation_bias and technical_depth
                innovation_avg = sum(e.current_ratings.get('innovation_bias', 50.0) for e in assigned_engineers) / len(assigned_engineers)
                technical_avg = sum(e.current_ratings.get('technical_depth', 50.0) for e in assigned_engineers) / len(assigned_engineers)
                engineer_bonus = (innovation_avg + technical_avg) / 2.0
                
                # Bonus for multiple engineers (collaboration)
                if len(assigned_engineers) > 1:
                    engineer_bonus += 5.0  # +5 flat bonus for teamwork
        elif team.engineers:
            # Fallback: use all engineers (legacy behavior)
            innovation_avg = sum(e.current_ratings.get('innovation_bias', 50.0) for e in team.engineers) / len(team.engineers)
            technical_avg = sum(e.current_ratings.get('technical_depth', 50.0) for e in team.engineers) / len(team.engineers)
            engineer_bonus = (innovation_avg + technical_avg) / 2.0
        else:
            # No engineers = penalty
            engineer_bonus = 35.0
        
        # Infrastructure bonus for success rate
        infra_bonus = 0.0
        if project_template.get('uses_wind_tunnel', False):
            wind_tunnel_q = team.infrastructure.get('wind_tunnel', 50.0)
            infra_bonus += (wind_tunnel_q - 50.0) * 0.001  # +0.1% per point above 50
        if project_template.get('uses_simulator', False):
            simulator_q = team.infrastructure.get('simulator', 50.0)
            infra_bonus += (simulator_q - 50.0) * 0.001
        # Factory affects all projects
        factory_q = team.infrastructure.get('factory_quality', 50.0)
        infra_bonus += (factory_q - 50.0) * 0.0005  # +0.05% per point
        
        # Driver feedback bonus
        driver_feedback_bonus = 0.0
        if project_template.get('benefits_from_driver_input', False):
            for driver in team.drivers:
                feedback_quality = driver.current_ratings.get('feedback_quality', 50.0)
                if feedback_quality > 60:
                    driver_feedback_bonus += (feedback_quality - 50.0) * 0.002
        
        # Adjust success rate: +0.3% per engineer point above 50
        base_rate = project_template['base_success_rate']
        success_rate = base_rate + ((engineer_bonus - 50.0) * 0.003) + infra_bonus + driver_feedback_bonus
        
        # Apply risk level modifier to success rate
        # Higher risk = lower success rate but higher reward
        success_penalty = risk_level * -0.15  # Up to -15% at max risk
        success_rate += success_penalty
        success_rate = max(0.3, min(0.95, success_rate))  # Clamp between 30% and 95%
        
        # Apply risk level to cost and duration
        cost_multiplier = 1.0 - (risk_level * 0.3)  # Up to -30% at max risk
        duration_multiplier_risk = 1.0 - (risk_level * 0.25)  # Up to -25% at max risk
        
        # Calculate duration with infrastructure modifier
        duration_multiplier = duration_multiplier_risk
        # High-quality factory speeds up all projects
        factory_quality = team.infrastructure.get('factory_quality', 50.0)
        duration_multiplier *= (1.0 - ((factory_quality - 50.0) / 50.0) * 0.2)  # Up to 20% faster at quality 100
        
        adjusted_duration = int(project_template['duration_ticks'] * duration_multiplier)
        adjusted_duration = max(5, adjusted_duration)  # Minimum 5 ticks
        
        adjusted_cost = int(project_template['cost'] * cost_multiplier)
        
        # Check if team can afford
        if not team.budget.can_afford(adjusted_cost):
            events.append(SimEvent(
                event_type="outcome",
                category="rd_project_rejected",
                ts=state.tick,
                priority=60.0,
                severity="warning",
                data={
                    'team': team.name,
                    'project_id': project_id,
                    'reason': 'Insufficient funds',
                    'required_cost': adjusted_cost,
                    'available_cash': team.budget.cash
                }
            ))
            return events
        
        # Deduct cost
        team.budget.cash -= adjusted_cost
        
        # Apply risk to reward (target improvement)
        reward_multiplier = 1.0 + (risk_level * 0.5)  # Up to +50% at max risk
        adjusted_improvement = project_template.get('target_improvement', 0.0) * reward_multiplier
        
        # Create project
        project = RDProject(
            project_id=project_id,
            project_name=project_template['name'],
            project_type=project_template['type'],
            team_name=team.name,
            total_cost=adjusted_cost,
            duration_ticks=adjusted_duration,
            started_tick=state.tick,
            progress_ticks=0,
            base_success_rate=base_rate,
            current_success_rate=success_rate,
            target_stat=project_template.get('target_stat', ''),
            target_improvement=adjusted_improvement,
            generates_part=project_template.get('generates_part', False),
            part_type=project_template.get('part_type', ''),
            description=project_template['description'],
            risk_level=project_template['risk_level'],
            assigned_engineer_ids=assigned_engineer_ids
        )
        
        team.active_rd_projects.append(project)
        
        events.append(SimEvent(
            event_type="structural",
            category="rd_project_started",
            ts=state.tick,
            priority=70.0,
            severity="info",
            data={
                'team': team.name,
                'project_id': project_id,
                'project_name': project.project_name,
                'cost': project.total_cost,
                'duration_ticks': project.duration_ticks,
                'estimated_weeks': round(project.duration_ticks / 7.0, 1),
                'success_rate': round(success_rate * 100, 1),
                'engineer_bonus': round(engineer_bonus, 1),
                'description': project.description
            }
        ))
        
        return events
    
    @staticmethod
    def _apply_cancel_rd_project(action: Action, team: Team, state: SimState) -> List[SimEvent]:
        """Cancel an active R&D project (Phase 4.7)"""
        events = []
        
        # action.target should be project_id
        project_id = action.target
        if not project_id:
            return events
        
        # Find project
        project = next((p for p in team.active_rd_projects if p.project_id == project_id and not p.completed and not p.cancelled), None)
        if not project:
            return events
        
        # Mark as cancelled (no refund)
        project.cancelled = True
        
        events.append(SimEvent(
            event_type="structural",
            category="rd_project_cancelled",
            ts=state.tick,
            priority=60.0,
            severity="warning",
            data={
                'team': team.name,
                'project_id': project_id,
                'project_name': project.project_name,
                'progress': project.progress_ticks,
                'total_duration': project.duration_ticks,
                'wasted_cost': project.total_cost
            }
        ))
        
        # Morale penalty
        morale_penalty = min(5.0, project.total_cost / 100000.0)
        team.standing_metrics['morale'] = max(0, team.standing_metrics['morale'] - morale_penalty)
        
        return events
    
    @staticmethod
    def _progress_rd_projects(state: SimState) -> List[SimEvent]:
        """
        Progress all active R&D projects (Phase 4.5).
        Called each tick to increment progress and complete projects.
        """
        events = []
        
        all_teams = ([state.player_team] if state.player_team else []) + state.ai_teams
        
        for team in all_teams:
            for project in team.active_rd_projects:
                if project.completed or project.cancelled:
                    continue
                
                # Increment progress
                project.progress_ticks += 1
                
                # Check for completion (Phase 4.6)
                if project.progress_ticks >= project.duration_ticks:
                    project.completed = True
                    
                    # Create notification for player team development completion
                    if team == state.player_team:
                        try:
                            import plugins.ftb_notifications as ftb_notif
                            ftb_notif.create_notification(
                                category='development',
                                title=f"🔧 Development Complete: {project.project_name}",
                                message=f"R&D project completed for {team.name}. Check results in Development tab.",
                                priority=70,
                                metadata={'project_id': project.project_id, 'project_name': project.project_name},
                                db_path=getattr(state, 'state_db_path', None)
                            )
                        except Exception as e:
                            _dbg(f"[FTB] Failed to create dev completion notification: {e}")
                    
                    # Roll for success
                    rng = state.get_rng("rd_project", f"{project.project_id}_{project.started_tick}")
                    success = rng.random() < project.current_success_rate
                    
                    if success:
                        # Apply improvements
                        if project.project_type == "car_upgrade":
                            # Apply stat improvement to car
                            if project.target_stat and team.car:
                                old_value = team.car.current_ratings.get(project.target_stat, 50.0)
                                new_value = old_value + project.target_improvement
                                new_value = max(1.0, min(99.0, new_value))
                                team.car.current_ratings[project.target_stat] = new_value
                                
                                events.append(SimEvent(
                                    event_type="outcome",
                                    category="rd_project_success",
                                    ts=state.tick,
                                    priority=80.0,
                                    severity="info",
                                    data={
                                        'team': team.name,
                                        'project_id': project.project_id,
                                        'project_name': project.project_name,
                                        'stat': project.target_stat,
                                        'old_value': round(old_value, 2),
                                        'new_value': round(new_value, 2),
                                        'improvement': round(project.target_improvement, 2)
                                    }
                                ))
                        
                        elif project.project_type == "part_development" and project.generates_part:
                            # Generate custom part
                            part_id = f"custom_{project.part_type}_{team.name.replace(' ', '_')}_{state.tick}"
                            
                            # Use manufacturer name from team if available, or generate one
                            manufacturer_id = f"custom_{team.name.replace(' ', '_')}"
                            
                            # Create part with boosted stats
                            from ftb_names import generate_part_model_name
                            part_name = generate_part_model_name(state.seed, part_id, team.name, project.part_type, 1)
                            
                            custom_part = Part(
                                name=part_name,
                                age=0,
                                part_id=part_id,
                                part_type=project.part_type,
                                manufacturer_id=manufacturer_id,
                                tier_availability=[team.tier]
                            )
                            
                            # Initialize with boosted stats (10-20 points above baseline)
                            custom_part.current_ratings = STATS_SCHEMAS['Part'].copy()
                            rng_part = state.get_rng("custom_part", part_id)
                            for stat in custom_part.current_ratings:
                                boost = rng_part.uniform(10.0, 20.0)
                                custom_part.current_ratings[stat] = min(95.0, 50.0 + boost)
                            
                            custom_part.generation = 1
                            custom_part.release_year = state.sim_year
                            custom_part.compatibility_tags = team.car.architecture_tags[:2]  # Inherit top 2 tags
                            
                            # Generate regulatory exposure for custom parts (like regular parts)
                            custom_part.regulatory_exposure = {
                                'structural_margin': random.uniform(0.0, 1.0),
                                'aero_freedom': random.uniform(0.0, 1.0),
                                'power_ceiling': random.uniform(0.0, 1.0),
                                'reliability_mandate': random.uniform(0.0, 1.0),
                                'cost_cap_friendly': random.uniform(0.0, 1.0)
                            }
                            
                            custom_part.tier_minimum = team.tier
                            custom_part.tier_maximum = 5
                            
                            # Add to catalog and team inventory
                            state.parts_catalog[part_id] = custom_part
                            team.parts_inventory.append(custom_part)
                            
                            events.append(SimEvent(
                                event_type="outcome",
                                category="rd_part_developed",
                                ts=state.tick,
                                priority=85.0,
                                severity="info",
                                data={
                                    'team': team.name,
                                    'project_id': project.project_id,
                                    'project_name': project.project_name,
                                    'part_id': part_id,
                                    'part_name': part_name,
                                    'part_type': project.part_type,
                                    'performance_score': round(custom_part.performance_score, 2)
                                }
                            ))
                        
                        elif project.project_type == "infrastructure_unlock":
                            # Unlock infrastructure facility
                            facility_key = RD_PROJECT_CATALOG[project.project_id].get('facility_key', '')
                            if facility_key:
                                unlock_key = facility_key + '_unlocked'
                                team.infrastructure[unlock_key] = True
                                if facility_key not in team.infrastructure:
                                    team.infrastructure[facility_key] = 50.0  # Start at baseline quality
                                
                                events.append(SimEvent(
                                    event_type="structural",
                                    category="infrastructure_unlocked",
                                    ts=state.tick,
                                    priority=85.0,
                                    severity="info",
                                    data={
                                        'team': team.name,
                                        'project_id': project.project_id,
                                        'project_name': project.project_name,
                                        'facility': facility_key,
                                        'initial_quality': team.infrastructure.get(facility_key, 50.0)
                                    }
                                ))
                        
                        elif project.project_type == "infrastructure_upgrade":
                            # Upgrade infrastructure facility
                            facility_key = RD_PROJECT_CATALOG[project.project_id].get('facility_key', '')
                            quality_improvement = RD_PROJECT_CATALOG[project.project_id].get('quality_improvement', 5.0)
                            
                            if facility_key and facility_key in team.infrastructure:
                                old_quality = team.infrastructure[facility_key]
                                new_quality = min(100.0, old_quality + quality_improvement)
                                team.infrastructure[facility_key] = new_quality
                                
                                events.append(SimEvent(
                                    event_type="structural",
                                    category="infrastructure_upgraded",
                                    ts=state.tick,
                                    priority=80.0,
                                    severity="info",
                                    data={
                                        'team': team.name,
                                        'project_id': project.project_id,
                                        'project_name': project.project_name,
                                        'facility': facility_key,
                                        'old_quality': round(old_quality, 1),
                                        'new_quality': round(new_quality, 1),
                                        'improvement': round(quality_improvement, 1)
                                    }
                                ))
                        
                        # Morale boost (base for all project completions)
                        morale_boost = min(8.0, project.total_cost / 50000.0)
                        
                        # Infrastructure projects get additional morale boost
                        # Better facilities improve working conditions and team satisfaction
                        if project.project_type in ("infrastructure_unlock", "infrastructure_upgrade"):
                            infrastructure_morale_bonus = 4.0  # Additional flat bonus for infrastructure
                            if project.project_type == "infrastructure_unlock":
                                infrastructure_morale_bonus += 2.0  # Extra bonus for new facilities
                            morale_boost += infrastructure_morale_bonus
                        
                        team.standing_metrics['morale'] = min(100, team.standing_metrics['morale'] + morale_boost)
                        
                    else:
                        # Project failed
                        events.append(SimEvent(
                            event_type="outcome",
                            category="rd_project_failed",
                            ts=state.tick,
                            priority=75.0,
                            severity="warning",
                            data={
                                'team': team.name,
                                'project_id': project.project_id,
                                'project_name': project.project_name,
                                'cost_wasted': project.total_cost,
                                'success_rate': round(project.current_success_rate * 100, 1)
                            }
                        ))
                        
                        # Morale penalty
                        morale_penalty = min(6.0, project.total_cost / 75000.0)
                        team.standing_metrics['morale'] = max(0, team.standing_metrics['morale'] - morale_penalty)
        
        return events
    
    @staticmethod
    def _apply_purchase_upgrade(action: Action, team: Team, state: SimState) -> List[SimEvent]:
        """Purchase and install an upgrade package (Phase 5.4)"""
        events = []
        
        # action.target should be upgrade_id
        upgrade_id = action.target
        if not upgrade_id or upgrade_id not in UPGRADE_PACKAGE_CATALOG:
            return events
        
        upgrade_template = UPGRADE_PACKAGE_CATALOG[upgrade_id]
        
        # Validate tier access (Phase 5.5)
        if team.tier not in upgrade_template['tier_availability']:
            events.append(SimEvent(
                event_type="outcome",
                category="upgrade_rejected",
                ts=state.tick,
                priority=60.0,
                severity="warning",
                data={
                    'team': team.name,
                    'upgrade_id': upgrade_id,
                    'reason': f"Upgrade requires tier {min(upgrade_template['tier_availability'])}+",
                    'team_tier': team.tier
                }
            ))
            return events
        
        # Check for duplicate installation (Phase 5.8)
        if upgrade_id in team.installed_upgrades:
            events.append(SimEvent(
                event_type="outcome",
                category="upgrade_rejected",
                ts=state.tick,
                priority=60.0,
                severity="warning",
                data={
                    'team': team.name,
                    'upgrade_id': upgrade_id,
                    'reason': 'Upgrade already installed'
                }
            ))
            return events
        
        # Check for incompatible upgrades (Phase 5.5)
        incompatible = upgrade_template.get('incompatible_upgrades', [])
        for installed_id in team.installed_upgrades:
            if installed_id in incompatible:
                events.append(SimEvent(
                    event_type="outcome",
                    category="upgrade_rejected",
                    ts=state.tick,
                    priority=60.0,
                    severity="warning",
                    data={
                        'team': team.name,
                        'upgrade_id': upgrade_id,
                        'reason': f"Incompatible with installed upgrade: {installed_id}",
                        'conflicting_upgrade': installed_id
                    }
                ))
                return events
        
        # Check required parts (Phase 5.5)
        required_parts = upgrade_template.get('required_parts', [])
        for part_type in required_parts:
            if part_type not in team.equipped_parts:
                events.append(SimEvent(
                    event_type="outcome",
                    category="upgrade_rejected",
                    ts=state.tick,
                    priority=60.0,
                    severity="warning",
                    data={
                        'team': team.name,
                        'upgrade_id': upgrade_id,
                        'reason': f"Requires equipped {part_type}",
                        'missing_part_type': part_type
                    }
                ))
                return events
        
        # Check minimum car stats (Phase 5.5)
        min_stats = upgrade_template.get('min_car_stat', {})
        for stat_name, min_value in min_stats.items():
            current_value = team.car.current_ratings.get(stat_name, 50.0)
            if current_value < min_value:
                events.append(SimEvent(
                    event_type="outcome",
                    category="upgrade_rejected",
                    ts=state.tick,
                    priority=60.0,
                    severity="warning",
                    data={
                        'team': team.name,
                        'upgrade_id': upgrade_id,
                        'reason': f"Car {stat_name} too low: {current_value:.1f} < {min_value:.1f}",
                        'stat_name': stat_name,
                        'current_value': current_value,
                        'required_value': min_value
                    }
                ))
                return events
        
        # Install upgrade - apply stat improvements (Phase 5.6)
        stat_improvements = upgrade_template.get('stat_improvements', {})
        old_overall = team.car.overall_rating
        
        for stat_name, improvement in stat_improvements.items():
            if stat_name in team.car.current_ratings:
                old_value = team.car.current_ratings[stat_name]
                new_value = old_value + improvement
                new_value = max(1.0, min(99.0, new_value))
                team.car.current_ratings[stat_name] = new_value
        
        # Mark as installed (Phase 5.7)
        team.installed_upgrades.append(upgrade_id)
        
        new_overall = team.car.overall_rating
        rating_delta = new_overall - old_overall
        
        events.append(SimEvent(
            event_type="structural",
            category="upgrade_installed",
            ts=state.tick,
            priority=75.0,
            severity="info",
            data={
                'team': team.name,
                'upgrade_id': upgrade_id,
                'upgrade_name': upgrade_template['name'],
                'cost': upgrade_template['cost'],
                'stat_improvements': stat_improvements,
                'old_car_rating': round(old_overall, 2),
                'new_car_rating': round(new_overall, 2),
                'rating_delta': round(rating_delta, 2),
                'category': upgrade_template.get('category', 'performance')
            }
        ))
        
        # Morale boost from upgrade
        morale_boost = min(7.0, rating_delta * 0.8)
        team.standing_metrics['morale'] = min(100, team.standing_metrics['morale'] + morale_boost)
        
        return events
    
    @staticmethod
    def _apply_install_upgrade(action: Action, team: Team, state: SimState) -> List[SimEvent]:
        """Install upgrade (alias for purchase_upgrade for backward compatibility)"""
        return FTBSimulation._apply_purchase_upgrade(action, team, state)
    
    @staticmethod
    def _apply_accept_sponsor(action: Action, team: Team, state: SimState) -> List[SimEvent]:
        """Accept a sponsor offer from pending offers"""
        events = []
        
        # action.target should be the sponsor index in pending_offers
        if team.name not in state.pending_sponsor_offers:
            return events
        
        sponsor_index = action.target if isinstance(action.target, int) else 0
        if sponsor_index >= len(state.pending_sponsor_offers[team.name]):
            return events
        
        sponsor = state.pending_sponsor_offers[team.name][sponsor_index]
        
        # Check exclusivity conflicts
        conflicts = []
        for clause in sponsor.exclusivity_clauses:
            # Check against existing sponsors
            for existing_sponsor in state.sponsorships.get(team.name, []):
                if clause in existing_sponsor.exclusivity_clauses:
                    conflicts.append(f"Conflict with {existing_sponsor.sponsor_name}: {clause}")
        
        if conflicts:
            events.append(SimEvent(
                event_type="outcome",
                category="sponsor_offer_rejected",
                ts=state.tick,
                priority=60.0,
                severity="warning",
                data={
                    'team': team.name,
                    'sponsor_name': sponsor.sponsor_name,
                    'conflicts': conflicts
                }
            ))
            return events
        
        # Sign the sponsor
        sponsor.signed_tick = state.tick
        sponsor.last_evaluated_tick = state.tick
        sponsor.last_payment_tick = state.tick
        
        # Move to active sponsorships
        if team.name not in state.sponsorships:
            state.sponsorships[team.name] = []
        state.sponsorships[team.name].append(sponsor)
        
        # Remove from pending offers
        state.pending_sponsor_offers[team.name].pop(sponsor_index)
        
        # Mark sponsors dirty to trigger UI refresh
        state.mark_dirty('sponsors')
        
        # Generate event
        events.append(SimEvent(
            event_type="outcome",
            category="sponsor_signed",
            ts=state.tick,
            priority=80.0,
            severity="success",
            data={
                'team': team.name,
                'sponsor_name': sponsor.sponsor_name,
                'tier': sponsor.tier,
                'payment_per_season': sponsor.base_payment_per_season,
                'duration_seasons': sponsor.duration_seasons,
                'exclusivity_clauses': sponsor.exclusivity_clauses
            },
            description=f"{team.name} signed {sponsor.sponsor_name} (${sponsor.base_payment_per_season:,}/season)"
        ))
        
        return events
    
    @staticmethod
    def _apply_reject_sponsor(action: Action, team: Team, state: SimState) -> List[SimEvent]:
        """Reject a sponsor offer"""
        events = []
        
        if team.name not in state.pending_sponsor_offers:
            return events
        
        sponsor_index = action.target if isinstance(action.target, int) else 0
        if sponsor_index >= len(state.pending_sponsor_offers[team.name]):
            return events
        
        sponsor = state.pending_sponsor_offers[team.name].pop(sponsor_index)
        
        events.append(SimEvent(
            event_type="outcome",
            category="sponsor_offer_rejected",
            ts=state.tick,
            priority=40.0,
            severity="info",
            data={
                'team': team.name,
                'sponsor_name': sponsor.sponsor_name,
                'tier': sponsor.tier
            },
            description=f"{team.name} declined offer from {sponsor.sponsor_name}"
        ))
        
        return events
    
    @staticmethod
    def _apply_negotiate_renewal(action: Action, team: Team, state: SimState) -> List[SimEvent]:
        """Negotiate sponsor contract renewal"""
        events = []
        
        # action.target should be sponsor index in active sponsorships
        if team.name not in state.sponsorships:
            return events
        
        sponsor_index = action.target if isinstance(action.target, int) else 0
        if sponsor_index >= len(state.sponsorships[team.name]):
            return events
        
        sponsor = state.sponsorships[team.name][sponsor_index]
        
        # Check if eligible for renewal (near end of contract)
        if sponsor.seasons_active < sponsor.duration_seasons - 1:
            events.append(SimEvent(
                event_type="outcome",
                category="renewal_too_early",
                ts=state.tick,
                priority=40.0,
                severity="info",
                data={
                    'team': team.name,
                    'sponsor_name': sponsor.sponsor_name,
                    'seasons_remaining': sponsor.duration_seasons - sponsor.seasons_active
                }
            ))
            return events
        
        # Calculate renewal terms based on confidence and loyalty
        try:
            behavior = json.loads(sponsor.contract_behavior_json) if sponsor.contract_behavior_json else {}
        except:
            behavior = {}
        
        loyalty = behavior.get('loyalty', 0.5)
        
        # Renewal probability
        renewal_prob = loyalty + (sponsor.confidence - 50.0) / 100.0
        
        if renewal_prob > 0.6:  # Likely to renew
            # Adjust payment based on performance
            payment_adjustment = 1.0 + (sponsor.confidence - 75.0) / 100.0
            new_payment = int(sponsor.base_payment_per_season * payment_adjustment)
            
            # Reset contract
            sponsor.duration_seasons += 2  # Add 2 more seasons
            sponsor.base_payment_per_season = new_payment
            sponsor.warning_issued = False
            
            events.append(SimEvent(
                event_type="outcome",
                category="sponsor_renewed",
                ts=state.tick,
                priority=75.0,
                severity="success",
                data={
                    'team': team.name,
                    'sponsor_name': sponsor.sponsor_name,
                    'new_payment': new_payment,
                    'old_payment': sponsor.base_payment_per_season,
                    'additional_seasons': 2,
                    'confidence': sponsor.confidence
                }
            ))
        else:
            events.append(SimEvent(
                event_type="outcome",
                category="renewal_declined",
                ts=state.tick,
                priority=70.0,
                severity="warning",
                data={
                    'team': team.name,
                    'sponsor_name': sponsor.sponsor_name,
                    'confidence': sponsor.confidence,
                    'loyalty': loyalty
                }
            ))
        
        return events
    
    @staticmethod
    def _apply_terminate_sponsor(action: Action, team: Team, state: SimState) -> List[SimEvent]:
        """Player-initiated early termination of sponsor contract"""
        events = []
        
        if team.name not in state.sponsorships:
            return events
        
        sponsor_index = action.target if isinstance(action.target, int) else 0
        if sponsor_index >= len(state.sponsorships[team.name]):
            return events
        
        sponsor = state.sponsorships[team.name][sponsor_index]
        
        # Calculate early termination penalty
        seasons_remaining = sponsor.duration_seasons - sponsor.seasons_active
        penalty = int(sponsor.base_payment_per_season * seasons_remaining * 0.5)
        
        # Deduct penalty from budget
        team.budget.cash -= penalty
        
        # Remove sponsor
        state.sponsorships[team.name].pop(sponsor_index)
        
        # Apply reputation hit
        if hasattr(team, 'standing_metrics'):
            team.standing_metrics['reputation'] = max(0, team.standing_metrics.get('reputation', 50) - 10.0)
        
        events.append(SimEvent(
            event_type="outcome",
            category="sponsor_terminated_early",
            ts=state.tick,
            priority=70.0,
            severity="warning",
            data={
                'team': team.name,
                'sponsor_name': sponsor.sponsor_name,
                'penalty': penalty,
                'seasons_remaining': seasons_remaining,
                'reputation_loss': 10.0
            },
            description=f"{team.name} terminated {sponsor.sponsor_name} contract (penalty: ${penalty:,})"
        ))
        
        return events
    
    @staticmethod
    def _process_manufacturer_innovation(state: SimState) -> List[SimEvent]:
        """
        Phase 6.1-6.3: Manufacturer innovation cycles - release new part generations periodically.
        Each manufacturer independently tracks innovation cadence based on innovation_velocity.
        """
        events = []
        
        for mfr_id, manufacturer in state.manufacturers.items():
            # Calculate innovation interval based on manufacturer's innovation velocity
            # Higher velocity = faster innovation cycles
            innovation_velocity = manufacturer.innovation_velocity
            base_interval = 500  # Base ticks between generations
            velocity_modifier = 100.0 / max(50.0, innovation_velocity)  # Faster at higher velocity
            innovation_interval = int(base_interval * velocity_modifier)
            
            # Check if it's time to innovate
            ticks_since_last = state.tick - manufacturer.last_innovation_tick
            if ticks_since_last >= innovation_interval:
                # Release new generation
                old_generation = manufacturer.current_generation
                manufacturer.current_generation += 1
                manufacturer.last_innovation_tick = state.tick
                new_generation = manufacturer.current_generation
                
                # Generate new parts for this generation
                new_parts_count = 0
                for part_type in ['engine', 'chassis', 'aero', 'suspension', 'electronics', 'cooling']:
                    # Generate new part for each tier the manufacturer serves
                    for tier in manufacturer.active_tiers:
                        # Import name generator
                        try:
                            from plugins.ftb_names import generate_part_model_name
                        except ImportError:
                            continue
                        
                        # Create new part ID and name
                        part_id = f"{mfr_id}_{part_type}_gen{new_generation}_t{tier}"
                        part_name = generate_part_model_name(
                            state.seed, part_id, manufacturer.name, part_type, new_generation
                        )
                        
                        # Create Part entity
                        part = Part()
                        part.entity_id = state._next_entity_id
                        state._next_entity_id += 1
                        part.part_id = part_id
                        part.name = part_name
                        part.display_name = part_name
                        part.part_type = part_type
                        part.manufacturer_id = mfr_id
                        part.generation = new_generation
                        part.introduction_year = state.sim_year
                        part.introduction_tick = state.tick
                        part.tier_minimum = tier
                        part.tier_maximum = 5
                        part.age = 0
                        
                        # Initialize stats from manufacturer stats + variance
                        rng = state.get_rng(f"part_gen_{part_id}", state.tick)
                        for stat_name in STATS_SCHEMAS.get('Part', []):
                            base_value = 50.0
                            
                            # Inherit manufacturer characteristics
                            if stat_name == 'reliability' and 'reliability_philosophy' in manufacturer.current_ratings:
                                base_value += (manufacturer.current_ratings['reliability_philosophy'] - 50) * 0.3
                            elif stat_name == 'build_quality' and 'build_quality' in manufacturer.current_ratings:
                                base_value += (manufacturer.current_ratings['build_quality'] - 50) * 0.3
                            
                            # Higher generation = higher base performance
                            generation_bonus = (new_generation - 1) * 3.0
                            base_value += generation_bonus
                            
                            # Add variance
                            variance = rng.uniform(-10.0, 10.0)
                            final_value = max(1.0, min(99.0, base_value + variance))
                            part.current_ratings[stat_name] = final_value
                        
                        # Set regulatory exposure
                        part.regulatory_exposure = {
                            'structural_margin': rng.uniform(0.0, 1.0),
                            'aero_freedom': rng.uniform(0.0, 1.0),
                            'power_ceiling': rng.uniform(0.0, 1.0),
                            'reliability_mandate': rng.uniform(0.0, 1.0),
                            'cost_cap_friendly': rng.uniform(0.0, 1.0)
                        }
                        
                        # Set compatibility tags
                        if part.current_ratings.get('peak_performance', 50) > 65:
                            part.compatibility_tags.append("high_performance")
                        if part.current_ratings.get('weight', 50) < 40:
                            part.compatibility_tags.append("lightweight")
                        if part.current_ratings.get('reliability', 50) > 65:
                            part.compatibility_tags.append("reliable")
                        
                        part.effectiveness_modifier = 1.0  # New parts start at full effectiveness
                        
                        # Add to catalog
                        state.parts_catalog[part.part_id] = part
                        new_parts_count += 1
                
                # Mark older generation parts as obsolete (Phase 6.3)
                obsoleted_count = 0
                for part_id, part in state.parts_catalog.items():
                    if part.manufacturer_id == mfr_id and part.generation < new_generation - 1:
                        # Parts 2+ generations old become obsolete
                        if part.effectiveness_modifier == 1.0:  # Not yet obsolete
                            part.effectiveness_modifier = 0.6  # 40% effectiveness penalty
                            obsoleted_count += 1
                
                # Generate event
                events.append(SimEvent(
                    event_type="structural",
                    category="manufacturer_innovation",
                    ts=state.tick,
                    priority=70.0,
                    severity="info",
                    data={
                        'manufacturer': manufacturer.name,
                        'manufacturer_id': mfr_id,
                        'old_generation': old_generation,
                        'new_generation': new_generation,
                        'new_parts_count': new_parts_count,
                        'obsoleted_parts_count': obsoleted_count,
                        'innovation_velocity': round(innovation_velocity, 2)
                    }
                ))
        
        return events
    
    @staticmethod
    def _propagate_obsolescence_effects(state: SimState) -> List[SimEvent]:
        """
        Phase 6.4: Check all teams for obsolete equipped parts and mark performance degradation.
        This runs every tick to ensure car ratings reflect current part effectiveness.
        """
        events = []
        
        for team in [state.player_team] + state.ai_teams if state.player_team else state.ai_teams:
            if not team or not team.car:
                continue
            
            obsolete_parts = []
            total_penalty = 0.0
            
            for slot, part in team.equipped_parts.items():
                if part.is_obsolete:
                    obsolete_parts.append({
                        'slot': slot,
                        'part_type': part.part_type,
                        'part_name': part.name,
                        'generation': part.generation,
                        'effectiveness': part.effectiveness_modifier
                    })
                    # Calculate penalty contribution
                    penalty = (1.0 - part.effectiveness_modifier) * 2.0  # Amplify obsolescence impact
                    total_penalty += penalty
            
            # If team has obsolete parts, generate warning event (only once per day to avoid spam)
            if obsolete_parts and state.tick % 10 == 0:  # Every 10 ticks
                events.append(SimEvent(
                    event_type="structural",
                    category="obsolete_parts_warning",
                    ts=state.tick,
                    priority=65.0,
                    severity="warning",
                    data={
                        'team': team.name,
                        'obsolete_parts': obsolete_parts,
                        'total_performance_penalty': round(total_penalty, 2),
                        'car_rating': round(team.car.overall_rating, 2)
                    }
                ))
        
        return events
    
    @staticmethod
    def _process_silly_season(state: SimState) -> List[SimEvent]:
        """Process Formula Z silly season during offseason: increased driver releases and hiring activity.
        
        Silly season characteristics:
        - AI teams release underperforming drivers more aggressively (40% vs 10% normal)
        - AI teams hire more actively (2x frequency)
        - Generates team signing announcements visible to player
        """
        events = []
        rng = random.Random(state.seed + state.tick + 777)
        
        # Only process for Formula Z tier teams
        formula_z_teams = [team for team in state.ai_teams if team and team.tier == 5]
        
        if not formula_z_teams:
            return events
        
        # Process AI team driver evaluations and releases
        for team in formula_z_teams:
            for driver in team.drivers[:]:  # Copy list to allow modification
                if driver is None:
                    continue
                
                # Evaluate driver performance
                performance_threshold = 55.0  # Below this rating = underperforming
                release_probability = 0.40  # 40% chance during silly season (vs 10% normal)
                
                if hasattr(driver, 'overall_rating') and driver.overall_rating < performance_threshold:
                    if rng.random() < release_probability:
                        # Release driver to free agency
                        team.drivers.remove(driver)
                        
                        # Add to free agent pool (convert per-tick to annual, with 20% discount)
                        per_tick_salary = estimate_salary_expectation(driver, team_tier=team.tier)
                        asking_salary = int(per_tick_salary * 365 * 0.8)  # Annual salary with discount
                        free_agent = FreeAgent(
                            entity=driver,
                            entity_type="Driver",
                            tier=team.tier,
                            overall_rating=driver.overall_rating,
                            asking_salary=asking_salary,
                            time_in_pool_days=0,
                            exit_reason="released_silly_season"
                        )
                        state.free_agents.append(free_agent)
                        
                        # Generate event
                        events.append(SimEvent(
                            event_type="structural",
                            category="ai_team_driver_release",
                            ts=state.tick,
                            priority=75.0,
                            severity="info",
                            data={
                                'team': team.name,
                                'driver_name': driver.name,
                                'driver_rating': driver.overall_rating,
                                'reason': 'underperformance',
                                'silly_season': True
                            },
                            description=f"{team.name} releases {driver.name} during silly season"
                        ))
        
        # AI team hiring spree - teams with vacant driver slots hire from free agency
        for team in formula_z_teams:
            # Check if team needs drivers
            max_drivers = TIER_FEATURES.get(team.tier, {}).get('max_drivers', 2)
            current_driver_count = len([d for d in team.drivers if d is not None])
            
            if current_driver_count < max_drivers and team.budget.cash > 500000:  # Need cash buffer
                # Find available free agent drivers in Formula Z
                available_drivers = [
                    fa for fa in state.free_agents 
                    if fa.entity_type == "Driver" and fa.tier >= 4  # Formula Y or Z level
                ]
                
                if available_drivers:
                    # Sort by rating, hire best available
                    available_drivers.sort(key=lambda fa: fa.overall_rating, reverse=True)
                    chosen_fa = available_drivers[0]
                    
                    # Hire driver
                    team.drivers.append(chosen_fa.entity)
                    state.free_agents.remove(chosen_fa)
                    
                    # Create contract
                    contract = Contract(
                        entity_id=chosen_fa.entity.entity_id,
                        team_name=team.name,
                        role="Driver",
                        start_day=state.sim_day_of_year,
                        duration_days=730,  # 2 years
                        base_salary=(chosen_fa.asking_salary / 365) * 1.1,  # 10% above asking (convert annual to per-tick)
                        signing_bonus=(chosen_fa.asking_salary / 365) * 0.2  # 20% signing bonus (per-tick)
                    )
                    state.contracts[chosen_fa.entity.entity_id] = contract
                    
                    # Generate hiring announcement event
                    events.append(SimEvent(
                        event_type="structural",
                        category="ai_team_hiring",
                        ts=state.tick,
                        priority=78.0,
                        severity="info",
                        data={
                            'team': team.name,
                            'driver_name': chosen_fa.entity.name,
                            'driver_rating': chosen_fa.overall_rating,
                            'contract_duration': 2,
                            'salary': contract.base_salary,
                            'silly_season': True
                        },
                        description=f"{team.name} signs {chosen_fa.entity.name} for 2 years"
                    ))
        
        return events
    
    @staticmethod
    def _progress_staff_training(state: SimState) -> List[SimEvent]:
        """
        Staff progression system with infrastructure impact.
        Engineers, mechanics, and strategists gain experience monthly.
        Infrastructure quality accelerates learning.
        """
        events = []
        
        all_teams = ([state.player_team] if state.player_team else []) + state.ai_teams
        
        for team in all_teams:
            # Calculate infrastructure learning multiplier
            factory_q = team.infrastructure.get('factory_quality', 50.0)
            simulator_q = team.infrastructure.get('simulator', 50.0)
            wind_tunnel_q = team.infrastructure.get('wind_tunnel', 50.0)
            
            # Check if facilities are unlocked
            simulator_unlocked = team.infrastructure.get('simulator_unlocked', False)
            wind_tunnel_unlocked = team.infrastructure.get('wind_tunnel_unlocked', False)
            
            # Only count unlocked facilities
            facilities = [factory_q]  # Factory always counts
            if simulator_unlocked:
                facilities.append(simulator_q)
            if wind_tunnel_unlocked:
                facilities.append(wind_tunnel_q)
            
            avg_infra = sum(facilities) / len(facilities)
            # Multiplier ranges from 0.5x (quality 0) to 1.5x (quality 100)
            infra_multiplier = 0.5 + (avg_infra / 100.0)
            
            # Progress engineers
            improved_engineers = []
            for engineer in team.engineers:
                base_growth = 0.12  # 0.12 points per month baseline
                growth_rate = base_growth * infra_multiplier
                
                # Apply growth to key stats that can improve with experience
                improvable_stats = [
                    'technical_depth', 'iteration_speed', 'upgrade_effectiveness',
                    'delivery_discipline', 'correlation_accuracy', 'simulation_fidelity',
                    'team_collaboration', 'communication_clarity'
                ]
                
                any_improvement = False
                for stat in improvable_stats:
                    old_value = engineer.current_ratings.get(stat, 50.0)
                    if old_value < 95.0:  # Cap growth at 95
                        new_value = min(95.0, old_value + growth_rate)
                        engineer.current_ratings[stat] = new_value
                        any_improvement = True
                
                if any_improvement:
                    improved_engineers.append(engineer.name)
            
            # Progress mechanics
            improved_mechanics = []
            for mechanic in team.mechanics:
                base_growth = 0.10
                growth_rate = base_growth * infra_multiplier
                
                improvable_stats = [
                    'build_quality', 'assembly_precision', 'pit_execution',
                    'coordination', 'reaction_time', 'mechanical_diagnosis',
                    'problem_solving', 'consistency'
                ]
                
                any_improvement = False
                for stat in improvable_stats:
                    old_value = mechanic.current_ratings.get(stat, 50.0)
                    if old_value < 95.0:
                        new_value = min(95.0, old_value + growth_rate)
                        mechanic.current_ratings[stat] = new_value
                        any_improvement = True
                
                if any_improvement:
                    improved_mechanics.append(mechanic.name)
            
            # Progress strategist
            if team.strategist:
                base_growth = 0.10
                growth_rate = base_growth * infra_multiplier
                
                improvable_stats = [
                    'race_reading', 'situational_awareness', 'timing_sense',
                    'call_latency', 'risk_assessment', 'contingency_planning'
                ]
                
                any_improvement = False
                for stat in improvable_stats:
                    old_value = team.strategist.current_ratings.get(stat, 50.0)
                    if old_value < 95.0:
                        new_value = min(95.0, old_value + growth_rate)
                        team.strategist.current_ratings[stat] = new_value
                        any_improvement = True
                
                if any_improvement and team == state.player_team:
                    # Only notify for player team
                    events.append(SimEvent(
                        event_type="structural",
                        category="staff_improved",
                        ts=state.tick,
                        priority=50.0,
                        severity="info",
                        data={
                            'team': team.name,
                            'staff_type': 'strategist',
                            'staff_name': team.strategist.name,
                            'infrastructure_multiplier': round(infra_multiplier, 2)
                        }
                    ))
            
            # Emit summary event for player team if any staff improved
            if team == state.player_team and (improved_engineers or improved_mechanics):
                events.append(SimEvent(
                    event_type="structural",
                    category="staff_training_monthly",
                    ts=state.tick,
                    priority=45.0,
                    severity="info",
                    data={
                        'team': team.name,
                        'engineers_improved': len(improved_engineers),
                        'mechanics_improved': len(improved_mechanics),
                        'infrastructure_multiplier': round(infra_multiplier, 2),
                        'avg_infrastructure_quality': round(avg_infra, 1)
                    }
                ))
        
        return events
    
    @staticmethod
    def _process_economic_downturn(state: SimState, rng: random.Random) -> List[SimEvent]:
        """
        Trigger rare economic downturn events that affect sponsor market league-wide.
        2-5% chance per season, lasts 2-4 seasons.
        """
        events = []
        
        # Check if downturn is currently active
        if state.economic_state['downturn_active']:
            # Check if downturn should end
            if state.tick >= state.economic_state['downturn_end_tick']:
                state.economic_state['downturn_active'] = False
                state.economic_state['sponsor_market_multiplier'] = 1.0
                
                events.append(SimEvent(
                    event_type="outcome",
                    category="economic_recovery",
                    ts=state.tick,
                    priority=80.0,
                    severity="major",
                    data={
                        'message': 'Sponsor market recovering - economic downturn ends',
                        'multiplier_restored': 1.0
                    }
                ))
                _dbg(f"[FTB] Economic downturn ended at tick {state.tick}")
            return events
        
        # Check for new downturn trigger (very rare)
        ticks_since_last_downturn = state.tick - state.economic_state['last_downturn_tick']
        ticks_per_season = 365 * 7  # Approx 365 days * 7 ticks/day
        seasons_since_last = ticks_since_last_downturn / ticks_per_season
        
        # Only check if it's been at least 3 seasons since last downturn
        if seasons_since_last >= 3.0:
            # 2-5% chance per season = ~0.16-0.42% chance per month
            monthly_chance = 0.003  # ~3.6% per year
            
            if rng.random() < monthly_chance:
                # Trigger economic downturn
                duration_seasons = rng.randint(2, 4)
                duration_ticks = duration_seasons * ticks_per_season
                
                # Set market multiplier (15-25% reduction)
                multiplier = 0.75 + (rng.random() * 0.10)  # 0.75 to 0.85
                
                state.economic_state['downturn_active'] = True
                state.economic_state['sponsor_market_multiplier'] = multiplier
                state.economic_state['last_downturn_tick'] = state.tick
                state.economic_state['downturn_end_tick'] = state.tick + duration_ticks
                
                events.append(SimEvent(
                    event_type="pressure",
                    category="economic_downturn",
                    ts=state.tick,
                    priority=85.0,
                    severity="major",
                    data={
                        'message': f'Economic downturn begins - sponsor budgets reduced {int((1-multiplier)*100)}% for {duration_seasons} seasons',
                        'multiplier': multiplier,
                        'duration_seasons': duration_seasons
                    }
                ))
                
                _dbg(f"[FTB] Economic downturn triggered: {multiplier:.2f}x multiplier for {duration_seasons} seasons")
        
        return events
    
    @staticmethod
    def _process_meta_shifts(state: SimState) -> List[SimEvent]:
        """
        Phase 6.5-6.6: Meta shifting based on regulatory changes.
        Periodically adjust part stat weights and regulatory exposure to create strategic variety.
        """
        events = []
        
        # Check for meta shifts every ~300 ticks (roughly once per season)
        if state.tick % 300 != 0:
            return events
        
        rng = state.get_rng("meta_shift", state.tick)
        
        # Define possible meta shifts (regulatory focus changes)
        meta_shifts = [
            {
                'name': 'Aero Restriction',
                'description': 'New regulations limit downforce, favoring mechanical grip',
                'stat_modifiers': {'aero_efficiency': -10.0, 'handling': +8.0, 'cornering_balance': +6.0},
                'part_type_impact': {'aero': -0.15, 'suspension': +0.15}
            },
            {
                'name': 'Power Unit Innovation',
                'description': 'Engine development unfrozen, power units gain importance',
                'stat_modifiers': {'power_output': +12.0, 'fuel_efficiency': +8.0},
                'part_type_impact': {'engine': +0.20, 'cooling': +0.10}
            },
            {
                'name': 'Cost Cap Adjustment',
                'description': 'Budget restrictions tightened, reliability becomes critical',
                'stat_modifiers': {'reliability': +10.0, 'durability': +8.0},
                'part_type_impact': {'chassis': +0.12, 'electronics': +0.08}
            },
            {
                'name': 'Ground Effect Era',
                'description': 'Return to ground effect aerodynamics favors low-rake designs',
                'stat_modifiers': {'downforce_peak': +10.0, 'aero_efficiency': +7.0, 'ride_stiffness': -5.0},
                'part_type_impact': {'aero': +0.18, 'suspension': +0.12}
            }
        ]
        
        # Select a random meta shift
        shift = rng.choice(meta_shifts)
        
        # Apply stat modifiers to all parts in catalog (recalibrate performance)
        affected_parts = 0
        for part_id, part in state.parts_catalog.items():
            for stat_name, modifier in shift['stat_modifiers'].items():
                if stat_name in part.current_ratings:
                    old_value = part.current_ratings[stat_name]
                    new_value = max(1.0, min(99.0, old_value + modifier))
                    part.current_ratings[stat_name] = new_value
                    affected_parts += 1
        
        # Update current meta tracking
        state.current_meta = {
            'name': shift['name'],
            'description': shift['description'],
            'applied_tick': state.tick,
            'stat_modifiers': shift['stat_modifiers'],
            'part_type_impact': shift['part_type_impact']
        }
        
        events.append(SimEvent(
            event_type="structural",
            category="meta_shift",
            ts=state.tick,
            priority=85.0,
            severity="major",
            data={
                'shift_name': shift['name'],
                'description': shift['description'],
                'stat_modifiers': shift['stat_modifiers'],
                'affected_parts_count': affected_parts
            }
        ))
        
        return events
    
    @staticmethod
    def _process_competitive_pressure(state: SimState) -> List[SimEvent]:
        """
        Phase 6.7-6.9: Competitive pressure triggering innovation.
        When a team dominates, manufacturers accelerate innovation to help other teams catch up.
        """
        events = []
        
        # Check every 50 ticks
        if state.tick % 50 != 0:
            return events
        
        # Analyze championship standings to detect dominance
        dominant_teams = []
        for league_id, league in state.leagues.items():
            if not league.championship_table:
                continue
            
            # Get top team points
            sorted_standings = sorted(league.championship_table.items(), key=lambda x: x[1], reverse=True)
            if len(sorted_standings) < 2:
                continue
            
            top_team_name, top_points = sorted_standings[0]
            second_team_name, second_points = sorted_standings[1]
            
            # Dominance threshold: 30+ point gap
            if top_points - second_points >= 30:
                dominant_teams.append({
                    'team_name': top_team_name,
                    'points': top_points,
                    'gap': top_points - second_points,
                    'league': league.name,
                    'tier': league.tier
                })
        
        # If dominance detected, trigger manufacturer innovation acceleration
        if dominant_teams:
            for mfr_id, manufacturer in state.manufacturers.items():
                # 30% chance per dominant situation to trigger early innovation
                rng = state.get_rng(f"competitive_pressure_{mfr_id}", state.tick)
                if rng.random() < 0.30:
                    # Reduce time to next innovation by 20%
                    ticks_since_last = state.tick - manufacturer.last_innovation_tick
                    innovation_velocity = manufacturer.innovation_velocity
                    base_interval = 500
                    velocity_modifier = 100.0 / max(50.0, innovation_velocity)
                    innovation_interval = int(base_interval * velocity_modifier)
                    
                    # If close to next innovation, trigger it early
                    if ticks_since_last >= innovation_interval * 0.80:
                        manufacturer.last_innovation_tick = state.tick - innovation_interval  # Reset timer to trigger immediately
                        
                        events.append(SimEvent(
                            event_type="structural",
                            category="innovation_accelerated",
                            ts=state.tick,
                            priority=75.0,
                            severity="info",
                            data={
                                'manufacturer': manufacturer.name,
                                'trigger': 'competitive_pressure',
                                'dominant_teams': [dt['team_name'] for dt in dominant_teams]
                            }
                        ))
        
        return events
    
    @staticmethod
    def calculate_part_cost(part: Part) -> float:
        """
        Calculate purchase price for a part based on generation, tier, performance.
        Returns integer cost in dollars.
        """
        base_cost = {
            'engine': 100000,
            'chassis': 150000,
            'aero_package': 120000,
            'suspension': 80000,
            'tires': 30000,
            'brakes': 50000,
            'cooling': 60000,
            'electronics': 90000,
            'transmission': 85000
        }
        
        cost = base_cost.get(part.part_type, 50000)
        
        # Generation multiplier (newer = more expensive)
        cost *= (1.0 + (part.generation - 1) * 0.25)
        
        # Performance multiplier
        perf_ratio = part.performance_score / 50.0
        cost *= perf_ratio
        
        # Tier multiplier
        cost *= (1.0 + (part.tier_minimum - 1) * 0.2)
        
        return int(cost)
    
    @staticmethod
    def _resolve_pending_developments(state: SimState) -> List[SimEvent]:
        """
        Check for pending developments that should resolve this tick.
        Roll outcomes based on engineer bonus and update car stats.
        """
        events = []
        resolved = []
        
        for dev in state.pending_developments:
            if dev['resolve_tick'] <= state.tick:
                # Find team
                team = state.player_team if state.player_team and state.player_team.name == dev['team_name'] else None
                if not team:
                    team = next((t for t in state.ai_teams if t.name == dev['team_name']), None)
                
                if not team or not team.car:
                    resolved.append(dev)
                    continue
                
                # Roll outcome: success / minor gain / regression
                # Engineer bonus (0-100) biases toward success
                rng = state.get_rng("dev", f"resolve_{dev['initiated_tick']}")
                roll = rng.random() * 100.0
                
                # Base probabilities: 30% regression, 40% minor, 30% breakthrough
                # Engineer bonus shifts these: +1% success per engineer point above 50
                engineer_bonus = dev['engineer_bonus']
                success_threshold = 70.0 - (engineer_bonus - 50.0)  # Lower threshold = easier success
                minor_threshold = 30.0
                
                if roll < minor_threshold:
                    outcome = "regression"
                    rating_change = -rng.uniform(1.0, 3.0)
                elif roll < success_threshold:
                    outcome = "minor_gain"
                    rating_change = rng.uniform(0.5, 2.0)
                else:
                    outcome = "breakthrough"
                    rating_change = rng.uniform(2.0, 5.0)
                
                # Apply to car (update a random stat)
                stat_names = list(team.car.current_ratings.keys())
                if stat_names:
                    target_stat = rng.choice(stat_names)
                    old_value = team.car.current_ratings[target_stat]
                    team.car.current_ratings[target_stat] = max(0, min(100, old_value + rating_change))
                    new_value = team.car.current_ratings[target_stat]
                    
                    events.append(SimEvent(
                        event_type="outcome",
                        category="development_result",
                        ts=state.tick,
                        priority=70.0,
                        severity="info" if outcome != "regression" else "warning",
                        data={
                            'team': team.name,
                            'outcome': outcome,
                            'stat': target_stat,
                            'old_value': old_value,
                            'new_value': new_value,
                            'change': rating_change,
                            'cost': dev['cost'],
                            'engineer_bonus': engineer_bonus
                        }
                    ))
                
                resolved.append(dev)
        
        # Remove resolved developments
        for dev in resolved:
            state.pending_developments.remove(dev)
        
        return events
    
    @staticmethod
    def _execute_ai_team_actions(state: SimState) -> List[SimEvent]:
        """
        AI teams probabilistically execute actions (10% chance per team per tick).
        Includes hiring, firing, and poaching behavior.
        """
        events = []
        rng = state.get_rng("ai_actions", state.tick)
        
        for team in state.ai_teams:
            # SAFETY CHECK: Never process player team in AI team actions
            # Compare by name since team_id changes across save/load cycles
            if state.player_team and team.name == state.player_team.name:
                _dbg(f"[FTB AI_ACTIONS] ✓ Skipping player team '{team.name}' from AI actions (safety check passed)")
                continue
            if rng.random() < 0.10:  # 10% chance per tick
                _dbg(f"[FTB AI_ACTIONS] AI team '{team.name}' executing action (player team is '{state.player_team.name if state.player_team else 'None'}')")
                # Determine action type (Phase 4.9: add R&D for tier 4+, Phase 5.9: add upgrades for tier 2+)
                team_features = TIER_FEATURES.get(team.tier, TIER_FEATURES[1])
                
                if team_features.get('can_rd_projects', False):
                    # Tier 4+: include R&D projects, upgrades, parts, infrastructure, job board, and sponsors
                    action_type = rng.choices(
                        ['hire', 'fire', 'poach', 'develop', 'rd_project', 'upgrade_package', 'purchase_part', 'infrastructure_upgrade', 'job_board', 'sponsor_management'],
                        weights=[0.20, 0.07, 0.10, 0.12, 0.10, 0.07, 0.17, 0.12, 0.02, 0.03]
                    )[0]
                elif team.tier >= 2:
                    # Tier 2-3: include upgrades, parts, infrastructure, job board, and sponsors but no R&D
                    action_type = rng.choices(
                        ['hire', 'fire', 'poach', 'develop', 'upgrade_package', 'purchase_part', 'infrastructure_upgrade', 'job_board', 'sponsor_management'],
                        weights=[0.25, 0.08, 0.12, 0.12, 0.07, 0.18, 0.11, 0.02, 0.05]
                    )[0]
                else:
                    # Tier 1: no R&D, upgrades, or parts but can upgrade infrastructure, apply for jobs, and manage sponsors
                    action_type = rng.choices(
                        ['hire', 'fire', 'poach', 'develop', 'infrastructure_upgrade', 'job_board', 'sponsor_management'],
                        weights=[0.32, 0.07, 0.15, 0.23, 0.14, 0.03, 0.06]
                    )[0]
                
                # HIRING: Fill vacant positions or upgrade weak staff (Phase 3.4: tier-aware)
                if action_type == 'hire':
                    # Get tier features for this team
                    team_features = TIER_FEATURES.get(team.tier, TIER_FEATURES[1])
                    
                    # Check if team needs staff (respecting tier limits)
                    needs_driver = len(team.drivers) < team_features['max_drivers']
                    needs_engineer = len(team.engineers) < team_features['max_engineers']
                    needs_mechanic = len(team.mechanics) < team_features['max_mechanics']
                    needs_strategist = team.strategist is None and team_features['can_hire_strategist']
                    
                    hire_role = None
                    if needs_driver:
                        hire_role = 'driver'
                    elif needs_engineer and rng.random() < 0.6:
                        hire_role = 'engineer'
                    elif needs_mechanic and rng.random() < 0.4:
                        hire_role = 'mechanic'
                    elif needs_strategist and rng.random() < 0.3:
                        hire_role = 'strategist'
                    
                    if hire_role and team.budget.cash >= 50000:
                        action = Action(f"hire_{hire_role}", cost=50000, target=None)
                        action_events = FTBSimulation.apply_action(action, team, state)
                        events.extend(action_events)
                
                # FIRING: Remove underperforming staff
                elif action_type == 'fire':
                    _dbg(f"[FTB AI_ACTIONS] Team '{team.name}' considering firing action (player team: '{state.player_team.name if state.player_team else 'None'}')")
                    # Find worst performing driver (if have multiple)
                    if len(team.drivers) > 1:
                        worst_driver = min(team.drivers, key=lambda d: d.overall_rating)
                        if worst_driver.overall_rating < 40:  # Only fire if truly bad
                            _dbg(f"[FTB AI_ACTIONS] Team '{team.name}' firing driver '{worst_driver.name}' (rating: {worst_driver.overall_rating})")
                            action = Action('fire_driver', cost=0, target=worst_driver.name)
                            action_events = FTBSimulation.apply_action(action, team, state)
                            events.extend(action_events)
                
                # POACHING: Try to hire from other teams (higher tier teams poach lower tier)
                elif action_type == 'poach':
                    # Find team's league tier
                    team_tier = 0
                    for league_id, league in state.leagues.items():
                        if team in league.teams:
                            team_tier = league.tier
                            break
                    
                    # Only teams in tier 2+ can poach
                    if team_tier >= 2 and team.budget.cash >= 150000:
                        # Find lower tier teams
                        lower_tier_teams = []
                        for other_team in state.ai_teams:
                            if other_team == team:
                                continue
                            other_tier = 0
                            for league_id, league in state.leagues.items():
                                if other_team in league.teams:
                                    other_tier = league.tier
                                    break
                            if other_tier < team_tier:
                                lower_tier_teams.append(other_team)
                        
                        if lower_tier_teams:
                            target_team = rng.choice(lower_tier_teams)
                            # Try to poach their best driver
                            if target_team.drivers:
                                best_driver = max(target_team.drivers, key=lambda d: d.overall_rating)
                                if best_driver.overall_rating >= 60:  # Only poach good drivers
                                    # 50% success chance
                                    if rng.random() < 0.5:
                                        # Remove from old team
                                        target_team.drivers.remove(best_driver)
                                        target_team.budget.remove_staff_salary(best_driver.name)
                                        if hasattr(best_driver, 'entity_id') and best_driver.entity_id in state.contracts:
                                            del state.contracts[best_driver.entity_id]
                                        
                                        # Add to new team
                                        team.drivers.append(best_driver)
                                        # ML ECONOMIC REALISM: Cap salary increases at 50% (matches poaching premium)
                                        base_salary = SALARY_BASE['Driver'] * (best_driver.overall_rating / 50.0)
                                        # Apply tier multiplier
                                        tier_mult = TIER_SALARY_MULTIPLIER.get(team.tier, 1.0)
                                        # Cap increase at 50% (1.5x multiplier)
                                        max_salary_mult = 1.5
                                        new_salary = base_salary * tier_mult * max_salary_mult
                                        team.budget.add_staff_salary(best_driver.name, new_salary)
                                        team.budget.cash -= 150000  # Poaching fee
                                        
                                        # Create contract
                                        contract_duration_days = int(rng.uniform(104, 156) * 7)
                                        contract = Contract(
                                            entity_id=best_driver.entity_id,
                                            entity_name=best_driver.name,
                                            team_name=team.name,
                                            role="Driver",
                                            start_day=state.sim_day_of_year,
                                            duration_days=contract_duration_days,
                                            base_salary=int(new_salary * 365)  # Convert per-tick to per-season
                                        )
                                        state.contracts[best_driver.entity_id] = contract
                                        
                                        events.append(SimEvent(
                                            event_type="structural",
                                            category="driver_poached",
                                            ts=state.tick,
                                            priority=75.0,
                                            severity="major",
                                            data={
                                                'poaching_team': team.name,
                                                'losing_team': target_team.name,
                                                'driver': best_driver.name,
                                                'new_salary': new_salary,
                                                'poaching_fee': 150000
                                            }
                                        ))
                
                # R&D PROJECTS: Start new R&D project (Phase 4.9)
                elif action_type == 'rd_project':
                    # Check if team can afford R&D and isn't already running too many projects
                    active_projects = [p for p in team.active_rd_projects if not p.completed and not p.cancelled]
                    max_concurrent = 2 if team.tier >= 5 else 1  # Formula Z can run 2 projects, others 1
                    
                    if len(active_projects) < max_concurrent and team.budget.cash >= 200000:
                        # Select a project that fits budget and isn't already running
                        available_projects = []
                        for project_id, template in RD_PROJECT_CATALOG.items():
                            # Check tier access
                            if template.get('min_tier', 4) > team.tier:
                                continue
                            # Check if already running
                            if any(p.project_id == project_id for p in active_projects):
                                continue
                            # Check budget
                            if template['cost'] <= team.budget.cash * 0.3:  # Don't spend more than 30% of budget
                                available_projects.append(project_id)
                        
                        if available_projects:
                            # Select project based on team needs (find weakest car stat)
                            if team.car and rng.random() < 0.7:  # 70% of the time, target weakness
                                weakest_stat = None
                                weakest_value = 100.0
                                for stat_name, value in team.car.current_ratings.items():
                                    if value < weakest_value:
                                        weakest_value = value
                                        weakest_stat = stat_name
                                
                                # Find project that improves weakest stat
                                matching_projects = [
                                    pid for pid in available_projects
                                    if RD_PROJECT_CATALOG[pid].get('target_stat') == weakest_stat
                                ]
                                if matching_projects:
                                    selected_project = rng.choice(matching_projects)
                                else:
                                    selected_project = rng.choice(available_projects)
                            else:
                                # Random selection
                                selected_project = rng.choice(available_projects)
                            
                            project_cost = RD_PROJECT_CATALOG[selected_project]['cost']
                            action = Action('start_rd_' + selected_project, cost=project_cost, target=selected_project)
                            action_events = FTBSimulation.apply_action(action, team, state)
                            events.extend(action_events)
                
                # UPGRADE PACKAGES: Purchase upgrade packages (Phase 5.9)
                elif action_type == 'upgrade_package':
                    # Check if team can afford upgrades
                    if team.budget.cash >= 100000:
                        # Find available upgrades for this team's tier
                        available_upgrades = []
                        for upgrade_id, template in UPGRADE_PACKAGE_CATALOG.items():
                            # Check tier access
                            if team.tier not in template['tier_availability']:
                                continue
                            # Check if already installed
                            if upgrade_id in team.installed_upgrades:
                                continue
                            # Check incompatibilities
                            incompatible = template.get('incompatible_upgrades', [])
                            if any(installed_id in incompatible for installed_id in team.installed_upgrades):
                                continue
                            # Check required parts
                            required_parts = template.get('required_parts', [])
                            if not all(part_type in team.equipped_parts for part_type in required_parts):
                                continue
                            # Check minimum car stats
                            min_stats = template.get('min_car_stat', {})
                            meets_requirements = True
                            for stat_name, min_value in min_stats.items():
                                current_value = team.car.current_ratings.get(stat_name, 50.0)
                                if current_value < min_value:
                                    meets_requirements = False
                                    break
                            if not meets_requirements:
                                continue
                            # Check budget (don't spend more than 20% of budget)
                            if template['cost'] <= team.budget.cash * 0.20:
                                available_upgrades.append(upgrade_id)
                        
                        if available_upgrades:
                            # Select upgrade based on team needs (find weakest car stat)
                            if team.car and rng.random() < 0.7:  # 70% of the time, target weakness
                                weakest_stat = None
                                weakest_value = 100.0
                                for stat_name, value in team.car.current_ratings.items():
                                    if value < weakest_value:
                                        weakest_value = value
                                        weakest_stat = stat_name
                                
                                # Find upgrade that improves weakest stat
                                matching_upgrades = []
                                for upgrade_id in available_upgrades:
                                    stat_improvements = UPGRADE_PACKAGE_CATALOG[upgrade_id].get('stat_improvements', {})
                                    if weakest_stat in stat_improvements and stat_improvements[weakest_stat] > 0:
                                        matching_upgrades.append(upgrade_id)
                                
                                if matching_upgrades:
                                    selected_upgrade = rng.choice(matching_upgrades)
                                else:
                                    selected_upgrade = rng.choice(available_upgrades)
                            else:
                                # Random selection
                                selected_upgrade = rng.choice(available_upgrades)
                            
                            upgrade_cost = UPGRADE_PACKAGE_CATALOG[selected_upgrade]['cost']
                            action = Action('purchase_upgrade', cost=upgrade_cost, target=selected_upgrade)
                            action_events = FTBSimulation.apply_action(action, team, state)
                            events.extend(action_events)
                
                # PART PURCHASING: Buy new parts to replace obsolete ones (Phase 6.10)
                elif action_type == 'purchase_part':
                    # Check for obsolete equipped parts
                    obsolete_slots = [
                        slot for slot, part in team.equipped_parts.items()
                        if part.is_obsolete
                    ]
                    
                    # If no obsolete parts, occasionally upgrade anyway (20% chance)
                    if not obsolete_slots and rng.random() < 0.20 and team.budget.cash >= 50000:
                        # Pick random equipped slot to potentially upgrade
                        if team.equipped_parts:
                            obsolete_slots = [rng.choice(list(team.equipped_parts.keys()))]
                    
                    if obsolete_slots and team.budget.cash >= 50000:
                        # Pick most obsolete part type to replace
                        worst_slot = max(obsolete_slots, key=lambda s: 1.0 - team.equipped_parts[s].effectiveness_modifier)
                        worst_part_type = team.equipped_parts[worst_slot].part_type
                        current_generation = team.equipped_parts[worst_slot].generation
                        
                        # Find newer generation parts of same type
                        available_parts = [
                            p for p in state.parts_catalog.values()
                            if p.part_type == worst_part_type
                            and p.generation > current_generation
                            and team.tier >= p.tier_minimum
                            and team.tier <= p.tier_maximum
                            and not p.is_obsolete
                        ]
                        
                        if available_parts:
                            # Select newest generation part with best performance
                            best_part = max(available_parts, key=lambda p: (p.generation, p.performance_score))
                            part_cost = FTBSimulation.calculate_part_cost(best_part)
                            
                            # Don't spend more than 15% of budget on a single part
                            if part_cost <= team.budget.cash * 0.15:
                                # Purchase part
                                action = Action('purchase_part', cost=part_cost, target=best_part.part_id)
                                events_purchase = FTBSimulation.apply_action(action, team, state)
                                events.extend(events_purchase)
                                
                                # Auto-equip immediately
                                action_equip = Action('equip_part', cost=0, target=best_part.part_id)
                                events_equip = FTBSimulation.apply_action(action_equip, team, state)
                                events.extend(events_equip)
                
                # INFRASTRUCTURE UPGRADE: Improve facilities (all tiers)
                elif action_type == 'infrastructure_upgrade':
                    # Calculate available budget for infrastructure (15-25% of free cash)
                    budget_pct = INFRASTRUCTURE_EFFECTS['ai_upgrade_budget_pct']
                    available_budget = team.budget.cash * budget_pct
                    
                    # Don't upgrade if budget is too tight (less than $100k)
                    if available_budget < 100000:
                        pass  # Skip this action
                    else:
                        # Prioritize facilities based on team tier and current weaknesses
                        priority_facilities = []
                        
                        # Tier-based priorities
                        if team.tier == 1:
                            # Grassroots: focus on baseline facilities
                            priority_facilities = ['workshop', 'basic_simulator', 'data_logging']
                        elif team.tier == 2:
                            # Formula V: unlock tier 2 facilities first, then upgrade
                            unlockable = ['improved_simulator', 'fabrication', 'data_analysis', 'engineering_roles']
                            priority_facilities = [f for f in unlockable if not team.infrastructure.get(f'{f}_unlocked', False)]
                            if not priority_facilities:
                                priority_facilities = ['improved_simulator', 'fabrication', 'workshop']
                        elif team.tier == 3:
                            # Tier 3: continue upgrading tier 2 facilities
                            priority_facilities = ['improved_simulator', 'fabrication', 'data_analysis', 'workshop']
                        elif team.tier == 4:
                            # Formula Y: unlock arms race facilities
                            unlockable = ['wind_tunnel_entry', 'cfd_limited', 'rd_department', 'specialized_teams']
                            priority_facilities = [f for f in unlockable if not team.infrastructure.get(f'{f}_unlocked', False)]
                            if not priority_facilities:
                                priority_facilities = ['wind_tunnel_entry', 'cfd_limited', 'rd_department', 'factory_quality']
                        else:  # tier 5
                            # Formula Z: unlock ultimate facilities or upgrade existing
                            unlockable = ['wind_tunnel_advanced', 'cfd_advanced', 'regulation_analysis', 'redundant_infrastructure']
                            priority_facilities = [f for f in unlockable if not team.infrastructure.get(f'{f}_unlocked', False)]
                            if not priority_facilities:
                                priority_facilities = ['wind_tunnel_advanced', 'cfd_advanced', 'rd_department', 'specialized_teams']
                        
                        # Check sponsor infrastructure demands (higher priority)
                        sponsor_demands = []
                        if hasattr(team, 'sponsorships'):
                            for sponsor in team.sponsorships:
                                if sponsor.infrastructure_demands:
                                    for facility, required_quality in sponsor.infrastructure_demands.items():
                                        current_quality = team.infrastructure.get(facility, 50.0)
                                        if current_quality < required_quality:
                                            sponsor_demands.append((facility, required_quality - current_quality))
                            
                            # Sort by gap (highest priority first)
                            sponsor_demands.sort(key=lambda x: x[1], reverse=True)
                            
                            # Add sponsor-demanded facilities to priority list
                            for facility, _gap in sponsor_demands[:2]:  # Top 2 demands
                                if facility not in priority_facilities:
                                    priority_facilities.insert(0, facility)
                        
                        # Find weakest priority facility
                        weakest_facility = None
                        weakest_quality = 100.0
                        needs_unlock = False
                        
                        for facility in priority_facilities:
                            unlock_key = f"{facility}_unlocked"
                            if unlock_key in team.infrastructure and not team.infrastructure[unlock_key]:
                                # Facility needs unlocking
                                weakest_facility = facility
                                needs_unlock = True
                                break
                            elif facility in team.infrastructure:
                                quality = team.infrastructure[facility]
                                if quality < weakest_quality:
                                    weakest_quality = quality
                                    weakest_facility = facility
                        
                        if weakest_facility:
                            if needs_unlock:
                                # Try to start R&D project to unlock (tier 4+ only)
                                if team.tier >= 4 and team_features.get('can_rd_projects', False):
                                    # Find unlock project for this facility
                                    unlock_project_id = f"rd_unlock_{weakest_facility}"
                                    if unlock_project_id in RD_PROJECT_CATALOG:
                                        project_template = RD_PROJECT_CATALOG[unlock_project_id]
                                        if team.budget.cash >= project_template['cost']:
                                            action = Action('start_rd_project', cost=project_template['cost'], target=unlock_project_id)
                                            action_events = FTBSimulation.apply_action(action, team, state)
                                            events.extend(action_events)
                            else:
                                # Upgrade facility
                                if team.tier <= 3:
                                    # Use direct upgrade for tier 1-3
                                    upgrade_amount = min(10.0, 100.0 - weakest_quality)
                                    result = team.direct_upgrade_facility(weakest_facility, upgrade_amount)
                                    
                                    if result['success']:
                                        events.append(SimEvent(
                                            event_type="structural",
                                            category="infrastructure_upgraded",
                                            ts=state.tick,
                                            priority=55.0,
                                            severity="info",
                                            data={
                                                'team': team.name,
                                                'facility': weakest_facility,
                                                'old_quality': result['old_quality'],
                                                'new_quality': result['new_quality'],
                                                'cost': result['cost'],
                                                'upgrade_type': 'direct_purchase',
                                                'ai_decision': True
                                            }
                                        ))
                                else:
                                    # Tier 4+: try R&D upgrade project
                                    # Look for small or large upgrade project
                                    upgrade_project_id = f"rd_upgrade_{weakest_facility}_5pt"
                                    if upgrade_project_id not in RD_PROJECT_CATALOG:
                                        upgrade_project_id = f"rd_upgrade_{weakest_facility}_10pt"
                                    
                                    if upgrade_project_id in RD_PROJECT_CATALOG:
                                        project_template = RD_PROJECT_CATALOG[upgrade_project_id]
                                        if team.budget.cash >= project_template['cost']:
                                            action = Action('start_rd_project', cost=project_template['cost'], target=upgrade_project_id)
                                            action_events = FTBSimulation.apply_action(action, team, state)
                                            events.extend(action_events)
                
                # JOB BOARD: Apply for new roles (very rare - 2% chance)
                elif action_type == 'job_board':
                    # AI teams can apply for jobs, but very rarely and only if dissatisfied
                    team_satisfaction = team.standing_metrics.get('morale', 50.0)
                    
                    # Only apply if morale is low (below 40) or team is underperforming
                    if team_satisfaction < 40.0 and team.budget.cash >= 1000:
                        available_jobs = state.job_board.filter_visible_to_player(team.standing_metrics)
                        
                        if available_jobs:
                            # Prefer higher-tier opportunities
                            job_weights = []
                            for job in available_jobs:
                                job_tier = getattr(job, 'tier', 1)
                                if job_tier > team.tier:  # Only apply to better positions
                                    job_weights.append(job_tier * 2)  # Weight by tier improvement
                                else:
                                    job_weights.append(0)  # Don't apply to lateral/downward moves
                            
                            if any(w > 0 for w in job_weights):
                                # Select weighted random job
                                selected_job = rng.choices(available_jobs, weights=job_weights)[0]
                                action = Action('apply_for_job', cost=1000, target=selected_job)
                                action_events = FTBSimulation.apply_action(action, team, state)
                                events.extend(action_events)
                
                # SPONSOR MANAGEMENT: Handle sponsor offers and renewals
                elif action_type == 'sponsor_management':
                    # Handle pending sponsor offers (accept good ones, reject bad ones)
                    if team.name in state.pending_sponsor_offers and state.pending_sponsor_offers[team.name]:
                        for idx, sponsor_offer in enumerate(state.pending_sponsor_offers[team.name]):
                            # Simple AI decision: accept if payment is better than current average
                            current_sponsors = state.sponsorships.get(team.name, [])
                            avg_current_payment = sum(s.base_payment_per_season for s in current_sponsors) / len(current_sponsors) if current_sponsors else 0
                            
                            # Accept if offer is 20% better than current average, or if team has no sponsors
                            should_accept = (sponsor_offer.base_payment_per_season > avg_current_payment * 1.2) or not current_sponsors
                            
                            # Also consider team financial health
                            if team.budget.cash < 50000:  # Desperate for money
                                should_accept = True
                            
                            # Don't accept if it would cause exclusivity conflicts
                            if should_accept:
                                conflicts = []
                                for clause in sponsor_offer.exclusivity_clauses:
                                    for existing in current_sponsors:
                                        if clause in existing.exclusivity_clauses:
                                            conflicts.append(clause)
                                if conflicts:
                                    should_accept = False
                            
                            if should_accept:
                                action = Action('accept_sponsor', cost=0, target=idx)
                                action_events = FTBSimulation.apply_action(action, team, state)
                                events.extend(action_events)
                                break  # Only handle one offer per tick
                            else:
                                # Reject with some probability to clear offers
                                if rng.random() < 0.3:
                                    action = Action('reject_sponsor', cost=0, target=idx)
                                    action_events = FTBSimulation.apply_action(action, team, state)
                                    events.extend(action_events)
                    
                    # Handle sponsor renewals
                    elif team.name in state.sponsorships and state.sponsorships[team.name]:
                        for idx, sponsor in enumerate(state.sponsorships[team.name]):
                            # Negotiate renewal if near contract end and sponsor confidence is reasonable
                            if (sponsor.seasons_active >= sponsor.duration_seasons - 1 and 
                                sponsor.confidence > 40.0 and 
                                rng.random() < 0.7):  # 70% chance to attempt renewal
                                action = Action('negotiate_renewal', cost=0, target=idx)
                                action_events = FTBSimulation.apply_action(action, team, state)
                                events.extend(action_events)
                                break  # Only handle one renewal per tick
                
                # DEVELOP: Use existing action system
                else:
                    actions = FTBSimulation.get_available_actions(team, state)
                    if actions:
                        action = FTBSimulation.ai_team_decide(team, state)
                        if action and action in actions:
                            action_events = FTBSimulation.apply_action(action, team, state)
                            events.extend(action_events)
        
        return events
    
    @staticmethod
    def _execute_player_delegation(state: SimState) -> List[SimEvent]:
        """
        Execute AI decisions for delegated player team using principal-based simulation.
        
        This uses the SAME decision logic as AI teams (evaluate_action + apply_tendency_weights).
        The player's manager entity (principal) was created from their identity during world gen.
        If a delegation_focus is active, temporarily modifies principal stats for this decision.
        
        NO LLM involvement in decision-making - only simulation-based choices.
        """
        events = []
        
        # CRITICAL SAFETY CHECK: Only execute if explicitly in delegated mode
        # Check both control_mode AND time_mode to ensure delegation is truly active
        if state.control_mode != "delegated":
            return events  # Player has NOT enabled delegation - do nothing
            
        if state.time_mode != "auto":
            return events  # Not in auto mode - delegation should not act
        
        # Additional safety checks
        if not state.player_team or not state.player_team.principal:
            return events  # No delegation possible without player principal
            
        # Ensure this is actually the PLAYER team (verify by checking if it matches the tracked player team)
        # This prevents AI teams from accidentally acting through delegation logic
        if state.player_team is None:
            return events  # Safety check: no player team exists
        
        # Probabilistic decision (15% chance per tick to prevent spam)
        rng = state.get_rng("player_delegation", state.tick)
        if rng.random() > 0.15:
            return events
        
        # Get the player's manager principal
        base_principal = state.player_team.principal
        
        # Apply focus modifiers if delegation_focus is active
        active_principal = base_principal
        if state.delegation_focus:
            active_principal = apply_focus_modifiers(base_principal, state.delegation_focus.active_modifiers)
            # Log focus effect
            from your_runtime import log
            log(
                "ftb",
                f"[Delegate] Applying focus: '{state.delegation_focus.focus_text}' ({len(state.delegation_focus.active_modifiers)} stat modifiers)"
            )
        
        # Get available actions for player team
        actions = FTBSimulation.get_available_actions(state.player_team, state)
        if not actions:
            return events
        
        # Filter out job board actions for delegated player (make them extremely rare)
        # Player delegation should not frequently apply for new jobs
        filtered_actions = []
        for action in actions:
            if action.name == "apply_for_job":
                # Only include job applications if team morale is very low (below 30)
                team_morale = state.player_team.standing_metrics.get('morale', 50.0)
                if team_morale < 30.0 and rng.random() < 0.05:  # 5% chance even when desperate
                    filtered_actions.append(action)
            else:
                filtered_actions.append(action)
        
        actions = filtered_actions
        if not actions:
            return events
        
        # Use the SAME decision logic as AI teams
        # Evaluate all actions with principal's tendencies
        scored_actions = []
        for action in actions:
            # Base evaluation (context-aware scoring)
            score = FTBSimulation.evaluate_action(action, state.player_team, state)
            
            # Apply principal tendencies (personality weighting)
            # This is where the player's manager identity influences decisions
            score = FTBSimulation.apply_tendency_weights(score, active_principal, action, state.player_team, state)
            
            scored_actions.append((action, score))
        
        # Select best action (deterministic given the stats)
        if not scored_actions:
            return events
        
        scored_actions.sort(key=lambda x: x[1], reverse=True)
        chosen_action, chosen_score = scored_actions[0]
        
        # Minimum score threshold for taking action (don't do bad actions)
        if chosen_score < 30.0:
            return events  # All actions are bad, do nothing this tick
        
        # Apply the chosen action
        try:
            _dbg(f"[FTB DELEGATION] Player team '{state.player_team.name}' applying action: {chosen_action.name} (target: {chosen_action.target}, score: {chosen_score:.1f})")
            action_events = FTBSimulation.apply_action(chosen_action, state.player_team, state)
            events.extend(action_events)
            
            # Generate delegation decision event for UI log
            focus_text = state.delegation_focus.focus_text if state.delegation_focus else "general management"
            
            decision_event = SimEvent(
                event_type="meta",
                category="delegation_decision",
                ts=state.tick,
                priority=30.0,
                severity="info",
                event_id=FTBSimulation._generate_event_id(state),
                data={
                    'action_type': chosen_action.name,
                    'action_target': chosen_action.target,
                    'cost': chosen_action.cost,
                    'score': chosen_score,
                    'focus': focus_text,
                    'manager_name': base_principal.display_name,
                    'message': f"{base_principal.display_name} decided: {chosen_action.name}",
                    'tick': state.tick
                }
            )
            events.append(decision_event)
            
            # Log decision
            from your_runtime import log
            log(
                "ftb",
                f"[Delegate] Tick {state.tick}: {base_principal.display_name} chose '{chosen_action.name}' (score: {chosen_score:.1f}, cost: ${chosen_action.cost:,.0f})"
            )
            
            # Top 3 alternatives for debugging
            if len(scored_actions) > 1:
                alternatives = [f"{a.type}({s:.1f})" for a, s in scored_actions[1:4]]
                log("ftb", f"[Delegate]   Alternatives: {', '.join(alternatives)}")
        
        except Exception as e:
            from your_runtime import log
            log("ftb", f"[Delegate] Error applying action: {e}")
            import traceback
            traceback.print_exc()
        
        return events
    
    @staticmethod
    def _generate_regulation_change(state: SimState) -> List[SimEvent]:
        """Generate new regulation change that affects car performance"""
        events = []
        rng = state.get_rng("regulations", state.tick)
        
        # Generate regulation change
        affected_stats = rng.sample(
            ['aero_efficiency', 'mechanical_grip', 'power_delivery', 'reliability'],
            k=2  # Affect 2 stats
        )
        
        reduction_percent = rng.uniform(0.10, 0.25)  # 10-25% reduction
        
        effective_day = state.sim_day_of_year + 180  # 180 days notice
        
        regulation = RegulationChange(
            announced_day=state.sim_day_of_year,
            epoch_day=effective_day,
            changes={stat: f"reduced_by_{int(reduction_percent*100)}pct" for stat in affected_stats},
            stat_resets=affected_stats,
            adaptation_difficulty=reduction_percent
        )
        
        state.regulations.append(regulation)
        
        events.append(SimEvent(
            event_type="structural",
            category="regulation_announced",
            ts=state.tick,
            priority=90.0,
            severity="major",
            data={
                'affected_stats': affected_stats,
                'reduction_percent': round(reduction_percent * 100, 1),
                'effective_in_days': 180,
                'description': f"New regulations will reduce {', '.join(affected_stats)} by {reduction_percent*100:.0f}%"
            }
        ))
        
        return events
    
    @staticmethod
    def calculate_cash_runway(team: Team) -> float:
        """
        Calculate weeks of cash remaining at current burn rate.
        Returns number of weeks (not ticks) until cash runs out.
        Assumes 7 ticks per week (daily ticks).
        """
        team.ensure_staff_salaries()
        payroll_per_tick = team.budget.calculate_staff_payroll()
        
        # Calculate infrastructure upkeep (only unlocked facilities)
        upkeep_per_tick = 0.0
        for key, calc_func in INFRASTRUCTURE_UPKEEP_COST.items():
            unlock_key = f"{key}_unlocked"
            is_unlocked = team.infrastructure.get(unlock_key, False)
            if is_unlocked:
                quality = team.infrastructure.get(key, 0.0)
                upkeep_per_tick += calc_func(quality)
        
        total_burn = payroll_per_tick + upkeep_per_tick + team.budget.burn_rate
        
        if total_burn <= 0:
            return float('inf')  # No burn, infinite runway
        
        # Convert ticks to weeks (7 ticks = 1 week for daily tick rate)
        return (team.budget.cash / total_burn) / 7
    
    @staticmethod
    def calculate_reputation_trend(state: SimState, team: Team, lookback_ticks: int = 10) -> str:
        """
        Calculate reputation trend over last N ticks.
        Returns '↑' (increasing), '↓' (decreasing), or '→' (stable).
        """
        # Get reputation changes from recent event history
        recent_events = [e for e in state.event_history if e.ts > (state.tick - lookback_ticks)]
        reputation_changes = [
            e.data.get('change', 0.0) for e in recent_events 
            if e.category == 'reputation_change'
        ]
        
        # Also check current vs historical
        if not reputation_changes:
            # No explicit reputation events, check passive decay assumption
            # If no race results, should be declining slowly
            return '→'
        
        total_change = sum(reputation_changes)
        
        if total_change > 2.0:
            return '↑'
        elif total_change < -2.0:
            return '↓'
        else:
            return '→'
    
    @staticmethod
    def calculate_morale_state(team: Team) -> str:
        """
        Bin morale into Low/Stable/High categories.
        """
        morale = team.standing_metrics.get('morale', 50.0)
        
        if morale < 40.0:
            return "Low"
        elif morale > 60.0:
            return "High"
        else:
            return "Stable"


# ============================================================
# SECTION 6: UI Widget
# ============================================================

try:
    import tkinter as tk
    from tkinter import ttk, simpledialog, messagebox, filedialog
    import customtkinter as ctk
    from plugins.ftb_components import (
        FTBTheme, StatBar, EntityCard, StatsTable, MetricDisplay,
        DecisionModal, ConfirmDialog, DevelopmentWizard,
        FireEntityWizard, UpgradeWizard,
        format_currency, format_percentage, format_trend
    )
    
    # Configure CustomTkinter
    ctk.set_appearance_mode("dark")
    ctk.set_default_color_theme("blue")

    # Guard CTkEntry placeholder callbacks against destroyed widgets
    if hasattr(ctk, "CTkEntry") and not hasattr(ctk.CTkEntry, "_ftb_callback_wrapped"):
        original_callback = ctk.CTkEntry._textvariable_callback

        def _ftb_safe_textvariable_callback(self, *args, **kwargs):
            try:
                # Check if textvariable still exists before calling original callback
                if not hasattr(self, '_textvariable') or self._textvariable is None:
                    return None
                return original_callback(self, *args, **kwargs)
            except (tk.TclError, AttributeError):
                return None

        ctk.CTkEntry._textvariable_callback = _ftb_safe_textvariable_callback
        ctk.CTkEntry._ftb_callback_wrapped = True
    
    # ============================================================
    # SPRITE GENERATOR & TOOLTIP UTILITIES
    # ============================================================
    
    # Cache for generated sprites (entity_id -> PIL Image)
    _SPRITE_CACHE = {}
    
    def generate_entity_sprite(entity_id: int, size: int = 32) -> Image:
        """
        Generate a procedural 8-bit pixel art sprite for an entity.
        Uses entity_id as random seed for consistency.
        Returns PIL Image.
        """
        if entity_id in _SPRITE_CACHE:
            return _SPRITE_CACHE[entity_id]
        
        # Use entity_id as seed for deterministic generation
        rng = np.random.RandomState(entity_id)
        
        # Create pixel array
        pixels = np.zeros((size, size, 3), dtype=np.uint8)
        
        # Generate color palette based on entity_id
        skin_hue = rng.randint(0, 40)  # Skin tone range
        hair_hue = rng.randint(0, 360)  # Hair color
        suit_hue = rng.randint(180, 280)  # Suit/uniform color (blue range)
        
        # Helper to create colors from HSV
        def hsv_to_rgb(h, s, v):
            import colorsys
            r, g, b = colorsys.hsv_to_rgb(h/360, s/100, v/100)
            return int(r*255), int(g*255), int(b*255)
        
        skin_color = hsv_to_rgb(skin_hue, 20 + rng.randint(0, 30), 60 + rng.randint(0, 30))
        hair_color = hsv_to_rgb(hair_hue, 50 + rng.randint(0, 40), 40 + rng.randint(0, 40))
        suit_color = hsv_to_rgb(suit_hue, 60 + rng.randint(0, 30), 50 + rng.randint(0, 30))
        eye_color = (255, 255, 255)  # White eyes
        pupil_color = (40, 40, 40)  # Dark pupils
        
        # Draw helmet/head (upper third)
        head_start = size // 6
        head_end = size // 2
        for y in range(head_start, head_end):
            for x in range(size // 4, 3 * size // 4):
                pixels[y, x] = hair_color
        
        # Draw face/visor area (middle)
        face_start = size // 3
        face_end = 2 * size // 3
        for y in range(face_start, face_end):
            for x in range(size // 3, 2 * size // 3):
                pixels[y, x] = skin_color
        
        # Draw eyes
        eye_y = size // 2
        left_eye_x = size // 3 + 2
        right_eye_x = 2 * size // 3 - 3
        
        # White of eyes
        if size >= 16:
            pixels[eye_y:eye_y+2, left_eye_x:left_eye_x+3] = eye_color
            pixels[eye_y:eye_y+2, right_eye_x:right_eye_x+3] = eye_color
            # Pupils
            pixels[eye_y+1, left_eye_x+1] = pupil_color
            pixels[eye_y+1, right_eye_x+1] = pupil_color
        
        # Draw suit/uniform (lower half)
        suit_start = 2 * size // 3
        for y in range(suit_start, size):
            for x in range(size // 6, 5 * size // 6):
                pixels[y, x] = suit_color
        
        # Add some racing suit details (stripes)
        if size >= 24:
            stripe_y = 3 * size // 4
            for x in range(size // 4, 3 * size // 4):
                if x % 4 < 2:
                    pixels[stripe_y, x] = tuple(max(0, c - 40) for c in suit_color)
        
        # Convert to PIL Image
        pil_image = Image.fromarray(pixels, 'RGB')
        
        # Cache it
        _SPRITE_CACHE[entity_id] = pil_image
        
        return pil_image
    
    class ToolTip:
        """
        Custom tooltip that appears on hover.
        Shows additional information in a floating window.
        """
        def __init__(self, widget, text_func):
            """
            widget: The widget to attach tooltip to
            text_func: Callable that returns tooltip text when invoked
            """
            self.widget = widget
            self.text_func = text_func
            self.tooltip_window = None
            
            widget.bind("<Enter>", self.on_enter)
            widget.bind("<Leave>", self.on_leave)
        
        def on_enter(self, event=None):
            """Show tooltip after brief delay"""
            self.widget.after(500, self.show_tooltip)
        
        def on_leave(self, event=None):
            """Hide tooltip"""
            self.hide_tooltip()
        
        def show_tooltip(self):
            """Create and display tooltip window"""
            if self.tooltip_window or not self.widget.winfo_exists():
                return
            
            text = self.text_func()
            if not text:
                return
            
            # Get widget position
            x = self.widget.winfo_rootx() + 20
            y = self.widget.winfo_rooty() + self.widget.winfo_height() + 5
            
            # Create tooltip window
            self.tooltip_window = tk.Toplevel(self.widget)
            self.tooltip_window.wm_overrideredirect(True)
            self.tooltip_window.wm_geometry(f"+{x}+{y}")
            
            label = tk.Label(
                self.tooltip_window,
                text=text,
                background="#1a1f2e",
                foreground="#e0e0e0",
                relief="solid",
                borderwidth=1,
                font=("Arial", 9),
                justify=tk.LEFT,
                padx=8,
                pady=6
            )
            label.pack()
        
        def hide_tooltip(self):
            """Destroy tooltip window"""
            if self.tooltip_window:
                self.tooltip_window.destroy()
                self.tooltip_window = None
    
    class FTBWidget(ctk.CTkFrame):
        """Main game interface handling Setup Wizard and Game Loop"""
        
        def __init__(self, parent, runtime_stub):
            super().__init__(parent, fg_color=FTBTheme.BG)
            self.runtime = runtime_stub
            self.sim_state = None
            self.current_view = None  # "start_menu", "wizard", or "game"
            self.control_mode = "human"  # "human" or "delegated"
            self.time_mode = "manual"
            self.time_rate = 1.0
            self.decision_history = []  # Track AI decisions for UI display
            self._last_tick = None  # Track last update to prevent unnecessary refreshes
            self._last_tab = None  # Track last viewed tab to detect tab changes
            self._last_tick_click_time = 0  # For debouncing tick button
            self._stats_selected_league = None  # For racing stats filtering (will be set to player's league)
            self._stats_driver_search = ""  # For driver name search
            
            # Racing stats cache to improve performance
            self._stats_cache = {
                'last_tier': None,
                'last_league': None,
                'last_tick': None,
                'archive_results': None,
                'archive_timestamp': 0
            }
            self._stats_last_refreshed = False  # Track if stats have been refreshed
            
            # Unique widget ID for debugging
            self.widget_id = str(id(self))[-6:]
            _dbg(f"[FTB WIDGET {self.widget_id}] Creating new widget instance")
            
            # Unique widget ID for debugging
            self.widget_id = str(id(self))[-6:]
            _dbg(f"[FTB WIDGET {self.widget_id}] Creating new widget instance")
            
            # Queue is created in register_widgets - just log that we're using it
            cmd_q = self.runtime.get("ftb_cmd_q")
            controller = self.runtime.get("ftb_controller")
            _dbg(f"[FTB WIDGET INIT] queue exists={cmd_q is not None}, controller exists={controller is not None}")
            _dbg(f"[FTB WIDGET INIT] controller.state exists={controller.state is not None if controller else 'no controller'}")
            _dbg(f"[FTB WIDGET INIT] Using queue id={id(cmd_q)}, runtime dict id={id(self.runtime)}")
            
            # Wizard Variables
            self.wiz_seed = tk.StringVar(value=str(int(time.time())))
            self.wiz_save_mode = tk.StringVar(value="permanent")
            self.wiz_origin = tk.StringVar(value="grassroots_hustler")
            self.wiz_identity = tk.StringVar(value="The Stranger")
            self.wiz_tier = tk.StringVar(value="grassroots")
            self.wiz_manager_first_name = tk.StringVar(value="")
            self.wiz_manager_last_name = tk.StringVar(value="")
            
            # Build container
            self.container = ctk.CTkFrame(self, fg_color="transparent")
            self.container.pack(fill=tk.BOTH, expand=True)
            
            # Show start menu with Continue Save / Load Game / New Game options
            # Check for autosave and pass it to start menu
            autosave_path = self._get_autosave_path()
            self.show_start_menu(autosave_path)
            
            # Start polling for controller state updates
            self.after(500, self._poll)
        
        def clear_ui(self):
            self._detach_entry_traces(self.container)
            for widget in self.container.winfo_children():
                widget.destroy()

        def _detach_entry_traces(self, parent):
            """Detach entry textvariables before destroy to avoid stale callbacks."""
            try:
                children = parent.winfo_children()
            except Exception:
                return

            for child in children:
                try:
                    if isinstance(child, ctk.CTkEntry):
                        child.configure(textvariable=None)
                except Exception:
                    pass
                self._detach_entry_traces(child)
        
        def _get_autosave_path(self):
            """Get path to autosave file - MUST match controller's path"""
            # CRITICAL FIX: Use STATION_DIR to match controller, not RADIO_OS_ROOT
            station_dir = self.runtime.get("STATION_DIR", ".")
            return os.path.join(station_dir, "ftb_autosave.json")
        
        def _has_autosave(self):
            """Check if autosave file exists"""
            path = self._get_autosave_path()
            exists = os.path.exists(path)
            _dbg(f"[FTB WIDGET] _has_autosave: path={path}, exists={exists}")
            return exists
        
        def show_start_menu(self, save_path: str = None):
            """Show start menu with New Game / Load Save options"""
            # Allow redrawing the menu (removed early return check)
            _dbg(f"[FTB START MENU] ========================================")
            _dbg(f"[FTB START MENU] show_start_menu called with save_path={save_path}")
            _dbg(f"[FTB START MENU] ========================================")
            self.clear_ui()
            self.current_view = "start_menu"
            
            # Main container
            main = ctk.CTkFrame(self.container, fg_color="transparent")
            main.pack(expand=True)
            _dbg(f"[FTB START MENU] Main container created")
            
            # Title
            title = ctk.CTkLabel(
                main,
                text="FROM THE BACKMARKER",
                font=("Arial", 32, "bold"),
                text_color=FTBTheme.ACCENT
            )
            title.pack(pady=(40, 10))
            _dbg(f"[FTB START MENU] Title created")
            
            subtitle = ctk.CTkLabel(
                main,
                text="Racing Management Simulation",
                font=("Arial", 14),
                text_color=FTBTheme.TEXT_MUTED
            )
            subtitle.pack(pady=(0, 60))
            _dbg(f"[FTB START MENU] Subtitle created")
            
            # Button container
            btn_frame = ctk.CTkFrame(main, fg_color="transparent")
            btn_frame.pack()
            _dbg(f"[FTB START MENU] Button frame created")
            
            # Continue Save button (only if autosave exists)
            if save_path and os.path.exists(save_path):
                _dbg(f"[FTB START MENU] ✅ Autosave exists at: {save_path}")
                try:
                    load_btn = ctk.CTkButton(
                        btn_frame,
                        text="Continue Save",
                        command=lambda: self._load_and_start(save_path),
                        fg_color=FTBTheme.SUCCESS,
                        hover_color=FTBTheme.SUCCESS_HOVER,
                        width=300,
                        height=60,
                        font=("Arial", 16, "bold"),
                        corner_radius=12
                    )
                    load_btn.pack(pady=10)
                    _dbg(f"[FTB START MENU] ✅ 'Continue Save' button created and packed")
                except Exception as e:
                    _dbg(f"[FTB START MENU] ❌ Error creating 'Continue Save' button: {e}")
                    import traceback
                    traceback.print_exc()
            else:
                _dbg(f"[FTB START MENU] ⏭️  No autosave (save_path={save_path}, exists={os.path.exists(save_path) if save_path else False})")
            
            # Load Game button (opens file picker) - ALWAYS SHOW THIS
            try:
                _dbg(f"[FTB START MENU] Creating 'Load Game' button...")
                load_any_btn = ctk.CTkButton(
                    btn_frame,
                    text="Load Game",
                    command=self._browse_and_load,
                    fg_color=FTBTheme.ACCENT,
                    hover_color=FTBTheme.ACCENT_HOVER,
                    width=300,
                    height=60,
                    font=("Arial", 16, "bold"),
                    corner_radius=12
                )
                _dbg(f"[FTB START MENU] 'Load Game' button object created, now packing...")
                load_any_btn.pack(pady=10)
                _dbg(f"[FTB START MENU] ✅ 'Load Game' button packed successfully!")
            except Exception as e:
                _dbg(f"[FTB START MENU] ❌ ERROR creating 'Load Game' button: {e}")
                import traceback
                traceback.print_exc()
            
            # New Game button
            try:
                _dbg(f"[FTB START MENU] Creating 'New Game' button...")
                new_btn = ctk.CTkButton(
                    btn_frame,
                    text="New Game",
                    command=self.show_wizard,
                    fg_color=FTBTheme.CARD,
                    hover_color=FTBTheme.CARD_HOVER,
                    width=300,
                    height=60,
                    font=("Arial", 16, "bold"),
                    corner_radius=12
                )
                new_btn.pack(pady=10)
                _dbg(f"[FTB START MENU] ✅ 'New Game' button created and packed")
            except Exception as e:
                _dbg(f"[FTB START MENU] ❌ ERROR creating 'New Game' button: {e}")
                import traceback
                traceback.print_exc()
            
            # Save info (only if autosave exists)
            if save_path and os.path.exists(save_path):
                try:
                    import time
                    mod_time = os.path.getmtime(save_path)
                    time_str = time.strftime("%Y-%m-%d %H:%M", time.localtime(mod_time))
                    info = ctk.CTkLabel(
                        main,
                        text=f"Autosave: {time_str}",
                        font=("Arial", 11),
                        text_color=FTBTheme.TEXT_DIM
                    )
                    info.pack(pady=(40, 0))
                    _dbg(f"[FTB START MENU] ✅ Autosave info displayed: {time_str}")
                except Exception as e:
                    _dbg(f"[FTB START MENU] ⚠️  Error displaying autosave info: {e}")
            
            _dbg(f"[FTB START MENU] ========================================"
)
            _dbg(f"[FTB START MENU] Start menu setup complete!")
            _dbg(f"[FTB START MENU] ========================================")
        
        def _load_and_start(self, save_path: str):
            """Load save file and show game UI"""
            cmd_q = self.runtime.get("ftb_cmd_q")
            if cmd_q:
                cmd_q.put({"cmd": "ftb_load_save", "path": save_path})
                # The controller will load the state and trigger a refresh
                # which will call show_game_ui() when state exists
        
        def _browse_and_load(self):
            """Open file browser to select a save file"""
            _dbg("[FTB] _browse_and_load called")
            workspace_root = self.runtime.get("RADIO_OS_ROOT", ".")
            saves_dir = os.path.join(workspace_root, "saves")
            _dbg(f"[FTB] Looking for saves in: {saves_dir}")
            
            # Ensure saves directory exists
            if not os.path.exists(saves_dir):
                _dbg(f"[FTB] Creating saves directory: {saves_dir}")
                os.makedirs(saves_dir)
            
            _dbg("[FTB] Opening file dialog...")
            filename = filedialog.askopenfilename(
                initialdir=saves_dir,
                title="Select save file",
                filetypes=(("JSON files", "*.json"), ("All files", "*.*")),
                parent=self
            )
            
            _dbg(f"[FTB] User selected: {filename}")
            if filename and os.path.exists(filename):
                _dbg(f"[FTB] Loading save from: {filename}")
                self._load_and_start(filename)
            else:
                _dbg(f"[FTB] No file selected or file doesn't exist")
        
        def _show_welcome_choice(self):
            """Show Continue/New Game choice screen when autosave exists"""
            self.clear_ui()
            self.current_view = "welcome"
            
            # Center container
            center_frame = ctk.CTkFrame(self.container, fg_color="transparent")
            center_frame.place(relx=0.5, rely=0.5, anchor=tk.CENTER)
            
            # Title
            ctk.CTkLabel(
                center_frame,
                text="From The Backmarker",
                font=("Arial", 24, "bold"),
                text_color=FTBTheme.TEXT
            ).pack(pady=(0, 20))
            
            # Subtitle
            ctk.CTkLabel(
                center_frame,
                text="An autosave was found",
                font=("Arial", 14),
                text_color=FTBTheme.TEXT_MUTED
            ).pack(pady=(0, 40))
            
            # Button container
            button_frame = ctk.CTkFrame(center_frame, fg_color="transparent")
            button_frame.pack(pady=10)
            
            # Continue button
            ctk.CTkButton(
                button_frame,
                text="Continue Game",
                command=lambda: self._load_and_start(self._get_autosave_path()),
                fg_color=FTBTheme.ACCENT,
                hover_color=FTBTheme.ACCENT_HOVER,
                width=200,
                height=50,
                font=("Arial", 14, "bold"),
                corner_radius=8
            ).pack(pady=10)
            
            # Load Game button (browse for different save)
            ctk.CTkButton(
                button_frame,
                text="Load Game",
                command=self._browse_and_load,
                fg_color=FTBTheme.SUCCESS,
                hover_color=FTBTheme.SUCCESS_HOVER,
                width=200,
                height=50,
                font=("Arial", 14),
                corner_radius=8
            ).pack(pady=10)
            
            # New Game button
            ctk.CTkButton(
                button_frame,
                text="New Game",
                command=lambda: self.show_wizard(skip_welcome=True),
                fg_color=FTBTheme.SURFACE,
                hover_color=FTBTheme.CARD,
                text_color=FTBTheme.TEXT,
                width=200,
                height=50,
                font=("Arial", 14),
                corner_radius=8
            ).pack(pady=10)
        
        def show_wizard(self, skip_welcome=False):
            """Show wizard, optionally showing welcome screen first if autosave exists"""
            if self.current_view == "wizard": return
            self.clear_ui()
            self.current_view = "wizard"
            
            # If autosave exists and we haven't skipped welcome, show Continue/New Game choice
            if not skip_welcome and self._has_autosave():
                self._show_welcome_choice()
                return
            
            # Header
            header = ctk.CTkLabel(
                self.container, 
                text="New Game Setup", 
                font=("Arial", 18, "bold"),
                text_color=FTBTheme.TEXT
            )
            header.pack(pady=20)
            
            # Form Frame
            form = ctk.CTkScrollableFrame(
                self.container, 
                fg_color=FTBTheme.PANEL,
                corner_radius=12
            )
            form.pack(fill=tk.BOTH, expand=True, padx=20, pady=(0, 20))
            
            # 1. Save Mode
            mode_card = ctk.CTkFrame(form, fg_color=FTBTheme.CARD, corner_radius=8)
            mode_card.pack(fill=tk.X, pady=10, padx=15)
            
            ctk.CTkLabel(
                mode_card, 
                text="1. Save Mode",
                font=("Arial", 14, "bold"),
                text_color=FTBTheme.TEXT
            ).pack(anchor=tk.W, padx=15, pady=(15, 5))
            
            ctk.CTkLabel(
                mode_card, 
                text="Deterministic: Same seed = same outcomes (replayable)",
                text_color=FTBTheme.TEXT_MUTED,
                font=("Arial", 11)
            ).pack(anchor=tk.W, padx=15, pady=2)
            
            ctk.CTkLabel(
                mode_card, 
                text="Permanent: Entropy injected (unique playthrough)",
                text_color=FTBTheme.TEXT_MUTED,
                font=("Arial", 11)
            ).pack(anchor=tk.W, padx=15, pady=(0, 10))
            
            ctk.CTkRadioButton(
                mode_card, 
                text="Replayable (Deterministic)", 
                variable=self.wiz_save_mode, 
                value="replayable",
                fg_color=FTBTheme.ACCENT,
                hover_color=FTBTheme.ACCENT_HOVER,
                text_color=FTBTheme.TEXT
            ).pack(anchor=tk.W, padx=15, pady=2)
            
            ctk.CTkRadioButton(
                mode_card, 
                text="Permanent (Entropy)", 
                variable=self.wiz_save_mode, 
                value="permanent",
                fg_color=FTBTheme.ACCENT,
                hover_color=FTBTheme.ACCENT_HOVER,
                text_color=FTBTheme.TEXT
            ).pack(anchor=tk.W, padx=15, pady=(2, 15))
            
            # 2. Seed
            seed_card = ctk.CTkFrame(form, fg_color=FTBTheme.CARD, corner_radius=8)
            seed_card.pack(fill=tk.X, pady=10, padx=15)
            
            ctk.CTkLabel(
                seed_card, 
                text="2. World Seed",
                font=("Arial", 14, "bold"),
                text_color=FTBTheme.TEXT
            ).pack(anchor=tk.W, padx=15, pady=(15, 5))
            
            ctk.CTkLabel(
                seed_card, 
                text="Locks world generation & RNG (editable only here)",
                text_color=FTBTheme.TEXT_MUTED,
                font=("Arial", 11)
            ).pack(anchor=tk.W, padx=15, pady=(0, 10))
            
            seed_row = ctk.CTkFrame(seed_card, fg_color="transparent")
            seed_row.pack(fill=tk.X, padx=15, pady=(0, 15))
            
            ctk.CTkEntry(
                seed_row, 
                textvariable=self.wiz_seed,
                fg_color=FTBTheme.SURFACE,
                border_color=FTBTheme.ACCENT,
                text_color=FTBTheme.TEXT,
                height=40,
                font=("Arial", 12)
            ).pack(side=tk.LEFT, fill=tk.X, expand=True)
            
            ctk.CTkButton(
                seed_row, 
                text="Randomize", 
                command=lambda: self.wiz_seed.set(str(int(time.time()))),
                fg_color=FTBTheme.ACCENT,
                hover_color=FTBTheme.ACCENT_HOVER,
                width=120,
                height=40,
                font=("Arial", 12)
            ).pack(side=tk.LEFT, padx=(10, 0))
            
            # 3. Starting Tier
            tier_card = ctk.CTkFrame(form, fg_color=FTBTheme.CARD, corner_radius=8)
            tier_card.pack(fill=tk.X, pady=10, padx=15)
            
            ctk.CTkLabel(
                tier_card,
                text="3. Starting Tier",
                font=("Arial", 14, "bold"),
                text_color=FTBTheme.TEXT
            ).pack(anchor=tk.W, padx=15, pady=(15, 5))
            
            ctk.CTkLabel(
                tier_card,
                text="Choose where you begin your journey up the motorsport ladder.",
                text_color=FTBTheme.TEXT_MUTED,
                font=("Arial", 11)
            ).pack(anchor=tk.W, padx=15, pady=(0, 10))
            
            tier_options = [
                "Grassroots ($200K-$500K budget, 16 teams, local competition)",
                "Formula V ($800K-$1.5M budget, 16 teams, regional series)",
                "Formula X ($3M-$8M budget, 10 teams, national championship)",
                "Formula Y ($15M-$40M budget, 11 teams, international racing)",
                "Formula Z ($140M-$400M budget, 10 teams, elite world championship)"
            ]
            
            tier_values = ['grassroots', 'formula_v', 'formula_x', 'formula_y', 'formula_z']
            
            self.wiz_tier_dropdown = ctk.CTkOptionMenu(
                tier_card,
                variable=self.wiz_tier,
                values=tier_values,
                command=self._update_tier_display,
                fg_color=FTBTheme.SURFACE,
                button_color=FTBTheme.ACCENT,
                button_hover_color=FTBTheme.ACCENT_HOVER,
                text_color=FTBTheme.TEXT,
                height=40,
                font=("Arial", 12)
            )
            self.wiz_tier_dropdown.pack(fill=tk.X, padx=15, pady=(0, 10))
            
            # Tier implications panel
            self.tier_implications = ctk.CTkFrame(tier_card, fg_color=FTBTheme.SURFACE, corner_radius=6)
            self.tier_implications.pack(fill=tk.X, padx=15, pady=(0, 15))
            
            self.tier_implications_label = ctk.CTkLabel(
                self.tier_implications,
                text="Starting at Grassroots:\n• Low budgets, minimal staff\n• 10 race season\n• Perfect for learning the ropes",
                font=("Arial", 10),
                text_color=FTBTheme.TEXT,
                justify="left",
                anchor="w"
            )
            self.tier_implications_label.pack(padx=10, pady=10, anchor="w")
            
            # 4. Identity
            identity_card = ctk.CTkFrame(form, fg_color=FTBTheme.CARD, corner_radius=8)
            identity_card.pack(fill=tk.X, pady=10, padx=15)
            
            ctk.CTkLabel(
                identity_card,
                text="4. Who are you?",
                font=("Arial", 14, "bold"),
                text_color=FTBTheme.TEXT
            ).pack(anchor=tk.W, padx=15, pady=(15, 5))
            
            ctk.CTkLabel(
                identity_card,
                text="Your identity and origin shape how the world sees you and how you begin.",
                text_color=FTBTheme.TEXT_MUTED,
                font=("Arial", 11)
            ).pack(anchor=tk.W, padx=15, pady=(0, 10))
            
            ctk.CTkLabel(
                identity_card,
                text="Origin Story (affects starting cash & reputation):",
                text_color=FTBTheme.TEXT_MUTED,
                font=("Arial", 11)
            ).pack(anchor=tk.W, padx=15, pady=(5, 5))
            
            origins = ['game_show_winner', 'grassroots_hustler', 'former_driver', 'corporate_spinout', 'engineering_savant']
            self.wiz_origin_dropdown = ctk.CTkOptionMenu(
                identity_card,
                variable=self.wiz_origin,
                values=origins,
                command=self._update_origin_display,
                fg_color=FTBTheme.SURFACE,
                button_color=FTBTheme.ACCENT,
                button_hover_color=FTBTheme.ACCENT_HOVER,
                text_color=FTBTheme.TEXT,
                height=40,
                font=("Arial", 12)
            )
            self.wiz_origin_dropdown.pack(fill=tk.X, padx=15, pady=(0, 10))
            
            # Origin implications panel
            self.origin_implications = ctk.CTkFrame(identity_card, fg_color=FTBTheme.SURFACE, corner_radius=6)
            self.origin_implications.pack(fill=tk.X, padx=15, pady=(0, 15))
            
            self.origin_implications_label = ctk.CTkLabel(
                self.origin_implications,
                text="Grassroots Hustler:\n• No cash bonus (pure struggle)\n• Low media standing (40)\n• High legitimacy (60) - you've earned your place",
                font=("Arial", 10),
                text_color=FTBTheme.TEXT,
                justify="left",
                anchor="w"
            )
            self.origin_implications_label.pack(padx=10, pady=10, anchor="w")
            
            ctk.CTkLabel(
                identity_card,
                text="Player Identity (descriptive tags, comma-separated):",
                text_color=FTBTheme.TEXT_MUTED,
                font=("Arial", 11)
            ).pack(anchor=tk.W, padx=15, pady=(10, 5))
            
            self.wiz_identity_text = ctk.CTkTextbox(
                identity_card,
                height=80,
                fg_color=FTBTheme.SURFACE,
                border_color=FTBTheme.ACCENT,
                text_color=FTBTheme.TEXT,
                font=("Arial", 11),
                wrap="word"
            )
            self.wiz_identity_text.pack(fill=tk.X, padx=15, pady=(0, 15))
            
            ctk.CTkLabel(
                identity_card,
                text="Manager Name:",
                text_color=FTBTheme.TEXT_MUTED,
                font=("Arial", 11)
            ).pack(anchor=tk.W, padx=15, pady=(10, 5))
            
            name_row = ctk.CTkFrame(identity_card, fg_color="transparent")
            name_row.pack(fill=tk.X, padx=15, pady=(0, 15))
            
            ctk.CTkEntry(
                name_row,
                textvariable=self.wiz_manager_first_name,
                placeholder_text="First Name",
                fg_color=FTBTheme.SURFACE,
                border_color=FTBTheme.ACCENT,
                text_color=FTBTheme.TEXT,
                height=40,
                font=("Arial", 12)
            ).pack(side=tk.LEFT, fill=tk.X, expand=True, padx=(0, 5))
            
            ctk.CTkEntry(
                name_row,
                textvariable=self.wiz_manager_last_name,
                placeholder_text="Last Name",
                fg_color=FTBTheme.SURFACE,
                border_color=FTBTheme.ACCENT,
                text_color=FTBTheme.TEXT,
                height=40,
                font=("Arial", 12)
            ).pack(side=tk.LEFT, fill=tk.X, expand=True, padx=(5, 0))
            
            # Manager dentity_text.insert('1.0', "The Stranger")
            
            # Manager Age
            ctk.CTkLabel(
                identity_card, 
                text="Manager Age:",
                text_color=FTBTheme.TEXT_MUTED,
                font=("Arial", 11)
            ).pack(anchor=tk.W, padx=15, pady=(10, 5))
            
            age_frame = ctk.CTkFrame(identity_card, fg_color="transparent")
            age_frame.pack(fill=tk.X, padx=15, pady=(0, 15))
            
            self.wiz_manager_age = tk.IntVar(value=32)
            self.wiz_manager_age_label = ctk.CTkLabel(
                age_frame,
                text="32 years old",
                font=("Arial", 12, "bold"),
                text_color=FTBTheme.ACCENT
            )
            self.wiz_manager_age_label.pack(side=tk.RIGHT, padx=(10, 0))
            
            def update_age_label(val):
                age = int(float(val))
                self.wiz_manager_age.set(age)
                self.wiz_manager_age_label.configure(text=f"{age} years old")
            
            age_slider = ctk.CTkSlider(
                age_frame,
                from_=22,
                to=70,
                number_of_steps=48,
                command=update_age_label,
                fg_color=FTBTheme.SURFACE,
                progress_color=FTBTheme.ACCENT,
                button_color=FTBTheme.ACCENT,
                button_hover_color=FTBTheme.ACCENT_HOVER
            )
            age_slider.set(32)
            age_slider.pack(side=tk.LEFT, fill=tk.X, expand=True)
            
            # 5. Team & Ownership
            team_card = ctk.CTkFrame(form, fg_color=FTBTheme.CARD, corner_radius=8)
            team_card.pack(fill=tk.X, pady=10, padx=15)
            
            ctk.CTkLabel(
                team_card,
                text="5. Team & Ownership",
                font=("Arial", 14, "bold"),
                text_color=FTBTheme.TEXT
            ).pack(anchor=tk.W, padx=15, pady=(15, 5))
            
            ctk.CTkLabel(
                team_card, 
                text="Team Name:",
                text_color=FTBTheme.TEXT_MUTED,
                font=("Arial", 11)
            ).pack(anchor=tk.W, padx=15, pady=(5, 5))
            
            self.wiz_team_name = tk.StringVar(value="")
            team_name_entry = ctk.CTkEntry(
                team_card,
                textvariable=self.wiz_team_name,
                placeholder_text="Enter your team name (leave empty for random)",
                fg_color=FTBTheme.SURFACE,
                border_color=FTBTheme.ACCENT,
                text_color=FTBTheme.TEXT,
                height=40,
                font=("Arial", 12)
            )
            team_name_entry.pack(fill=tk.X, padx=15, pady=(0, 15))
            
            ctk.CTkLabel(
                team_card, 
                text="Ownership Model:",
                text_color=FTBTheme.TEXT_MUTED,
                font=("Arial", 11)
            ).pack(anchor=tk.W, padx=15, pady=(10, 5))
            
            self.wiz_ownership = tk.StringVar(value="hired_manager")
            ownership_frame = ctk.CTkFrame(team_card, fg_color="transparent")
            ownership_frame.pack(fill=tk.X, padx=15, pady=(0, 15))
            
            ctk.CTkRadioButton(
                ownership_frame,
                text="Self-Owned Team  (like Frank Williams - no owner pressure)",
                variable=self.wiz_ownership,
                value="self_owned",
                fg_color=FTBTheme.ACCENT,
                hover_color=FTBTheme.ACCENT_HOVER,
                text_color=FTBTheme.TEXT,
                font=("Arial", 11)
            ).pack(anchor=tk.W, pady=5)
            
            ctk.CTkRadioButton(
                ownership_frame,
                text="Hired Manager  (report to team owner, job security matters)",
                variable=self.wiz_ownership,
                value="hired_manager",
                fg_color=FTBTheme.ACCENT,
                hover_color=FTBTheme.ACCENT_HOVER,
                text_color=FTBTheme.TEXT,
                font=("Arial", 11)
            ).pack(anchor=tk.W, pady=5)
            
            # 6. Confirmation & Start
            confirm_frame = ctk.CTkFrame(self.container, fg_color="transparent")
            confirm_frame.pack(pady=20, padx=20, fill=tk.X)
            
            ctk.CTkLabel(
                confirm_frame, 
                text="These settings are locked once game starts", 
                font=("Arial", 10, "italic"),
                text_color=FTBTheme.TEXT_DIM
            ).pack(pady=(0, 10))
            
            ctk.CTkButton(
                confirm_frame, 
                text="START NEW GAME", 
                command=self.confirm_and_submit_wizard,
                fg_color=FTBTheme.ACCENT,
                hover_color=FTBTheme.ACCENT_HOVER,
                height=50,
                font=("Arial", 14, "bold"),
                corner_radius=8
            ).pack(fill=tk.X)
        
        def confirm_and_submit_wizard(self):
            """Show confirmation dialog before starting game"""
            _dbg("[FTB] confirm_and_submit_wizard called")  # Debug log
            
            # Check if autosave exists and warn about overwrite
            if self._has_autosave():
                overwrite_msg = """An autosave already exists.

Starting a new game will OVERWRITE the existing autosave.

Do you want to overwrite it and start a new game?"""
                overwrite_confirmed = messagebox.askyesno("Overwrite Autosave?", overwrite_msg, parent=self, icon='warning')
                _dbg(f"[FTB] Overwrite confirmed: {overwrite_confirmed}")
                
                if not overwrite_confirmed:
                    _dbg("[FTB] User cancelled new game to preserve autosave")
                    return  # User cancelled, keep autosave
            
            try:
                seed = int(self.wiz_seed.get())
            except:
                seed = int(time.time())
            
            save_mode = self.wiz_save_mode.get()
            origin = self.wiz_origin.get()
            identity_text = self.wiz_identity_text.get('1.0', tk.END).strip()
            identity_list = [s.strip() for s in identity_text.split(',') if s.strip()]
            team_name = self.wiz_team_name.get().strip()
            ownership = self.wiz_ownership.get()
            manager_age = self.wiz_manager_age.get()
            manager_first_name = self.wiz_manager_first_name.get().strip()
            manager_last_name = self.wiz_manager_last_name.get().strip()
            
            _dbg(f"[FTB] Showing confirmation: seed={seed}, mode={save_mode}, origin={origin}, manager_age={manager_age}, manager_name={manager_first_name} {manager_last_name}")  # Debug log
            
            # Build confirmation message
            ownership_display = "Self-Owned Team" if ownership == "self_owned" else "Hired Manager"
            manager_name_display = f"{manager_first_name} {manager_last_name}".strip() if manager_first_name or manager_last_name else "(Not Set)"
            msg = f"""Game Setup Confirmation:

Seed: {seed}
Save Mode: {save_mode.title()}
Origin: {origin.replace('_', ' ').title()}
Identity: {', '.join(identity_list)}
Manager Name: {manager_name_display}
Manager Age: {manager_age} years old
Team Name: {team_name if team_name else "(Random)"}
Ownership: {ownership_display}

These settings cannot be changed after starting.
Only way to modify is by editing the save file directly.

Start game with these settings?"""
            
            confirmed = messagebox.askyesno("Confirm New Game", msg, parent=self)
            _dbg(f"[FTB] User confirmed: {confirmed}")  # Debug log
            
            if confirmed:
                # Clear wizard UI and show loading state to prevent double-clicks
                self.clear_ui()
                self.current_view = "loading"
                
                # Show loading message
                loading_frame = ctk.CTkFrame(self.container, fg_color="transparent")
                loading_frame.pack(expand=True)
                
                ctk.CTkLabel(
                    loading_frame,
                    text="Creating New Game...",
                    font=("Arial", 18, "bold"),
                    text_color=FTBTheme.TEXT
                ).pack(pady=50)
                
                ctk.CTkLabel(
                    loading_frame,
                    text="Generating teams, drivers, and season schedule...",
                    font=("Arial", 12),
                    text_color=FTBTheme.TEXT_MUTED
                ).pack(pady=10)
                
                # Force UI update before queueing command
                self.update_idletasks()
                
                q = self.runtime["ftb_cmd_q"]
                _dbg(f"[FTB BUTTON] Putting command in queue id={id(q)}, runtime dict id={id(self.runtime)}")
                q.put({
                    "cmd": "ftb_new_save",
                    "origin": origin,
                    "identity": identity_list,
                    "save_mode": save_mode,
                    "tier": self.wiz_tier.get(),
                    "seed": seed,
                    "team_name": team_name,
                    "ownership": ownership,
                    "manager_age": manager_age,
                    "manager_first_name": manager_first_name,
                    "manager_last_name": manager_last_name
                })
                _dbg(f"[FTB BUTTON] Command queued successfully! Queue size now: {q.qsize()}")
        
        def submit_wizard(self):
            """Send setup command to controller"""
            try:
                seed = int(self.wiz_seed.get())
            except:
                seed = int(time.time())
                
            self.runtime["ftb_cmd_q"].put({
                "cmd": "ftb_new_save",
                "origin": self.wiz_origin.get(),
                "identity": [self.wiz_identity.get()], # List format
                "save_mode": self.wiz_save_mode.get(),
                "tier": self.wiz_tier.get(),
                "seed": seed
            })
        
        def _update_tier_display(self, tier_value):
            """Update tier implications panel when tier selection changes"""
            tier_info = {
                'grassroots': {
                    'text': "Starting at Grassroots:\n• Budget: $200K-$500K\n• 10 race season, 16 teams\n• Low staff count (1 mechanic, 0 engineers)\n• Perfect for learning the ropes"
                },
                'formula_v': {
                    'text': "Starting at Formula V:\n• Budget: $800K-$1.5M\n• 10 race season, 16 teams\n• Small professional operation\n• Regional competition"
                },
                'formula_x': {
                    'text': "Starting at Formula X:\n• Budget: $3M-$8M\n• 10 race season, 10 teams\n• National championship level\n• Significant staff and resources"
                },
                'formula_y': {
                    'text': "Starting at Formula Y:\n• Budget: $15M-$40M\n• 14 race season, 11 teams\n• International racing series\n• Advanced cars and technology"
                },
                'formula_z': {
                    'text': "Starting at Formula Z:\n• Budget: $140M-$400M\n• 24 race season, 10 teams\n• Elite world championship\n• Maximum complexity and competition"
                }
            }
            
            info = tier_info.get(tier_value, tier_info['grassroots'])
            self.tier_implications_label.configure(text=info['text'])
        
        def _update_origin_display(self, origin_value):
            """Update origin implications panel when origin selection changes"""
            origin_info = {
                'game_show_winner': {
                    'cash': '+$50K',
                    'text': "Game Show Winner:\n• Cash bonus: +$50,000\n• Media standing: 60 (high visibility)\n• Legitimacy: 40 (questionable credibility)\n• You won big on TV - now prove you belong"
                },
                'grassroots_hustler': {
                    'cash': '+$0',
                    'text': "Grassroots Hustler:\n• No cash bonus (pure struggle)\n• Media standing: 40 (unknown)\n• Legitimacy: 60 (earned respect)\n• You've worked your way up from nothing"
                },
                'former_driver': {
                    'cash': '+$30K',
                    'text': "Former Driver:\n• Cash bonus: +$30,000 (savings)\n• Media standing: 55 (some fame)\n• Legitimacy: 55 (proven experience)\n• Your racing career is over - management begins"
                },
                'corporate_spinout': {
                    'cash': '+$300K',
                    'text': "Corporate Spinout:\n• Cash bonus: +$300,000 (investor backing)\n• Media standing: 50 (corporate presence)\n• Legitimacy: 45 (money talks, but...)\n• Corporate money, corporate expectations"
                },
                'engineering_savant': {
                    'cash': '+$70K',
                    'text': "Engineering Savant:\n• Cash bonus: +$70,000 (patents/consulting)\n• Media standing: 45 (technical reputation)\n• Legitimacy: 50 (respected expertise)\n• Your innovations speak louder than words"
                }
            }
            
            info = origin_info.get(origin_value, origin_info['grassroots_hustler'])
            self.origin_implications_label.configure(text=info['text'])
            
        def show_game_interface(self):
            if self.current_view == "game": return
            self.clear_ui()
            self.current_view = "game"
            
            # --- Top Toolbar (Calendar + Quick Actions) ---
            toolbar = ctk.CTkFrame(self.container, fg_color=FTBTheme.PANEL, corner_radius=0, height=60)
            toolbar.pack(fill=tk.BOTH, padx=0, pady=0)
            toolbar.pack_propagate(False)
            
            # Calendar display
            self.cal_label = ctk.CTkLabel(
                toolbar, 
                text="--/--",
                font=("Arial", 13, "bold"),
                text_color=FTBTheme.TEXT,
                width=150
            )
            self.cal_label.pack(side=tk.LEFT, padx=15, pady=10)
            
            # Time control buttons
            time_controls = ctk.CTkFrame(toolbar, fg_color="transparent")
            time_controls.pack(side=tk.LEFT, padx=5, pady=10)
            
            ctk.CTkButton(
                time_controls,
                text="+1 Day",
                command=lambda: self.send_tick(1),
                fg_color=FTBTheme.ACCENT,
                hover_color=FTBTheme.ACCENT_HOVER,
                width=90,
                height=35,
                font=("Arial", 11)
            ).pack(side=tk.LEFT, padx=3)
            
            ctk.CTkButton(
                time_controls,
                text="+1 Week",
                command=lambda: self.send_tick_batch(7),
                fg_color=FTBTheme.ACCENT,
                hover_color=FTBTheme.ACCENT_HOVER,
                width=90,
                height=35,
                font=("Arial", 11)
            ).pack(side=tk.LEFT, padx=3)
            
            ctk.CTkButton(
                time_controls,
                text="+1 Month",
                command=lambda: self.send_tick_batch(30),
                fg_color=FTBTheme.ACCENT,
                hover_color=FTBTheme.ACCENT_HOVER,
                width=90,
                height=35,
                font=("Arial", 11)
            ).pack(side=tk.LEFT, padx=3)
            
            # Next Event Indicator
            next_event_frame = ctk.CTkFrame(toolbar, fg_color=FTBTheme.CARD, corner_radius=6)
            next_event_frame.pack(side=tk.LEFT, padx=15, pady=10, fill=tk.Y)
            
            self.next_event_label = ctk.CTkLabel(
                next_event_frame,
                text="⏰ Next: Loading...",
                font=("Arial", 11),
                text_color=FTBTheme.TEXT,
                anchor="w"
            )
            self.next_event_label.pack(padx=10, pady=8)
            
            # Add tooltip that shows next 3 events
            def get_next_events_tooltip():
                if not self.sim_state:
                    return ""
                try:
                    calendar = self.sim_state.get_calendar_projection(days_ahead=60)
                    if not calendar:
                        return "No upcoming events"
                    
                    # Get next 3 major events
                    tooltip_lines = ["Upcoming Events:\n"]
                    for i, entry in enumerate(calendar[:3]):
                        days_until = entry['entry_day'] - self.sim_state.sim_day_of_year
                        tooltip_lines.append(f"{entry['title']} in {days_until} days")
                        if i < 2 and i < len(calendar) - 1:
                            tooltip_lines.append("")
                    
                    return "\n".join(tooltip_lines)
                except:
                    return ""
            
            # Tooltip disabled for cleaner UI
            # ToolTip(next_event_frame, get_next_events_tooltip)
            
            # File menu buttons on right
            file_controls = ctk.CTkFrame(toolbar, fg_color="transparent")
            file_controls.pack(side=tk.RIGHT, padx=10, pady=10)
            
            ctk.CTkButton(
                file_controls,
                text="💾 Save",
                command=self.save_game,
                fg_color=FTBTheme.SURFACE,
                hover_color=FTBTheme.BUTTON_SECONDARY_HOVER,
                width=80,
                height=35,
                font=("Arial", 11)
            ).pack(side=tk.LEFT, padx=3)
            
            ctk.CTkButton(
                file_controls,
                text="📁 Load",
                command=self.load_game,
                fg_color=FTBTheme.SURFACE,
                hover_color=FTBTheme.BUTTON_SECONDARY_HOVER,
                width=80,
                height=35,
                font=("Arial", 11)
            ).pack(side=tk.LEFT, padx=3)
            
            ctk.CTkButton(
                file_controls,
                text="🗄️ Load DB",
                command=self.load_from_db,
                fg_color=FTBTheme.SURFACE,
                hover_color=FTBTheme.BUTTON_SECONDARY_HOVER,
                width=90,
                height=35,
                font=("Arial", 11)
            ).pack(side=tk.LEFT, padx=3)
            
            ctk.CTkButton(
                file_controls,
                text="🔄 New",
                command=self.new_game,
                fg_color=FTBTheme.SURFACE,
                hover_color=FTBTheme.BUTTON_SECONDARY_HOVER,
                width=80,
                height=35,
                font=("Arial", 11)
            ).pack(side=tk.LEFT, padx=3)
            
            # Notification bell button
            self.notif_btn = ctk.CTkButton(
                file_controls,
                text="🔔",
                command=self.show_notification_center,
                fg_color=FTBTheme.SURFACE,
                hover_color=FTBTheme.BUTTON_SECONDARY_HOVER,
                width=60,
                height=35,
                font=("Arial", 16)
            )
            self.notif_btn.pack(side=tk.LEFT, padx=3)
            
            # Toast notification container (overlays on top-right)
            self.toast_container = ctk.CTkFrame(
                self.container, 
                fg_color="transparent",
                width=350
            )
            self.toast_container.place(relx=1.0, rely=0.0, x=-10, y=70, anchor="ne")
            
            # --- Tabbed Interface ---
            self.tabview = ctk.CTkTabview(
                self.container,
                fg_color=FTBTheme.PANEL,
                segmented_button_fg_color=FTBTheme.SURFACE,
                segmented_button_selected_color=FTBTheme.ACCENT,
                segmented_button_selected_hover_color=FTBTheme.ACCENT_HOVER,
                segmented_button_unselected_color=FTBTheme.SURFACE,
                segmented_button_unselected_hover_color=FTBTheme.BUTTON_SECONDARY_HOVER,
                text_color=FTBTheme.TEXT
            )
            self.tabview.pack(fill=tk.BOTH, expand=True, padx=10, pady=10)
            
            # Create tabs
            self.tab_dashboard = self.tabview.add("Dashboard")
            self.tab_ai_assistant = self.tabview.add("AI Assistant")
            self.tab_team = self.tabview.add("Team")
            self.tab_manager_career = self.tabview.add("Manager Career")
            self.tab_car = self.tabview.add("Car")
            self.tab_development = self.tabview.add("Development")
            self.tab_finance = self.tabview.add("Finance")
            self.tab_race_ops = self.tabview.add("Race Operations")
            self.tab_racing_stats = self.tabview.add("Racing Stats")  # New tab
            self.tab_analytics = self.tabview.add("Analytics")
            self.tab_sponsors = self.tabview.add("Sponsors")
            self.tab_penalties = self.tabview.add("Penalties")
            self.tab_audio_settings = self.tabview.add("Audio Settings")  # New audio settings tab
            self.tab_history = self.tabview.add("History")  # New history tab
            
            # Build each tab
            self._build_dashboard_tab()
            self._build_ai_assistant_tab()
            self._build_team_tab()
            self._build_manager_career_tab()
            self._build_car_tab()
            self._build_development_tab()
            self._build_finance_tab()
            self._build_race_ops_tab()
            self._build_racing_stats_tab()  # New tab builder
            self._build_analytics_tab()
            self._build_sponsors_tab()
            self._build_penalties_tab()
            self._build_audio_settings_tab()  # New audio settings tab builder
            self._build_history_tab()  # New history tab builder
        
        def _build_dashboard_tab(self):
            """Build Dashboard tab - Time Control, Delegation, Metrics, Event Log"""
            tab = self.tab_dashboard
            
            # Left side - Controls and Metrics
            left = ctk.CTkScrollableFrame(tab, fg_color="transparent")
            left.pack(side=tk.LEFT, fill=tk.BOTH, expand=True, padx=(0, 5))
            
            # Pressure Indicators
            pressure_panel = ctk.CTkFrame(left, fg_color=FTBTheme.CARD, corner_radius=8)
            pressure_panel.pack(fill=tk.X, pady=(0, 10))
            
            # Header row with title and refresh button
            header_row = ctk.CTkFrame(pressure_panel, fg_color="transparent")
            header_row.pack(fill=tk.X, padx=15, pady=(15, 10))
            
            ctk.CTkLabel(
                header_row,
                text="⚠️ Pressure Indicators",
                font=("Arial", 14, "bold"),
                text_color=FTBTheme.TEXT
            ).pack(side=tk.LEFT)
            
            # Refresh button
            ctk.CTkButton(
                header_row,
                text="🔄 Refresh",
                command=self._force_dashboard_refresh,
                fg_color=FTBTheme.BUTTON_SECONDARY,
                hover_color=FTBTheme.BUTTON_SECONDARY_HOVER,
                width=100,
                height=28,
                font=("Arial", 11)
            ).pack(side=tk.RIGHT)
            
            indicators_grid = ctk.CTkFrame(pressure_panel, fg_color="transparent")
            indicators_grid.pack(fill=tk.X, padx=15, pady=(0, 15))
            
            # Cash Runway
            self.runway_metric = MetricDisplay(
                indicators_grid,
                label="Cash Runway",
                value="--",
                color=FTBTheme.TEXT_MUTED,
                sublabel="weeks remaining"
            )
            self.runway_metric.pack(side=tk.LEFT, fill=tk.BOTH, expand=True, padx=5)
            
            # Reputation
            self.rep_metric = MetricDisplay(
                indicators_grid,
                label="Reputation",
                value="--",
                color=FTBTheme.TEXT_MUTED,
                sublabel="trend"
            )
            self.rep_metric.pack(side=tk.LEFT, fill=tk.BOTH, expand=True, padx=5)
            
            # Morale
            self.morale_metric = MetricDisplay(
                indicators_grid,
                label="Morale",
                value="--",
                color=FTBTheme.TEXT_MUTED,
                sublabel=""
            )
            self.morale_metric.pack(side=tk.LEFT, fill=tk.BOTH, expand=True, padx=5)
            
            # Second row of metrics
            indicators_grid2 = ctk.CTkFrame(pressure_panel, fg_color="transparent")
            indicators_grid2.pack(fill=tk.X, padx=15, pady=(0, 15))
            
            # Owner Pressure
            self.owner_pressure_metric = MetricDisplay(
                indicators_grid2,
                label="Board Confidence",
                value="--",
                color=FTBTheme.TEXT_MUTED,
                sublabel="owner support"
            )
            self.owner_pressure_metric.pack(side=tk.LEFT, fill=tk.BOTH, expand=True, padx=5)
            
            # Budget Burn Rate
            self.burn_rate_metric = MetricDisplay(
                indicators_grid2,
                label="Burn Rate",
                value="--",
                color=FTBTheme.TEXT_MUTED,
                sublabel="daily spend"
            )
            self.burn_rate_metric.pack(side=tk.LEFT, fill=tk.BOTH, expand=True, padx=5)
            
            # Sponsor Health
            self.sponsor_metric = MetricDisplay(
                indicators_grid2,
                label="Sponsor Health",
                value="--",
                color=FTBTheme.TEXT_MUTED,
                sublabel="avg confidence"
            )
            self.sponsor_metric.pack(side=tk.LEFT, fill=tk.BOTH, expand=True, padx=5)
            
            # Team Overview - Enhanced
            team_panel = ctk.CTkFrame(left, fg_color=FTBTheme.CARD, corner_radius=8)
            team_panel.pack(fill=tk.X, pady=(0, 10))
            
            ctk.CTkLabel(
                team_panel,
                text="🏁 Team Overview",
                font=("Arial", 16, "bold"),
                text_color=FTBTheme.ACCENT
            ).pack(padx=15, pady=(15, 10), anchor="w")
            
            # Team name and tier
            self.team_name_label = ctk.CTkLabel(
                team_panel,
                text="Team: Loading...",
                text_color=FTBTheme.TEXT,
                font=("Arial", 13, "bold"),
                anchor="w"
            )
            self.team_name_label.pack(padx=15, pady=(2, 8), anchor="w")
            
            # Budget and championship in one row
            info_row = ctk.CTkFrame(team_panel, fg_color="transparent")
            info_row.pack(fill=tk.X, padx=15, pady=2)
            
            self.team_budget_label = ctk.CTkLabel(
                info_row,
                text="💰 $0",
                text_color=FTBTheme.SUCCESS,
                font=("Arial", 12, "bold"),
                anchor="w"
            )
            self.team_budget_label.pack(side=tk.LEFT, padx=(0, 20))
            
            self.team_position_label = ctk.CTkLabel(
                info_row,
                text="📊 Position: --",
                text_color=FTBTheme.TEXT,
                font=("Arial", 12),
                anchor="w"
            )
            self.team_position_label.pack(side=tk.LEFT)
            
            # League and points row
            info_row2 = ctk.CTkFrame(team_panel, fg_color="transparent")
            info_row2.pack(fill=tk.X, padx=15, pady=2)
            
            self.team_league_label = ctk.CTkLabel(
                info_row2,
                text="🏆 Loading...",
                text_color=FTBTheme.TEXT_MUTED,
                font=("Arial", 11),
                anchor="w"
            )
            self.team_league_label.pack(side=tk.LEFT, padx=(0, 20))
            
            self.team_points_label = ctk.CTkLabel(
                info_row2,
                text="⭐ 0 pts",
                text_color=FTBTheme.TEXT_MUTED,
                font=("Arial", 11),
                anchor="w"
            )
            self.team_points_label.pack(side=tk.LEFT)
            
            # Separator
            ctk.CTkFrame(team_panel, height=1, fg_color=FTBTheme.SURFACE).pack(fill=tk.X, padx=15, pady=8)
            
            # Morale with progress bar
            ctk.CTkLabel(
                team_panel,
                text="Team Morale",
                text_color=FTBTheme.TEXT_MUTED,
                font=("Arial", 10),
                anchor="w"
            ).pack(padx=15, pady=(2, 2), anchor="w")
            
            morale_frame = ctk.CTkFrame(team_panel, fg_color="transparent")
            morale_frame.pack(fill=tk.X, padx=15, pady=2)
            
            self.team_morale_bar = ctk.CTkProgressBar(
                morale_frame,
                width=200,
                height=14,
                fg_color=FTBTheme.SURFACE,
                progress_color=FTBTheme.SUCCESS
            )
            self.team_morale_bar.set(0.5)
            self.team_morale_bar.pack(side=tk.LEFT, padx=(0, 10))
            
            self.team_morale_label = ctk.CTkLabel(
                morale_frame,
                text="50%",
                text_color=FTBTheme.TEXT,
                font=("Arial", 10, "bold"),
                anchor="w"
            )
            self.team_morale_label.pack(side=tk.LEFT)
            
            # Reputation with progress bar
            ctk.CTkLabel(
                team_panel,
                text="Reputation",
                text_color=FTBTheme.TEXT_MUTED,
                font=("Arial", 10),
                anchor="w"
            ).pack(padx=15, pady=(4, 2), anchor="w")
            
            rep_frame = ctk.CTkFrame(team_panel, fg_color="transparent")
            rep_frame.pack(fill=tk.X, padx=15, pady=2)
            
            self.team_reputation_bar = ctk.CTkProgressBar(
                rep_frame,
                width=200,
                height=14,
                fg_color=FTBTheme.SURFACE,
                progress_color=FTBTheme.WARNING
            )
            self.team_reputation_bar.set(0.5)
            self.team_reputation_bar.pack(side=tk.LEFT, padx=(0, 10))
            
            self.team_reputation_label = ctk.CTkLabel(
                rep_frame,
                text="50%",
                text_color=FTBTheme.TEXT,
                font=("Arial", 10, "bold"),
                anchor="w"
            )
            self.team_reputation_label.pack(side=tk.LEFT)
            
            # Separator
            ctk.CTkFrame(team_panel, height=1, fg_color=FTBTheme.SURFACE).pack(fill=tk.X, padx=15, pady=8)
            
            # Car performance indicator
            self.team_car_label = ctk.CTkLabel(
                team_panel,
                text="🏎️ Car Performance: --",
                text_color=FTBTheme.TEXT,
                font=("Arial", 11),
                anchor="w"
            )
            self.team_car_label.pack(padx=15, pady=2, anchor="w")
            
            # Staff summary
            self.team_staff_label = ctk.CTkLabel(
                team_panel,
                text="👥 Staff: --",
                text_color=FTBTheme.TEXT_MUTED,
                font=("Arial", 11),
                anchor="w"
            )
            self.team_staff_label.pack(padx=15, pady=2, anchor="w")
            
            # Driver status
            self.team_driver_status_label = ctk.CTkLabel(
                team_panel,
                text="🏁 Drivers: --",
                text_color=FTBTheme.TEXT_MUTED,
                font=("Arial", 11),
                anchor="w"
            )
            self.team_driver_status_label.pack(padx=15, pady=2, anchor="w")
            
            # Form/Streak indicator
            self.team_form_label = ctk.CTkLabel(
                team_panel,
                text="📈 Form: No recent races",
                text_color=FTBTheme.TEXT_MUTED,
                font=("Arial", 11),
                anchor="w"
            )
            self.team_form_label.pack(padx=15, pady=(2, 15), anchor="w")
            
            # Contract Alerts Panel
            contracts_panel = ctk.CTkFrame(left, fg_color=FTBTheme.CARD, corner_radius=8)
            contracts_panel.pack(fill=tk.X, pady=(0, 10))
            
            ctk.CTkLabel(
                contracts_panel,
                text="📝 Contract Alerts",
                font=("Arial", 14, "bold"),
                text_color=FTBTheme.TEXT
            ).pack(padx=15, pady=(15, 10), anchor="w")
            
            self.contract_alerts_label = ctk.CTkLabel(
                contracts_panel,
                text="No expiring contracts",
                text_color=FTBTheme.TEXT_MUTED,
                font=("Arial", 11),
                anchor="w",
                wraplength=400
            )
            self.contract_alerts_label.pack(padx=15, pady=(0, 15), anchor="w")
            
            # Recent Race Results Panel
            results_panel = ctk.CTkFrame(left, fg_color=FTBTheme.CARD, corner_radius=8)
            results_panel.pack(fill=tk.X, pady=(0, 10))
            
            ctk.CTkLabel(
                results_panel,
                text="🏆 Recent Race Results",
                font=("Arial", 14, "bold"),
                text_color=FTBTheme.TEXT
            ).pack(padx=15, pady=(15, 10), anchor="w")
            
            # Scrollable frame for race results
            self.race_results_container = ctk.CTkScrollableFrame(
                results_panel,
                fg_color="transparent",
                height=120
            )
            self.race_results_container.pack(fill=tk.BOTH, expand=True, padx=15, pady=(0, 15))
            
            self.race_results_label = ctk.CTkLabel(
                self.race_results_container,
                text="No recent races",
                text_color=FTBTheme.TEXT_MUTED,
                font=("Arial", 11),
                anchor="w"
            )
            self.race_results_label.pack(anchor="w")
            
            # Right side - Event Log with Tabs
            right = ctk.CTkFrame(tab, fg_color=FTBTheme.CARD, corner_radius=8)
            right.pack(side=tk.RIGHT, fill=tk.BOTH, expand=True)
            
            ctk.CTkLabel(
                right,
                text="📋 Event Log",
                font=("Arial", 14, "bold"),
                text_color=FTBTheme.TEXT
            ).pack(padx=15, pady=(15, 10), anchor="w")
            
            # Create tabview for Personal and World events
            self.event_log_tabview = ctk.CTkTabview(
                right,
                fg_color=FTBTheme.SURFACE,
                segmented_button_fg_color=FTBTheme.SURFACE,
                segmented_button_selected_color=FTBTheme.ACCENT,
                segmented_button_selected_hover_color=FTBTheme.CARD_HOVER,
            )
            self.event_log_tabview.pack(fill=tk.BOTH, expand=True, padx=15, pady=(0, 15))
            
            # Add two tabs
            self.event_log_tabview.add("Personal Events")
            self.event_log_tabview.add("World Events")
            
            # Personal events textbox (scrollable)
            self.personal_events_text = ctk.CTkTextbox(
                self.event_log_tabview.tab("Personal Events"),
                fg_color=FTBTheme.SURFACE,
                text_color=FTBTheme.TEXT,
                font=("Consolas", 10),
                wrap="word",
                activate_scrollbars=True
            )
            self.personal_events_text.pack(fill=tk.BOTH, expand=True)
            
            # World events textbox (scrollable)
            self.world_events_text = ctk.CTkTextbox(
                self.event_log_tabview.tab("World Events"),
                fg_color=FTBTheme.SURFACE,
                text_color=FTBTheme.TEXT,
                font=("Consolas", 10),
                wrap="word",
                activate_scrollbars=True
            )
            self.world_events_text.pack(fill=tk.BOTH, expand=True)
        
        def _build_ai_assistant_tab(self):
            """Build AI Assistant tab - Delegation controls and decision log"""
            tab = self.tab_ai_assistant
            
            # Main scrollable container
            container = ctk.CTkScrollableFrame(tab, fg_color="transparent")
            container.pack(fill=tk.BOTH, expand=True, padx=10, pady=10)
            
            # Header
            header = ctk.CTkFrame(container, fg_color=FTBTheme.CARD, corner_radius=8)
            header.pack(fill=tk.X, pady=(0, 10))
            
            ctk.CTkLabel(
                header,
                text="🤖 AI Assistant",
                font=("Arial", 18, "bold"),
                text_color=FTBTheme.ACCENT
            ).pack(padx=20, pady=15, anchor="w")
            
            # Status Panel
            status_panel = ctk.CTkFrame(container, fg_color=FTBTheme.CARD, corner_radius=8)
            status_panel.pack(fill=tk.X, pady=(0, 10))
            
            ctk.CTkLabel(
                status_panel,
                text="Status & Control",
                font=("Arial", 14, "bold"),
                text_color=FTBTheme.TEXT
            ).pack(padx=20, pady=(15, 10), anchor="w")
            
            # Status indicator
            status_frame = ctk.CTkFrame(status_panel, fg_color="transparent")
            status_frame.pack(fill=tk.X, padx=20, pady=5)
            
            ctk.CTkLabel(
                status_frame,
                text="Mode:",
                text_color=FTBTheme.TEXT_MUTED,
                font=("Arial", 12),
                width=120,
                anchor="w"
            ).pack(side=tk.LEFT)
            
            self.ai_mode_label = ctk.CTkLabel(
                status_frame,
                text="MANUAL",
                font=("Arial", 12, "bold"),
                text_color=FTBTheme.WARNING,
                anchor="w"
            )
            self.ai_mode_label.pack(side=tk.LEFT)
            
            # Control buttons
            btn_frame = ctk.CTkFrame(status_panel, fg_color="transparent")
            btn_frame.pack(fill=tk.X, padx=20, pady=(10, 15))
            
            self.enable_delegation_btn = ctk.CTkButton(
                btn_frame,
                text="Enable Delegation",
                command=self._enable_delegation,
                fg_color=FTBTheme.SUCCESS,
                hover_color=FTBTheme.SUCCESS_HOVER,
                width=180,
                height=40,
                font=("Arial", 12, "bold")
            )
            self.enable_delegation_btn.pack(side=tk.LEFT, padx=5)
            
            self.disable_delegation_btn = ctk.CTkButton(
                btn_frame,
                text="Regain Control",
                command=self._disable_delegation,
                fg_color=FTBTheme.DANGER,
                hover_color=FTBTheme.DANGER_HOVER,
                width=180,
                height=40,
                font=("Arial", 12, "bold"),
                state="disabled"
            )
            self.disable_delegation_btn.pack(side=tk.LEFT, padx=5)
            
            # ======================================
            # DELEGATION FOCUS PANEL (NEW)
            # ======================================
            focus_panel = ctk.CTkFrame(container, fg_color=FTBTheme.CARD, corner_radius=8)
            focus_panel.pack(fill=tk.X, pady=(0, 10))
            
            ctk.CTkLabel(
                focus_panel,
                text="🎯 Delegation Focus",
                font=("Arial", 14, "bold"),
                text_color=FTBTheme.TEXT
            ).pack(padx=20, pady=(15, 5), anchor="w")
            
            ctk.CTkLabel(
                focus_panel,
                text="Guide your manager's priorities. Focus shapes how decisions are weighted.",
                font=("Arial", 10),
                text_color=FTBTheme.TEXT_MUTED,
                wraplength=700
            ).pack(padx=20, pady=(0, 10), anchor="w")
            
            # Current focus display
            current_focus_frame = ctk.CTkFrame(focus_panel, fg_color=FTBTheme.SURFACE, corner_radius=6)
            current_focus_frame.pack(fill=tk.X, padx=20, pady=(0, 10))
            
            current_label_container = ctk.CTkFrame(current_focus_frame, fg_color="transparent")
            current_label_container.pack(fill=tk.X, padx=15, pady=10)
            
            ctk.CTkLabel(
                current_label_container,
                text="Current Focus:",
                font=("Arial", 11, "bold"),
                text_color=FTBTheme.TEXT_MUTED,
                width=120,
                anchor="w"
            ).pack(side=tk.LEFT)
            
            self.current_focus_label = ctk.CTkLabel(
                current_label_container,
                text="None (using base personality)",
                font=("Arial", 11),
                text_color=FTBTheme.TEXT,
                anchor="w",
                wraplength=500
            )
            self.current_focus_label.pack(side=tk.LEFT, fill=tk.X, expand=True)
            
            # Focus input
            input_frame = ctk.CTkFrame(focus_panel, fg_color="transparent")
            input_frame.pack(fill=tk.X, padx=20, pady=(0, 10))
            
            ctk.CTkLabel(
                input_frame,
                text="New Focus:",
                font=("Arial", 11),
                text_color=FTBTheme.TEXT_MUTED,
                width=120,
                anchor="w"
            ).pack(side=tk.LEFT, padx=(0, 10))
            
            self.focus_text_entry = ctk.CTkEntry(
                input_frame,
                placeholder_text="e.g., 'Stabilize finances', 'Develop young drivers', 'Push for promotion'",
            

                fg_color=FTBTheme.SURFACE,
                border_color=FTBTheme.BORDER,
                text_color=FTBTheme.TEXT,
                height=40,
                font=("Arial", 11)
            )
            self.focus_text_entry.pack(side=tk.LEFT, fill=tk.X, expand=True, padx=(0, 10))
            
            # Focus buttons
            focus_btn_frame = ctk.CTkFrame(focus_panel, fg_color="transparent")
            focus_btn_frame.pack(fill=tk.X, padx=20, pady=(0, 15))
            
            ctk.CTkButton(
                focus_btn_frame,
                text="Apply Focus",
                command=self._apply_focus,
                fg_color=FTBTheme.ACCENT,
                hover_color=FTBTheme.ACCENT_HOVER,
                width=140,
                height=35,
                font=("Arial", 11, "bold")
            ).pack(side=tk.LEFT, padx=(0, 10))
            
            ctk.CTkButton(
                focus_btn_frame,
                text="Clear Focus",
                command=self._clear_focus,
                fg_color=FTBTheme.TEXT_DIM,
                hover_color=FTBTheme.BUTTON_SECONDARY_HOVER,
                text_color=FTBTheme.TEXT,
                width=140,
                height=35,
                font=("Arial", 11)
            ).pack(side=tk.LEFT)
            
            # Focus examples (collapsible)
            examples_label = ctk.CTkLabel(
                focus_panel,
                text="💡 Example Focuses: 'Cut costs', 'Build for the future', 'Win at all costs', 'Develop rookies'",
                font=("Arial", 9),
                text_color=FTBTheme.TEXT_DIM,
                wraplength=700,
                justify="left"
            )
            examples_label.pack(padx=20, pady=(0, 15), anchor="w")
            
            # Decision History Panel
            history_panel = ctk.CTkFrame(container, fg_color=FTBTheme.CARD, corner_radius=8)
            history_panel.pack(fill=tk.BOTH, expand=True)
            
            ctk.CTkLabel(
                history_panel,
                text="Recent AI Decisions",
                font=("Arial", 14, "bold"),
                text_color=FTBTheme.TEXT
            ).pack(padx=20, pady=(15, 5), anchor="w")
            
            ctk.CTkLabel(
                history_panel,
                text="Actions taken by the AI assistant:",
                font=("Arial", 10),
                text_color=FTBTheme.TEXT_MUTED
            ).pack(padx=20, pady=(0, 10), anchor="w")
            
            # Scrollable decision log
            self.ai_decision_log = ctk.CTkScrollableFrame(
                history_panel,
                fg_color=FTBTheme.SURFACE,
                corner_radius=6,
                height=300
            )
            self.ai_decision_log.pack(fill=tk.BOTH, expand=True, padx=20, pady=(0, 15))
            
            # Placeholder
            self.ai_empty_label = ctk.CTkLabel(
                self.ai_decision_log,
                text="No AI decisions yet.\nEnable delegation to see the AI in action.",
                font=("Arial", 12),
                text_color=FTBTheme.TEXT_MUTED,
                justify="center"
            )
            self.ai_empty_label.pack(pady=50)
        
        def _build_team_tab(self):
            """Build Team tab - Roster, Job Board, Hiring"""
            tab = self.tab_team
            
            # Two column layout
            left_panel = ctk.CTkScrollableFrame(tab, fg_color="transparent")
            left_panel.pack(side=tk.LEFT, fill=tk.BOTH, expand=True, padx=(0, 5))
            
            right_panel = ctk.CTkScrollableFrame(tab, fg_color="transparent")
            right_panel.pack(side=tk.RIGHT, fill=tk.BOTH, expand=True, padx=(5, 0))
            
            # Left: Financial Overview (at top)
            fin_overview = ctk.CTkFrame(left_panel, fg_color=FTBTheme.CARD, corner_radius=8)
            fin_overview.pack(fill=tk.X, pady=(0, 10))
            
            ctk.CTkLabel(
                fin_overview,
                text="💰 Financial Overview",
                font=("Arial", 16, "bold"),
                text_color=FTBTheme.TEXT
            ).pack(padx=15, pady=(15, 10), anchor="w")
            
            self.financial_overview_container = ctk.CTkFrame(fin_overview, fg_color="transparent")
            self.financial_overview_container.pack(fill=tk.X, padx=15, pady=(0, 15))
            
            # Left: Current Roster
            roster_header = ctk.CTkFrame(left_panel, fg_color=FTBTheme.CARD, corner_radius=8)
            roster_header.pack(fill=tk.X, pady=(0, 10))
            
            ctk.CTkLabel(
                roster_header,
                text="👥 Current Roster",
                font=("Arial", 16, "bold"),
                text_color=FTBTheme.TEXT
            ).pack(side=tk.LEFT, padx=15, pady=15)
            
            ctk.CTkButton(
                roster_header,
                text="↻ Refresh",
                command=self._refresh_roster,
                fg_color=FTBTheme.ACCENT,
                hover_color=FTBTheme.ACCENT_HOVER,
                width=100,
                height=28,
                font=("Arial", 11)
            ).pack(side=tk.RIGHT, padx=15, pady=15)
            
            self.roster_container = ctk.CTkFrame(left_panel, fg_color="transparent")
            self.roster_container.pack(fill=tk.BOTH, expand=True)
            
            # Right: Job Board with Tabs
            job_header = ctk.CTkFrame(right_panel, fg_color=FTBTheme.CARD, corner_radius=8)
            job_header.pack(fill=tk.X, pady=(0, 10))
            
            ctk.CTkLabel(
                job_header,
                text="📋 Job Market",
                font=("Arial", 16, "bold"),
                text_color=FTBTheme.TEXT
            ).pack(side=tk.LEFT, padx=15, pady=15)
            
            ctk.CTkButton(
                job_header,
                text="🔄 Refresh",
                command=self._refresh_job_market,
                fg_color=FTBTheme.ACCENT,
                hover_color=FTBTheme.ACCENT_HOVER,
                width=100,
                height=30,
                font=("Arial", 11)
            ).pack(side=tk.RIGHT, padx=15, pady=15)
            
            # Create tabview for job board
            self.job_market_tabview = ctk.CTkTabview(right_panel, fg_color=FTBTheme.SURFACE, corner_radius=8)
            self.job_market_tabview.pack(fill=tk.BOTH, expand=True, pady=(0, 10))
            
            # Add tabs
            self.job_market_tabview.add("Job Openings")
            self.job_market_tabview.add("Poachable Drivers")  # NEW: Driver poaching tab
            self.job_market_tabview.add("Free Agent Drivers")
            self.job_market_tabview.add("Free Agent Engineers")
            self.job_market_tabview.add("Free Agent Mechanics")
            self.job_market_tabview.add("Free Agent Strategists")
            self.job_market_tabview.add("Free Agent Principals")
            
            # Create containers for each tab
            self.job_board_container = ctk.CTkScrollableFrame(
                self.job_market_tabview.tab("Job Openings"),
                fg_color="transparent"
            )
            self.job_board_container.pack(fill=tk.BOTH, expand=True)
            
            self.poachable_drivers_container = ctk.CTkScrollableFrame(
                self.job_market_tabview.tab("Poachable Drivers"),
                fg_color="transparent"
            )
            self.poachable_drivers_container.pack(fill=tk.BOTH, expand=True)
            
            self.free_agent_drivers_container = ctk.CTkScrollableFrame(
                self.job_market_tabview.tab("Free Agent Drivers"),
                fg_color="transparent"
            )
            self.free_agent_drivers_container.pack(fill=tk.BOTH, expand=True)
            
            self.free_agent_engineers_container = ctk.CTkScrollableFrame(
                self.job_market_tabview.tab("Free Agent Engineers"),
                fg_color="transparent"
            )
            self.free_agent_engineers_container.pack(fill=tk.BOTH, expand=True)
            
            self.free_agent_mechanics_container = ctk.CTkScrollableFrame(
                self.job_market_tabview.tab("Free Agent Mechanics"),
                fg_color="transparent"
            )
            self.free_agent_mechanics_container.pack(fill=tk.BOTH, expand=True)
            
            self.free_agent_strategists_container = ctk.CTkScrollableFrame(
                self.job_market_tabview.tab("Free Agent Strategists"),
                fg_color="transparent"
            )
            self.free_agent_strategists_container.pack(fill=tk.BOTH, expand=True)
            
            self.free_agent_principals_container = ctk.CTkScrollableFrame(
                self.job_market_tabview.tab("Free Agent Principals"),
                fg_color="transparent"
            )
            self.free_agent_principals_container.pack(fill=tk.BOTH, expand=True)
            
            # Right: Team Browser (below job board)
            browser_header = ctk.CTkFrame(right_panel, fg_color=FTBTheme.CARD, corner_radius=8)
            browser_header.pack(fill=tk.X, pady=(20, 10))
            
            ctk.CTkLabel(
                browser_header,
                text="🏁 Browse Teams",
                font=("Arial", 16, "bold"),
                text_color=FTBTheme.TEXT
            ).pack(side=tk.LEFT, padx=15, pady=15)
            
            ctk.CTkButton(
                browser_header,
                text="🔄 Refresh",
                command=self._refresh_team_browser,
                fg_color=FTBTheme.ACCENT,
                hover_color=FTBTheme.ACCENT_HOVER,
                width=100,
                height=30,
                font=("Arial", 11)
            ).pack(side=tk.RIGHT, padx=15, pady=15)
            
            self.team_browser_container = ctk.CTkFrame(right_panel, fg_color="transparent")
            self.team_browser_container.pack(fill=tk.BOTH, expand=True)
        
        def _refresh_roster(self):
            """Update roster display with current team entities"""
            if not self.sim_state or not self.sim_state.player_team:
                return
            if not hasattr(self, 'roster_container') or not self.roster_container:
                return
            try:
                if not self.roster_container.winfo_exists():
                    return
            except (tk.TclError, RuntimeError):
                return
            
            # Clear existing
            try:
                for widget in self.roster_container.winfo_children():
                    widget.destroy()
            except (tk.TclError, RuntimeError):
                return
            
            team = self.sim_state.player_team
            team.normalize_roster()
            
            # Drivers
            if team.drivers:
                self._add_roster_section(self.roster_container, "🏎️ Drivers", team.drivers, "Driver")
            
            # Engineers
            if team.engineers:
                self._add_roster_section(self.roster_container, "🔧 Engineers", team.engineers, "Engineer")
            
            # Mechanics
            if team.mechanics:
                self._add_roster_section(self.roster_container, "⚙️ Mechanics", team.mechanics, "Mechanic")
            
            # Strategist
            if team.strategist:
                self._add_roster_section(self.roster_container, "📊 Strategist", [team.strategist], "Strategist")
            
            # Principal (if AI-controlled)
            if team.principal:
                self._add_roster_section(self.roster_container, "👔 Principal", [team.principal], "Principal")
            
            # Empty state
            if not any([team.drivers, team.engineers, team.mechanics, team.strategist, team.principal]):
                empty_label = ctk.CTkLabel(
                    self.roster_container,
                    text="No staff hired yet.\nBrowse the job board to build your team.",
                    font=("Arial", 13),
                    text_color=FTBTheme.TEXT_MUTED,
                    justify="center"
                )
                empty_label.pack(pady=50)
        
        def _refresh_financial_overview(self):
            """Update financial overview display"""
            if not self.sim_state or not self.sim_state.player_team:
                return
            if not hasattr(self, 'financial_overview_container') or not self.financial_overview_container:
                return
            try:
                if not self.financial_overview_container.winfo_exists():
                    return
            except (tk.TclError, RuntimeError):
                return
            
            # Clear existing
            try:
                for widget in self.financial_overview_container.winfo_children():
                    widget.destroy()
            except (tk.TclError, RuntimeError):
                return
            
            team = self.sim_state.player_team
            
            # Calculate financials
            cash = team.budget.cash
            weekly_salaries = sum(team.budget.staff_salaries.values())
            
            # Calculate total contract obligations (future payments)
            total_contract_value = 0
            for entity_id in list(self.sim_state.contracts.keys()):
                contract = self.sim_state.contracts[entity_id]
                if contract.team_name == team.name:
                    total_contract_value += contract.total_value()
            
            # Tier context
            tier_name = team.tier_name if hasattr(team, 'tier_name') else 'grassroots'
            tier_config = {
                'grassroots': {'range': '$200K-$500K', 'display': 'Grassroots'},
                'formula_v': {'range': '$800K-$1.5M', 'display': 'Formula V'},
                'formula_x': {'range': '$3M-$8M', 'display': 'Formula X'},
                'formula_y': {'range': '$15M-$40M', 'display': 'Formula Y'},
                'formula_z': {'range': '$140M-$400M', 'display': 'Formula Z'}
            }
            
            tier_info = tier_config.get(tier_name, {'range': 'Unknown', 'display': tier_name.replace('_', ' ').title()})
            
            # Display info
            info_text = f"""Current Cash: {format_currency(cash)}
Weekly Expenses: {format_currency(weekly_salaries)}
Total Contract Obligations: {format_currency(total_contract_value)}

Tier: {tier_info['display']}
Typical Budget Range: {tier_info['range']}"""
            
            ctk.CTkLabel(
                self.financial_overview_container,
                text=info_text,
                font=("Arial", 11),
                text_color=FTBTheme.TEXT,
                justify="left",
                anchor="w"
            ).pack(fill=tk.X)
        
        def _add_roster_section(self, parent, title: str, entities: list, entity_type: str):
            """Add a roster section for one entity type"""
            section = ctk.CTkFrame(parent, fg_color=FTBTheme.CARD, corner_radius=8)
            section.pack(fill=tk.X, pady=(0, 10))
            
            # Section header
            header_frame = ctk.CTkFrame(section, fg_color="transparent")
            header_frame.pack(fill=tk.X, padx=15, pady=(15, 10))
            
            ctk.CTkLabel(
                header_frame,
                text=title,
                font=("Arial", 13, "bold"),
                text_color=FTBTheme.TEXT,
                anchor="w"
            ).pack(side=tk.LEFT)
            
            ctk.CTkLabel(
                header_frame,
                text=f"({len(entities)})",
                font=("Arial", 11),
                text_color=FTBTheme.TEXT_MUTED
            ).pack(side=tk.LEFT, padx=(5, 0))
            
            # Entity cards
            for entity in [entry for entry in entities if entry]:
                self._add_entity_card(section, entity, entity_type)
        
        def _add_entity_card(self, parent, entity, entity_type: str):
            """Add an individual entity card with stats and actions"""
            card = ctk.CTkFrame(parent, fg_color=FTBTheme.SURFACE, corner_radius=6)
            card.pack(fill=tk.X, padx=15, pady=5)
            
            # Main info
            info_frame = ctk.CTkFrame(card, fg_color="transparent")
            info_frame.pack(fill=tk.X, padx=10, pady=10)
            
            # Add sprite if entity has entity_id
            if hasattr(entity, 'entity_id'):
                try:
                    sprite_pil = generate_entity_sprite(entity.entity_id, size=32)
                    ctk_sprite = ctk.CTkImage(light_image=sprite_pil, dark_image=sprite_pil, size=(32, 32))
                    sprite_label = ctk.CTkLabel(
                        info_frame,
                        image=ctk_sprite,
                        text=""
                    )
                    sprite_label.pack(side=tk.LEFT, padx=(0, 10))
                except Exception as e:
                    _dbg(f"[FTB] Error displaying sprite in entity card: {e}")
            
            # Name and age
            name_label = ctk.CTkLabel(
                info_frame,
                text=entity.name,
                font=("Arial", 12, "bold"),
                text_color=FTBTheme.TEXT,
                anchor="w"
            )
            name_label.pack(side=tk.LEFT, fill=tk.X, expand=True)
            
            if hasattr(entity, 'age'):
                age_label = ctk.CTkLabel(
                    info_frame,
                    text=f"Age {entity.age}",
                    font=("Arial", 10),
                    text_color=FTBTheme.TEXT_MUTED
                )
                age_label.pack(side=tk.LEFT, padx=(10, 0))
            
            # Rating
            if hasattr(entity, 'overall_rating'):
                rating = entity.overall_rating
                rating_color = FTBTheme.get_stat_color(rating)
                rating_label = ctk.CTkLabel(
                    info_frame,
                    text=f"{rating:.0f}",
                    font=("Arial", 14, "bold"),
                    text_color=rating_color,
                    width=40
                )
                rating_label.pack(side=tk.RIGHT, padx=(10, 0))
            
            # Salary info
            if self.sim_state and self.sim_state.player_team:
                salary = self.sim_state.player_team.budget.staff_salaries.get(entity.name, 0)
                if salary > 0:
                    salary_label = ctk.CTkLabel(
                        card,
                        text=f"💰 {format_currency(salary)}/tick",
                        font=("Arial", 10),
                        text_color=FTBTheme.TEXT_MUTED
                    )
                    salary_label.pack(padx=10, pady=(0, 5), anchor="w")
            
            # Contract info
            if self.sim_state and hasattr(entity, 'entity_id') and entity.entity_id in self.sim_state.contracts:
                contract = self.sim_state.contracts[entity.entity_id]
                days_remaining = contract.days_remaining(self.sim_state.sim_day_of_year)
                seasons_remaining = contract.seasons_remaining(self.sim_state.sim_day_of_year)
                
                # Color code based on time remaining
                if days_remaining <= 30:
                    contract_color = FTBTheme.WARNING
                elif days_remaining <= 90:
                    contract_color = FTBTheme.TEXT_MUTED
                else:
                    contract_color = FTBTheme.SUCCESS
                
                contract_text = f"📄 Contract: {seasons_remaining:.1f} seasons ({days_remaining} days remaining)"
                contract_label = ctk.CTkLabel(
                    card,
                    text=contract_text,
                    font=("Arial", 10),
                    text_color=contract_color
                )
                contract_label.pack(padx=10, pady=(0, 5), anchor="w")
            
            # Action buttons
            actions_frame = ctk.CTkFrame(card, fg_color="transparent")
            actions_frame.pack(fill=tk.X, padx=10, pady=(5, 10))
            
            ctk.CTkButton(
                actions_frame,
                text="📊 View Stats",
                command=lambda e=entity: self._show_entity_stats(e),
                fg_color=FTBTheme.ACCENT,
                hover_color=FTBTheme.ACCENT_HOVER,
                height=28,
                width=100,
                font=("Arial", 10)
            ).pack(side=tk.LEFT, padx=(0, 5))
            
            ctk.CTkButton(
                actions_frame,
                text="📄 Contract",
                command=lambda e=entity: self._show_contract_details(e),
                fg_color=FTBTheme.SURFACE,
                hover_color=FTBTheme.BUTTON_SECONDARY_HOVER,
                height=28,
                width=100,
                font=("Arial", 10)
            ).pack(side=tk.LEFT, padx=5)
            
            ctk.CTkButton(
                actions_frame,
                text="❌ Fire",
                command=lambda e=entity: self._fire_entity(e),
                fg_color=FTBTheme.DANGER,
                hover_color=FTBTheme.DANGER_HOVER,
                height=28,
                width=80,
                font=("Arial", 10)
            ).pack(side=tk.RIGHT)
        
        def _refresh_job_market(self):
            """Update all job market displays"""
            self._refresh_job_board()
            self._refresh_poachable_drivers()  # NEW: Refresh poachable drivers tab
            self._refresh_free_agent_drivers()
            self._refresh_free_agent_engineers()
            self._refresh_free_agent_mechanics()
            self._refresh_free_agent_strategists()
            self._refresh_free_agent_principals()
        
        def _refresh_job_board(self):
            """Update job board display"""
            if not self.sim_state:
                return
            
            # Clear existing
            for widget in self.job_board_container.winfo_children():
                widget.destroy()
            
            # Get visible vacancies
            player_metrics = self.sim_state.player_team.standing_metrics if self.sim_state.player_team else {}
            visible_vacancies = self.sim_state.job_board.filter_visible_to_player(player_metrics)
            
            if not visible_vacancies:
                empty_label = ctk.CTkLabel(
                    self.job_board_container,
                    text="No positions available at your level.\n\nImprove your legitimacy and reputation\nto unlock more opportunities.",
                    font=("Arial", 13),
                    text_color=FTBTheme.TEXT_MUTED,
                    justify="center"
                )
                empty_label.pack(pady=50)
                return
            
            # Show vacancies
            for listing in visible_vacancies:
                self._add_job_listing_card(self.job_board_container, listing)
        
        def _refresh_poachable_drivers(self):
            """Update poachable (contracted but open to offers) drivers display"""
            if not self.sim_state or not self.sim_state.player_team:
                return
            
            # Clear existing
            for widget in self.poachable_drivers_container.winfo_children():
                widget.destroy()
            
            # Find all poachable contracted drivers
            poachable_drivers = []
            current_day = self.sim_state.sim_day_of_year
            
            # FIX: leagues is a dict, need to use .values()
            for league in self.sim_state.leagues.values():
                for team in league.teams:
                    # Don't show own team's drivers
                    if team == self.sim_state.player_team:
                        continue
                    
                    for driver in team.drivers:
                        if not driver:
                            continue
                        
                        # Get contract from central registry
                        entity_id = getattr(driver, 'entity_id', None)
                        if not entity_id or entity_id not in self.sim_state.contracts:
                            continue
                        
                        contract = self.sim_state.contracts[entity_id]
                        
                        # Check if poachable and open to offers
                        if contract.is_poachable(current_day) and contract.open_to_offers:
                            buyout = contract.calculate_buyout_amount(team.tier, current_day)
                            
                            poachable_drivers.append({
                                'entity': driver,
                                'team': team,
                                'contract': contract,
                                'buyout': buyout,
                                'morale': getattr(driver, 'morale', 50.0)
                            })
            
            # Display empty state or drivers
            if not poachable_drivers:
                empty_frame = ctk.CTkFrame(
                    self.poachable_drivers_container,
                    fg_color=FTBTheme.CARD,
                    corner_radius=8
                )
                empty_frame.pack(fill=tk.X, padx=10, pady=10)
                
                ctk.CTkLabel(
                    empty_frame,
                    text="🔒 No Drivers Currently Open to Offers",
                    font=("Arial", 14, "bold"),
                    text_color=FTBTheme.TEXT_MUTED
                ).pack(pady=(20, 10))
                
                ctk.CTkLabel(
                    empty_frame,
                    text="Drivers may become available when:\n• Morale drops below 55\n• Team underperforms (bottom 50% of league)\n• Financial instability at their team\n• High-talent drivers stuck in low tiers",
                    font=("Arial", 11),
                    text_color=FTBTheme.TEXT_MUTED,
                    justify="left"
                ).pack(padx=20, pady=(0, 20))
            else:
                # Sort by overall rating (best first)
                poachable_drivers.sort(key=lambda x: x['entity'].overall_rating, reverse=True)
                
                # Header info
                info_frame = ctk.CTkFrame(
                    self.poachable_drivers_container,
                    fg_color=FTBTheme.CARD,
                    corner_radius=8
                )
                info_frame.pack(fill=tk.X, padx=10, pady=(10, 15))
                
                ctk.CTkLabel(
                    info_frame,
                    text=f"🟡 {len(poachable_drivers)} Driver{'s' if len(poachable_drivers) != 1 else ''} Open to Offers",
                    font=("Arial", 13, "bold"),
                    text_color=FTBTheme.WARNING
                ).pack(padx=15, pady=12)
                
                # Display each poachable driver
                for item in poachable_drivers:
                    self._display_poachable_driver_card(self.poachable_drivers_container, item)
        
        def _refresh_free_agent_drivers(self):
            """Update free agent drivers display"""
            if not self.sim_state:
                return
            
            # Clear existing
            for widget in self.free_agent_drivers_container.winfo_children():
                widget.destroy()
            
            # Get drivers from free agent pool
            drivers = [fa for fa in self.sim_state.free_agents if fa.entity_type == "Driver"]
            
            if not drivers:
                empty_label = ctk.CTkLabel(
                    self.free_agent_drivers_container,
                    text="No drivers available in free agency.",
                    font=("Arial", 13),
                    text_color=FTBTheme.TEXT_MUTED,
                    justify="center"
                )
                empty_label.pack(pady=50)
                return
            
            # Sort by overall rating
            drivers.sort(key=lambda fa: fa.overall_rating, reverse=True)
            
            # Show free agents
            for fa in drivers:
                self._add_free_agent_card(self.free_agent_drivers_container, fa)
        
        def _refresh_free_agent_engineers(self):
            """Update free agent engineers display"""
            if not self.sim_state:
                return
            
            # Clear existing
            for widget in self.free_agent_engineers_container.winfo_children():
                widget.destroy()
            
            # Get engineers from free agent pool
            engineers = [fa for fa in self.sim_state.free_agents if fa.entity_type == "Engineer"]
            
            if not engineers:
                empty_label = ctk.CTkLabel(
                    self.free_agent_engineers_container,
                    text="No engineers available in free agency.",
                    font=("Arial", 13),
                    text_color=FTBTheme.TEXT_MUTED,
                    justify="center"
                )
                empty_label.pack(pady=50)
                return
            
            # Sort by overall rating
            engineers.sort(key=lambda fa: fa.overall_rating, reverse=True)
            
            # Show free agents
            for fa in engineers:
                self._add_free_agent_card(self.free_agent_engineers_container, fa)
        
        def _refresh_free_agent_mechanics(self):
            """Update free agent mechanics display"""
            if not self.sim_state:
                return
            
            # Clear existing
            for widget in self.free_agent_mechanics_container.winfo_children():
                widget.destroy()
            
            # Get mechanics from free agent pool
            mechanics = [fa for fa in self.sim_state.free_agents if fa.entity_type == "Mechanic"]
            
            if not mechanics:
                empty_label = ctk.CTkLabel(
                    self.free_agent_mechanics_container,
                    text="No mechanics available in free agency.",
                    font=("Arial", 13),
                    text_color=FTBTheme.TEXT_MUTED,
                    justify="center"
                )
                empty_label.pack(pady=50)
                return
            
            # Sort by overall rating
            mechanics.sort(key=lambda fa: fa.overall_rating, reverse=True)
            
            # Show free agents
            for fa in mechanics:
                self._add_free_agent_card(self.free_agent_mechanics_container, fa)
        
        def _refresh_free_agent_strategists(self):
            """Update free agent strategists display"""
            if not self.sim_state:
                return
            
            # Clear existing
            for widget in self.free_agent_strategists_container.winfo_children():
                widget.destroy()
            
            # Get strategists from free agent pool
            strategists = [fa for fa in self.sim_state.free_agents if fa.entity_type == "Strategist"]
            
            if not strategists:
                empty_label = ctk.CTkLabel(
                    self.free_agent_strategists_container,
                    text="No strategists available in free agency.",
                    font=("Arial", 13),
                    text_color=FTBTheme.TEXT_MUTED,
                    justify="center"
                )
                empty_label.pack(pady=50)
                return
            
            # Sort by overall rating
            strategists.sort(key=lambda fa: fa.overall_rating, reverse=True)
            
            # Show free agents
            for fa in strategists:
                self._add_free_agent_card(self.free_agent_strategists_container, fa)
        
        def _refresh_free_agent_principals(self):
            """Update free agent principals display"""
            if not self.sim_state:
                return
            
            # Clear existing
            for widget in self.free_agent_principals_container.winfo_children():
                widget.destroy()
            
            # Get principals from free agent pool
            principals = [fa for fa in self.sim_state.free_agents if fa.entity_type == "AIPrincipal"]
            
            if not principals:
                empty_label = ctk.CTkLabel(
                    self.free_agent_principals_container,
                    text="No principals available in free agency.",
                    font=("Arial", 13),
                    text_color=FTBTheme.TEXT_MUTED,
                    justify="center"
                )
                empty_label.pack(pady=50)
                return
            
            # Sort by overall rating
            principals.sort(key=lambda fa: fa.overall_rating, reverse=True)
            
            # Show free agents
            for fa in principals:
                self._add_free_agent_card(self.free_agent_principals_container, fa)
        
        def _add_job_listing_card(self, parent, listing):
            """Add a job listing card"""
            card = ctk.CTkFrame(parent, fg_color=FTBTheme.CARD, corner_radius=8)
            card.pack(fill=tk.X, pady=(0, 10))
            
            # Team name
            team_name = listing.team.name if listing.team else listing.team_name
            ctk.CTkLabel(
                card,
                text=team_name,
                font=("Arial", 14, "bold"),
                text_color=FTBTheme.TEXT
            ).pack(padx=15, pady=(15, 5), anchor="w")
            
            # Role
            ctk.CTkLabel(
                card,
                text=f"Role: {listing.role}",
                font=("Arial", 12),
                text_color=FTBTheme.TEXT
            ).pack(padx=15, pady=2, anchor="w")
            
            # Expectations
            ctk.CTkLabel(
                card,
                text=f"Expectations: {listing.expectation_band}",
                font=("Arial", 11),
                text_color=FTBTheme.TEXT_MUTED
            ).pack(padx=15, pady=2, anchor="w")
            
            # Patience
            patience_color = FTBTheme.SUCCESS if listing.patience_profile > 0.6 else FTBTheme.WARNING if listing.patience_profile > 0.3 else FTBTheme.DANGER
            ctk.CTkLabel(
                card,
                text=f"Patience: {listing.patience_profile:.0%}",
                font=("Arial", 11),
                text_color=patience_color
            ).pack(padx=15, pady=2, anchor="w")
            
            # Actions
            actions_frame = ctk.CTkFrame(card, fg_color="transparent")
            actions_frame.pack(fill=tk.X, padx=15, pady=(10, 15))
            
            ctk.CTkButton(
                actions_frame,
                text="📝 Apply",
                command=lambda l=listing: self._apply_for_job(l),
                fg_color=FTBTheme.ACCENT,
                hover_color=FTBTheme.CARD_HOVER,
                height=35,
                width=120,
                font=("Arial", 11, "bold")
            ).pack(side=tk.LEFT)
            
            ctk.CTkButton(
                actions_frame,
                text="ℹ️ Details",
                command=lambda l=listing: self._show_job_details(l),
                fg_color=FTBTheme.SURFACE,
                hover_color=FTBTheme.CARD,
                height=35,
                width=100,
                font=("Arial", 11)
            ).pack(side=tk.LEFT, padx=(10, 0))
        
        def _show_entity_stats(self, entity):
            """Show detailed entity stats modal"""
            # Create modal window
            modal = ctk.CTkToplevel(self)
            modal.title(f"{entity.name} - Stats")
            modal.geometry("600x700")
            modal.configure(fg_color=FTBTheme.BG)
            modal.transient(self)
            modal.grab_set()
            
            # Center window
            modal.update_idletasks()
            x = (modal.winfo_screenwidth() // 2) - (600 // 2)
            y = (modal.winfo_screenheight() // 2) - (700 // 2)
            modal.geometry(f"600x700+{x}+{y}")
            
            # Header
            header = ctk.CTkFrame(modal, fg_color=FTBTheme.PANEL, corner_radius=0)
            header.pack(fill=tk.X)
            
            # Add sprite if entity has entity_id
            if hasattr(entity, 'entity_id'):
                try:
                    sprite_pil = generate_entity_sprite(entity.entity_id, size=64)
                    ctk_sprite = ctk.CTkImage(light_image=sprite_pil, dark_image=sprite_pil, size=(64, 64))
                    sprite_label = ctk.CTkLabel(
                        header,
                        image=ctk_sprite,
                        text=""
                    )
                    sprite_label.pack(pady=(20, 10))
                except Exception as e:
                    _dbg(f"[FTB] Error displaying sprite in profile: {e}")
            
            ctk.CTkLabel(
                header,
                text=entity.name,
                font=("Arial", 18, "bold"),
                text_color=FTBTheme.TEXT
            ).pack(padx=20, pady=(10, 5))
            
            entity_type = type(entity).__name__
            ctk.CTkLabel(
                header,
                text=f"{entity_type} • Age {entity.age if hasattr(entity, 'age') else 'N/A'}",
                font=("Arial", 12),
                text_color=FTBTheme.TEXT_MUTED
            ).pack(padx=20, pady=(0, 20))
            
            # Overall rating
            if hasattr(entity, 'overall_rating'):
                rating_frame = ctk.CTkFrame(modal, fg_color=FTBTheme.CARD, corner_radius=8)
                rating_frame.pack(fill=tk.X, padx=20, pady=(20, 10))
                
                rating = entity.overall_rating
                rating_color = FTBTheme.get_stat_color(rating)
                
                ctk.CTkLabel(
                    rating_frame,
                    text="Overall Rating",
                    font=("Arial", 11),
                    text_color=FTBTheme.TEXT_MUTED
                ).pack(padx=15, pady=(15, 5))
                
                ctk.CTkLabel(
                    rating_frame,
                    text=f"{rating:.0f}/100",
                    font=("Arial", 32, "bold"),
                    text_color=rating_color
                ).pack(padx=15, pady=(0, 15))
            
            # Stats scrollable area
            stats_frame = ctk.CTkScrollableFrame(modal, fg_color=FTBTheme.PANEL, corner_radius=8)
            stats_frame.pack(fill=tk.BOTH, expand=True, padx=20, pady=(0, 20))
            
            # Show all stats
            if hasattr(entity, 'current_ratings'):
                for stat_name, value in sorted(entity.current_ratings.items()):
                    stat_bar = StatBar(
                        stats_frame,
                        label=stat_name.replace('_', ' ').title(),
                        value=value,
                        max_value=100.0,
                        show_value=True
                    )
                    stat_bar.pack(fill=tk.X, padx=10, pady=3)
            
            # Close button
            ctk.CTkButton(
                modal,
                text="Close",
                command=modal.destroy,
                fg_color=FTBTheme.SURFACE,
                hover_color=FTBTheme.CARD,
                height=40,
                width=150,
                font=("Arial", 12)
            ).pack(pady=(0, 20))
        
        def _show_contract_details(self, entity, free_agent=None):
            """Show contract negotiation modal"""
            if not self.sim_state or not self.sim_state.player_team:
                return
            
            # Get existing contract (if extending)
            existing_contract = self.sim_state.contracts.get(entity.entity_id)
            role_label = existing_contract.role if existing_contract else (free_agent.entity_type if free_agent else type(entity).__name__)
            
            # Create modal window
            modal = ctk.CTkToplevel(self)
            modal.title(f"Contract Negotiation: {entity.name}")
            modal.geometry("700x900")
            modal.configure(fg_color=FTBTheme.BG)
            modal.transient(self)
            modal.grab_set()
            
            # Will be populated with trace IDs for cleanup
            trace_ids_to_cleanup = []
            
            def cleanup_modal():
                """Clean up trace callbacks before destroying modal"""
                try:
                    # Remove any stored trace callbacks
                    for var, mode, trace_id in trace_ids_to_cleanup:
                        try:
                            var.trace_remove(mode, trace_id)
                        except:
                            pass
                except:
                    pass
                try:
                    if modal.winfo_exists():
                        modal.destroy()
                except (tk.TclError, RuntimeError):
                    pass
            
            modal.protocol("WM_DELETE_WINDOW", cleanup_modal)
            
            # Scrollable content
            scroll = ctk.CTkScrollableFrame(modal, fg_color="transparent")
            scroll.pack(fill=tk.BOTH, expand=True, padx=20, pady=20)
            
            # Header
            header = ctk.CTkFrame(scroll, fg_color=FTBTheme.CARD, corner_radius=8)
            header.pack(fill=tk.X, pady=(0, 15))
            
            ctk.CTkLabel(
                header,
                text=f"Negotiate Contract: {entity.name}",
                font=("Arial", 18, "bold"),
                text_color=FTBTheme.TEXT
            ).pack(padx=20, pady=(15, 5))
            
            ctk.CTkLabel(
                header,
                text=f"Role: {role_label}",
                font=("Arial", 12),
                text_color=FTBTheme.TEXT_DIM
            ).pack(padx=20, pady=(0, 15))
            
            # Current contract info (if extending)
            if existing_contract:
                current_card = ctk.CTkFrame(scroll, fg_color=FTBTheme.CARD, corner_radius=8)
                current_card.pack(fill=tk.X, pady=(0, 15))
                
                ctk.CTkLabel(
                    current_card,
                    text="Current Contract",
                    font=("Arial", 14, "bold"),
                    text_color=FTBTheme.TEXT
                ).pack(padx=20, pady=(15, 10), anchor="w")
                
                current_info = ctk.CTkFrame(current_card, fg_color="transparent")
                current_info.pack(fill=tk.X, padx=20, pady=(0, 15))
                
                info_items = [
                    ("Seasons Remaining:", f"{existing_contract.seasons_remaining(self.sim_state.sim_day_of_year):.1f}"),
                    ("Days Remaining:", f"{existing_contract.days_remaining(self.sim_state.sim_day_of_year)}"),
                    ("Base Salary:", format_currency(existing_contract.base_salary)),
                    ("Total Value:", format_currency(existing_contract.total_value())),
                ]
                
                for label, value in info_items:
                    row = ctk.CTkFrame(current_info, fg_color="transparent")
                    row.pack(fill=tk.X, pady=3)
                    
                    ctk.CTkLabel(
                        row,
                        text=label,
                        font=("Arial", 11, "bold"),
                        text_color=FTBTheme.TEXT_DIM
                    ).pack(side=tk.LEFT)
                    
                    ctk.CTkLabel(
                        row,
                        text=value,
                        font=("Arial", 11),
                        text_color=FTBTheme.TEXT
                    ).pack(side=tk.RIGHT)
            
            # Negotiation form
            form_card = ctk.CTkFrame(scroll, fg_color=FTBTheme.CARD, corner_radius=8)
            form_card.pack(fill=tk.X, pady=(0, 15))
            
            ctk.CTkLabel(
                form_card,
                text="New Contract Terms",
                font=("Arial", 14, "bold"),
                text_color=FTBTheme.TEXT
            ).pack(padx=20, pady=(15, 10), anchor="w")
            
            form_container = ctk.CTkFrame(form_card, fg_color="transparent")
            form_container.pack(fill=tk.X, padx=20, pady=(0, 15))
            
            # Contract duration (seasons)
            duration_frame = ctk.CTkFrame(form_container, fg_color="transparent")
            duration_frame.pack(fill=tk.X, pady=10)
            
            ctk.CTkLabel(
                duration_frame,
                text="Contract Duration (Seasons):",
                font=("Arial", 12, "bold"),
                text_color=FTBTheme.TEXT
            ).pack(anchor="w", pady=(0, 5))
            
            duration_var = tk.IntVar(value=existing_contract.seasons_duration if existing_contract else 2)
            duration_slider = ctk.CTkSlider(
                duration_frame,
                from_=1,
                to=5,
                number_of_steps=4,
                variable=duration_var,
                width=400
            )
            duration_slider.pack(fill=tk.X, pady=5)
            
            duration_label = ctk.CTkLabel(
                duration_frame,
                text=f"{duration_var.get()} season{'s' if duration_var.get() > 1 else ''} (~{Contract.seasons_to_days(duration_var.get())} days)",
                font=("Arial", 11),
                text_color=FTBTheme.TEXT_DIM
            )
            duration_label.pack(anchor="w")
            
            def update_duration_label(*args):
                try:
                    if not modal.winfo_exists():
                        return
                    seasons = duration_var.get()
                    duration_label.configure(text=f"{seasons} season{'s' if seasons > 1 else ''} (~{Contract.seasons_to_days(seasons)} days)")
                    update_total_value()
                except (tk.TclError, RuntimeError):
                    pass  # Widget destroyed
            
            trace_id = duration_var.trace_add("write", update_duration_label)
            trace_ids_to_cleanup.append((duration_var, 'write', trace_id))
            
            # Base salary per season
            salary_frame = ctk.CTkFrame(form_container, fg_color="transparent")
            salary_frame.pack(fill=tk.X, pady=10)
            
            ctk.CTkLabel(
                salary_frame,
                text="Base Salary (per year):",
                font=("Arial", 12, "bold"),
                text_color=FTBTheme.TEXT
            ).pack(anchor="w", pady=(0, 5))
            
            # Convert asking_salary (annual) to annual for display, or use existing contract annual rate
            default_salary_annual = existing_contract.base_salary * 365 if existing_contract else (free_agent.asking_salary if free_agent else 100000)
            salary_var = tk.IntVar(value=int(default_salary_annual))
            salary_entry = ctk.CTkEntry(
                salary_frame,
                textvariable=salary_var,
                width=200,
                font=("Arial", 12)
            )
            salary_entry.pack(anchor="w", pady=5)
            
            def safe_update_total_value(event=None):
                try:
                    if modal.winfo_exists():
                        update_total_value()
                except (tk.TclError, RuntimeError):
                    pass
            
            salary_entry.bind("<KeyRelease>", safe_update_total_value)
            
            # Signing bonus
            bonus_frame = ctk.CTkFrame(form_container, fg_color="transparent")
            bonus_frame.pack(fill=tk.X, pady=10)
            
            ctk.CTkLabel(
                bonus_frame,
                text="Signing Bonus (one-time):",
                font=("Arial", 12, "bold"),
                text_color=FTBTheme.TEXT
            ).pack(anchor="w", pady=(0, 5))
            
            signing_bonus_var = tk.IntVar(value=int(existing_contract.signing_bonus * 365) if existing_contract else 0)
            bonus_entry = ctk.CTkEntry(
                bonus_frame,
                textvariable=signing_bonus_var,
                width=200,
                font=("Arial", 12)
            )
            bonus_entry.pack(anchor="w", pady=5)
            
            bonus_entry.bind("<KeyRelease>", safe_update_total_value)
            
            # Total value display
            total_value_label = ctk.CTkLabel(
                form_container,
                text="",
                font=("Arial", 14, "bold"),
                text_color=FTBTheme.ACCENT
            )
            total_value_label.pack(anchor="w", pady=15)
            
            def update_total_value():
                try:
                    if not modal.winfo_exists():
                        return
                    seasons = duration_var.get()
                    salary = salary_var.get()
                    bonus = signing_bonus_var.get()
                    total = (salary * seasons) + bonus
                    total_value_label.configure(text=f"Total Contract Value: {format_currency(total)}")
                except (tk.TclError, RuntimeError, ValueError):
                    try:
                        if modal.winfo_exists():
                            total_value_label.configure(text="Total Contract Value: ---")
                    except:
                        pass  # Widget destroyed
            
            update_total_value()
            
            # Performance clauses (optional)
            clauses_card = ctk.CTkFrame(scroll, fg_color=FTBTheme.CARD, corner_radius=8)
            clauses_card.pack(fill=tk.X, pady=(0, 15))
            
            ctk.CTkLabel(
                clauses_card,
                text="Performance Clauses (Optional)",
                font=("Arial", 14, "bold"),
                text_color=FTBTheme.TEXT
            ).pack(padx=20, pady=(15, 10), anchor="w")
            
            clauses_container = ctk.CTkFrame(clauses_card, fg_color="transparent")
            clauses_container.pack(fill=tk.X, padx=20, pady=(0, 15))
            
            # Points bonus
            points_bonus_enabled = tk.BooleanVar(value=False)
            points_bonus_value = tk.IntVar(value=50000)
            
            points_frame = ctk.CTkFrame(clauses_container, fg_color="transparent")
            points_frame.pack(fill=tk.X, pady=5)
            
            ctk.CTkCheckBox(
                points_frame,
                text="Points Bonus:",
                variable=points_bonus_enabled,
                font=("Arial", 11),
                text_color=FTBTheme.TEXT
            ).pack(side=tk.LEFT, padx=(0, 10))
            
            ctk.CTkEntry(
                points_frame,
                textvariable=points_bonus_value,
                width=120,
                font=("Arial", 11)
            ).pack(side=tk.LEFT)
            
            # Wins bonus
            wins_bonus_enabled = tk.BooleanVar(value=False)
            wins_bonus_value = tk.IntVar(value=100000)
            
            wins_frame = ctk.CTkFrame(clauses_container, fg_color="transparent")
            wins_frame.pack(fill=tk.X, pady=5)
            
            ctk.CTkCheckBox(
                wins_frame,
                text="Win Bonus:",
                variable=wins_bonus_enabled,
                font=("Arial", 11),
                text_color=FTBTheme.TEXT
            ).pack(side=tk.LEFT, padx=(0, 10))
            
            ctk.CTkEntry(
                wins_frame,
                textvariable=wins_bonus_value,
                width=120,
                font=("Arial", 11)
            ).pack(side=tk.LEFT)
            
            # Exit clauses
            exit_card = ctk.CTkFrame(scroll, fg_color=FTBTheme.CARD, corner_radius=8)
            exit_card.pack(fill=tk.X, pady=(0, 15))
            
            ctk.CTkLabel(
                exit_card,
                text="Exit Clauses (Optional)",
                font=("Arial", 14, "bold"),
                text_color=FTBTheme.TEXT
            ).pack(padx=20, pady=(15, 10), anchor="w")
            
            exit_container = ctk.CTkFrame(exit_card, fg_color="transparent")
            exit_container.pack(fill=tk.X, padx=20, pady=(0, 15))
            
            # Buyout cost
            buyout_enabled = tk.BooleanVar(value=False)
            buyout_value = tk.IntVar(value=200000)
            
            buyout_frame = ctk.CTkFrame(exit_container, fg_color="transparent")
            buyout_frame.pack(fill=tk.X, pady=5)
            
            ctk.CTkCheckBox(
                buyout_frame,
                text="Buyout Cost:",
                variable=buyout_enabled,
                font=("Arial", 11),
                text_color=FTBTheme.TEXT
            ).pack(side=tk.LEFT, padx=(0, 10))
            
            ctk.CTkEntry(
                buyout_frame,
                textvariable=buyout_value,
                width=120,
                font=("Arial", 11)
            ).pack(side=tk.LEFT)
            
            # Performance escape clause
            perf_escape_var = tk.BooleanVar(value=False)
            ctk.CTkCheckBox(
                exit_container,
                text="Performance Escape Clause (can leave if team underperforms)",
                variable=perf_escape_var,
                font=("Arial", 11),
                text_color=FTBTheme.TEXT
            ).pack(anchor="w", pady=5)
            
            # Response message area (for AI counter-offers)
            response_frame = ctk.CTkFrame(scroll, fg_color=FTBTheme.CARD, corner_radius=8)
            response_frame.pack(fill=tk.X, pady=(0, 15))
            response_frame.pack_forget()  # Hide initially
            
            response_label = ctk.CTkLabel(
                response_frame,
                text="",
                font=("Arial", 12),
                text_color=FTBTheme.TEXT,
                wraplength=600,
                justify="left"
            )
            response_label.pack(padx=20, pady=15)
            
            # Buttons
            button_frame = ctk.CTkFrame(scroll, fg_color="transparent")
            button_frame.pack(fill=tk.X, pady=(15, 0))
            
            def make_offer():
                """Send offer to simulation for evaluation"""
                try:
                    performance_clauses = {}
                    if points_bonus_enabled.get():
                        performance_clauses['points_bonus'] = points_bonus_value.get()
                    if wins_bonus_enabled.get():
                        performance_clauses['wins_bonus'] = wins_bonus_value.get()
                    
                    exit_clauses = {}
                    if buyout_enabled.get():
                        exit_clauses['buyout_cost'] = buyout_value.get()
                    if perf_escape_var.get():
                        exit_clauses['performance_escape'] = True
                    
                    controller = self.runtime.get("ftb_controller")
                    if not controller or not controller.state:
                        messagebox.showerror("Contract Error", "Contract system is unavailable.", parent=modal)
                        return

                    offer_data = {
                        'entity_id': entity.entity_id,
                        'seasons_duration': duration_var.get(),
                        'base_salary': salary_var.get() / 365,  # Convert annual to per-tick
                        'signing_bonus': signing_bonus_var.get() / 365,  # Convert annual to per-tick
                        'performance_clauses': performance_clauses,
                        'exit_clauses': exit_clauses,
                        'role': role_label
                    }

                    with controller.state_lock:
                        rng = controller.state.get_rng("contracts", entity.entity_id)
                        result = controller.state.evaluate_contract_offer(entity.entity_id, offer_data, rng)

                    response_frame.pack(fill=tk.X, pady=(0, 15))

                    if result.get('accepted'):
                        response_label.configure(text=result.get('message', "Offer accepted."), text_color=FTBTheme.SUCCESS)
                        contract_data = {
                            **offer_data,
                            'team_name': self.sim_state.player_team.name
                        }
                        self.runtime["ftb_cmd_q"].put({
                            "cmd": "ftb_finalize_contract",
                            "contract_data": contract_data
                        })
                        # Safe delayed destruction with refresh
                        def safe_destroy():
                            try:
                                if modal.winfo_exists():
                                    modal.destroy()
                            except (tk.TclError, RuntimeError):
                                pass
                        
                        def refresh_and_close():
                            controller = self.runtime.get("ftb_controller")
                            if controller and controller.state:
                                try:
                                    controller._refresh_widget()
                                except:
                                    pass
                            safe_destroy()
                        modal.after(800, refresh_and_close)
                        return

                    counter_offer = result.get('counter_offer')
                    if counter_offer:
                        duration_var.set(counter_offer.get('seasons_duration', duration_var.get()))
                        # Convert counter-offer per-tick values back to annual for display
                        salary_var.set(int(counter_offer.get('base_salary', salary_var.get() / 365) * 365))
                        signing_bonus_var.set(int(counter_offer.get('signing_bonus', signing_bonus_var.get() / 365) * 365))
                        update_total_value()
                        response_label.configure(text=result.get('message', "Counter-offer received."), text_color=FTBTheme.WARNING)
                    else:
                        response_label.configure(text=result.get('message', "Offer rejected."), text_color=FTBTheme.DANGER)
                    
                except ValueError:
                    messagebox.showerror("Invalid Input", "Please enter valid numbers for salary and bonuses.", parent=modal)
            
            ctk.CTkButton(
                button_frame,
                text="Make Offer",
                command=make_offer,
                fg_color=FTBTheme.SUCCESS,
                hover_color=FTBTheme.SUCCESS_HOVER,
                width=150,
                height=40,
                font=("Arial", 13, "bold")
            ).pack(side=tk.LEFT, padx=5)
            
            ctk.CTkButton(
                button_frame,
                text="Cancel",
                command=cleanup_modal,
                fg_color=FTBTheme.DANGER,
                hover_color=FTBTheme.DANGER_HOVER,
                width=150,
                height=40,
                font=("Arial", 13, "bold")
            ).pack(side=tk.RIGHT, padx=5)
        
        def _attempt_driver_poach(self, driver, original_team, contract, buyout_amount):
            """Attempt to poach a driver from another team via buyout
            
            Process:
            1. Validate roster space and financial capacity
            2. Confirm transaction with player
            3. Execute buyout payment to original team
            4. Terminate old contract
            5. Negotiate new contract with driver
            6. Add driver to player team
            7. Generate events and update UI
            """
            from tkinter import messagebox
            
            player_team = self.sim_state.player_team
            current_day = self.sim_state.sim_day_of_year
            
            # Step 1: Validation checks
            errors = []
            
            # Check roster space
            tier_features = TIER_FEATURES.get(player_team.tier, {})
            max_drivers = tier_features.get('max_drivers', 2)
            current_drivers = len([d for d in player_team.drivers if d])
            
            if current_drivers >= max_drivers:
                errors.append(f"❌ Roster full ({current_drivers}/{max_drivers} drivers)")
            
            # Check financial capacity
            # Cost = buyout + estimated first contract payment
            estimated_new_salary = contract.base_salary * 1.2  # Assume 20% raise for switching
            signing_bonus = int(estimated_new_salary * 0.3)  # 30% signing bonus
            first_payment = signing_bonus + (estimated_new_salary / 26)  # First 2-week salary
            total_cost = buyout_amount + first_payment
            
            if player_team.budget.cash < total_cost:
                errors.append(f"❌ Insufficient funds (need ${total_cost:,}, have ${player_team.budget.cash:,})")
            
            # Check if budget would fall below safety threshold
            remaining = player_team.budget.cash - total_cost
            safety_threshold = getattr(player_team.budget, 'bankruptcy_threshold', 50000) * 2
            
            if remaining < safety_threshold:
                errors.append(f"⚠️ Would leave budget below safety threshold")
            
            # Display errors if any
            if errors:
                messagebox.showerror(
                    "Cannot Complete Buyout",
                    "\n\n".join(["Transaction blocked:"] + errors),
                    parent=self
                )
                return
            
            # Step 2: Confirmation dialog
            confirm_msg = f"""Trigger buyout clause for {driver.name}?

Current Team: {original_team.name}
Overall Rating: {driver.overall_rating:.0f}
Age: {driver.age}
Current Morale: {getattr(driver, 'morale', 50.0):.0f}

COSTS:
• Buyout Payment: ${buyout_amount:,} (paid to {original_team.name})
• Est. Signing Bonus: ${signing_bonus:,}
• Total Upfront: ${total_cost:,}

After buyout, you'll need to negotiate a new contract.
Budget after transaction: ${remaining:,}

Proceed with buyout?"""
            
            if not messagebox.askyesno("Confirm Driver Buyout", confirm_msg, parent=self):
                return
            
            # Step 3-7: Execute transaction via command queue
            self.runtime["ftb_cmd_q"].put({
                "cmd": "ftb_poach_driver",
                "driver_entity_id": driver.entity_id,
                "original_team_name": original_team.name,
                "buyout_amount": buyout_amount
            })
            
            # Show success message
            estimated_new_salary = int(contract.base_salary * 1.25)
            estimated_bonus = int(estimated_new_salary * 0.3)
            
            messagebox.showinfo(
                "Buyout Successful!",
                f"✅ {driver.name} has been poached from {original_team.name}!\n\n" +
                f"TRANSACTION SUMMARY:\n" +
                f"• Buyout paid: ${buyout_amount:,}\n" +
                f"• Contract created: ${estimated_new_salary:,}/year (2 seasons)\n" +
                f"• Signing bonus: ${estimated_bonus:,}\n" +
                f"• 30-day poaching protection applied\n\n" +
                f"{driver.name} is now on your roster!",
                parent=self
            )
            
            # Refresh UI
            self._refresh_job_market()
            self._refresh_roster()
        
        def _fire_entity(self, entity):
            """Fire an entity with comprehensive wizard"""
            def on_confirm(entity):
                # Send command to controller with confirmation flag
                self.runtime["ftb_cmd_q"].put({
                    "cmd": "ftb_fire_entity",
                    "entity_name": entity.name,
                    "confirmed": True
                })
                # Don't refresh immediately - let command handler trigger update
                # self._refresh_roster()  # Removed to prevent widget access after destroy
            
            # Launch FireEntityWizard with full cost disclosure
            try:
                FireEntityWizard(
                    self,
                    entity=entity,
                    team=self.sim_state.player_team,
                    state=self.sim_state,
                    on_confirm=on_confirm
                )
            except Exception as e:
                _dbg(f"[FTB] ERROR launching FireEntityWizard: {e}")
                import traceback
                traceback.print_exc()
                messagebox.showerror("Error", f"Failed to open wizard: {e}", parent=self)
        
        def _display_poachable_driver_card(self, parent, item):
            """Display a driver available for poaching with buyout option"""
            driver = item['entity']
            team = item['team']
            contract = item['contract']
            buyout = item['buyout']
            morale = item['morale']
            
            card = ctk.CTkFrame(parent, fg_color=FTBTheme.CARD, corner_radius=8)
            card.pack(fill=tk.X, padx=10, pady=(0, 10))
            
            # Top row: Name, rating, current team
            header = ctk.CTkFrame(card, fg_color="transparent")
            header.pack(fill=tk.X, padx=15, pady=(15, 8))
            
            ctk.CTkLabel(
                header,
                text=f"{driver.name}",
                font=("Arial", 13, "bold"),
                text_color=FTBTheme.TEXT
            ).pack(side=tk.LEFT)
            
            ctk.CTkLabel(
                header,
                text=f"OVR {driver.overall_rating:.0f}",
                font=("Arial", 12, "bold"),
                text_color=FTBTheme.ACCENT
            ).pack(side=tk.LEFT, padx=(12, 0))
            
            ctk.CTkLabel(
                header,
                text=f"@ {team.name}",
                font=("Arial", 11),
                text_color=FTBTheme.TEXT_MUTED
            ).pack(side=tk.LEFT, padx=(12, 0))
            
            # Age and nationality
            ctk.CTkLabel(
                header,
                text=f"{driver.age}y",
                font=("Arial", 10),
                text_color=FTBTheme.TEXT_MUTED
            ).pack(side=tk.RIGHT, padx=(0, 5))
            
            if hasattr(driver, 'nationality') and driver.nationality:
                ctk.CTkLabel(
                    header,
                    text=driver.nationality,
                    font=("Arial", 10),
                    text_color=FTBTheme.TEXT_MUTED
                ).pack(side=tk.RIGHT, padx=(0, 8))
            
            # Stats row
            stats_frame = ctk.CTkFrame(card, fg_color=FTBTheme.SURFACE, corner_radius=6)
            stats_frame.pack(fill=tk.X, padx=15, pady=(0, 8))
            
            stats_grid = ctk.CTkFrame(stats_frame, fg_color="transparent")
            stats_grid.pack(fill=tk.X, padx=10, pady=8)
            
            stat_labels = [
                ("Speed", driver.speed),
                ("Racecraft", driver.racecraft),
                ("Consistency", driver.consistency),
                ("Wet", driver.wet_skill)
            ]
            
            for i, (label, value) in enumerate(stat_labels):
                stat_col = ctk.CTkFrame(stats_grid, fg_color="transparent")
                stat_col.pack(side=tk.LEFT, expand=True)
                
                ctk.CTkLabel(
                    stat_col,
                    text=label,
                    font=("Arial", 9),
                    text_color=FTBTheme.TEXT_MUTED
                ).pack()
                
                ctk.CTkLabel(
                    stat_col,
                    text=f"{value:.0f}",
                    font=("Arial", 11, "bold"),
                    text_color=FTBTheme.TEXT
                ).pack()
            
            # Contract details row
            contract_frame = ctk.CTkFrame(card, fg_color="transparent")
            contract_frame.pack(fill=tk.X, padx=15, pady=(0, 8))
            
            days_remaining = contract.days_remaining(self.sim_state.sim_day_of_year)
            
            ctk.CTkLabel(
                contract_frame,
                text=f"📄 Contract: {days_remaining} days remaining | ${contract.base_salary:,}/year",
                font=("Arial", 10),
                text_color=FTBTheme.TEXT
            ).pack(side=tk.LEFT)
            
            # Morale indicator
            if morale < 35:
                morale_emoji = "😠"
                morale_color = FTBTheme.ERROR
            elif morale < 45:
                morale_emoji = "😟"
                morale_color = FTBTheme.WARNING
            elif morale < 55:
                morale_emoji = "😐"
                morale_color = FTBTheme.TEXT
            else:
                morale_emoji = "🙂"
                morale_color = FTBTheme.SUCCESS
            
            ctk.CTkLabel(
                contract_frame,
                text=f"{morale_emoji} Morale: {morale:.0f}",
                font=("Arial", 10),
                text_color=morale_color
            ).pack(side=tk.LEFT, padx=(15, 0))
            
            # Bottom row: Buyout cost and action button
            actions = ctk.CTkFrame(card, fg_color="transparent")
            actions.pack(fill=tk.X, padx=15, pady=(0, 15))
            
            ctk.CTkLabel(
                actions,
                text=f"💰 Buyout: ${buyout:,}",
                font=("Arial", 12, "bold"),
                text_color=FTBTheme.WARNING
            ).pack(side=tk.LEFT)
            
            # Check if player can afford
            can_afford = self.sim_state.player_team.budget.cash >= buyout
            
            trigger_btn = ctk.CTkButton(
                actions,
                text="Trigger Buyout" if can_afford else "Cannot Afford",
                width=130,
                height=32,
                fg_color=FTBTheme.ACCENT if can_afford else FTBTheme.SURFACE,
                hover_color=FTBTheme.ACCENT_HOVER if can_afford else FTBTheme.SURFACE,
                text_color=FTBTheme.TEXT if can_afford else FTBTheme.TEXT_MUTED,
                state="normal" if can_afford else "disabled",
                command=lambda: self._attempt_driver_poach(driver, team, contract, buyout),
                font=("Arial", 11, "bold" if can_afford else "normal")
            )
            trigger_btn.pack(side=tk.RIGHT)
        
        def _add_free_agent_card(self, parent, free_agent):
            """Add a free agent card"""
            card = ctk.CTkFrame(parent, fg_color=FTBTheme.CARD, corner_radius=8)
            card.pack(fill=tk.X, pady=(0, 10), padx=10)
            
            entity = free_agent.entity
            
            # Entity info
            info_frame = ctk.CTkFrame(card, fg_color="transparent")
            info_frame.pack(fill=tk.X, padx=15, pady=(15, 5))
            
            # Name and age
            ctk.CTkLabel(
                info_frame,
                text=entity.name,
                font=("Arial", 14, "bold"),
                text_color=FTBTheme.TEXT
            ).pack(side=tk.LEFT)
            
            ctk.CTkLabel(
                info_frame,
                text=f"Age {entity.age}",
                font=("Arial", 11),
                text_color=FTBTheme.TEXT_MUTED
            ).pack(side=tk.LEFT, padx=(10, 0))
            
            # Overall rating
            rating_color = FTBTheme.SUCCESS if free_agent.overall_rating >= 75 else FTBTheme.WARNING if free_agent.overall_rating >= 60 else FTBTheme.TEXT
            ctk.CTkLabel(
                card,
                text=f"Overall Rating: {free_agent.overall_rating:.0f}",
                font=("Arial", 12, "bold"),
                text_color=rating_color
            ).pack(padx=15, pady=2, anchor="w")
            
            # Time in free agency
            days_text = f"{free_agent.time_in_pool_days} day{'s' if free_agent.time_in_pool_days != 1 else ''}"
            ctk.CTkLabel(
                card,
                text=f"Time in Free Agency: {days_text}",
                font=("Arial", 11),
                text_color=FTBTheme.TEXT_MUTED
            ).pack(padx=15, pady=2, anchor="w")
            
            # Asking salary
            ctk.CTkLabel(
                card,
                text=f"Asking Salary: {format_currency(free_agent.asking_salary)}/year",
                font=("Arial", 11),
                text_color=FTBTheme.TEXT
            ).pack(padx=15, pady=2, anchor="w")
            
            # Actions
            actions_frame = ctk.CTkFrame(card, fg_color="transparent")
            actions_frame.pack(fill=tk.X, padx=15, pady=(10, 15))
            
            ctk.CTkButton(
                actions_frame,
                text="💼 Negotiate",
                command=lambda fa=free_agent: self._hire_from_free_agent(fa),
                fg_color=FTBTheme.SUCCESS,
                hover_color=FTBTheme.SUCCESS_HOVER,
                height=35,
                width=120,
                font=("Arial", 11, "bold")
            ).pack(side=tk.LEFT)
            
            ctk.CTkButton(
                actions_frame,
                text="ℹ️ Details",
                command=lambda e=entity: self._show_entity_stats(e),
                fg_color=FTBTheme.SURFACE,
                hover_color=FTBTheme.CARD,
                height=35,
                width=100,
                font=("Arial", 11)
            ).pack(side=tk.LEFT, padx=(10, 0))
        
        def _hire_from_free_agent(self, free_agent):
            """Hire an entity from free agency"""
            if not self.sim_state or not self.sim_state.player_team:
                messagebox.showwarning("No Team", "You need to have a team first!", parent=self)
                return
            
            # Check if player can afford
            team = self.sim_state.player_team
            asking_salary = free_agent.asking_salary
            
            if team.budget.cash < asking_salary:
                messagebox.showerror(
                    "Insufficient Funds",
                    f"Cannot afford {free_agent.entity.name}.\n\nAsking salary: {format_currency(asking_salary)}\nAvailable cash: {format_currency(team.budget.cash)}",
                    parent=self
                )
                return
            
            # Show contract negotiation modal
            self._show_contract_details(free_agent.entity, free_agent=free_agent)
        
        def _apply_for_job(self, listing):
            """Apply for a job"""
            if not self.sim_state or not self.sim_state.player_team:
                messagebox.showwarning("No Team", "You need to have a team first!", parent=self)
                return
            
            # Calculate acceptance probability
            player_metrics = self.sim_state.player_team.standing_metrics
            legitimacy = player_metrics.get('legitimacy', 50.0)
            reputation = player_metrics.get('reputation', 50.0)
            acceptance_chance = self.sim_state.job_board.get_acceptance_chance(player_metrics, listing)
            
            # Show confirmation with probability
            team_name = listing.team.name if listing.team else listing.team_name
            msg = f"Apply for {listing.role} at {team_name}?\n\n"
            msg += f"Estimated acceptance chance: {acceptance_chance:.0%}\n\n"
            msg += f"Your legitimacy: {legitimacy:.0f}\n"
            msg += f"Your reputation: {reputation:.0f}"
            
            if messagebox.askyesno("Apply for Position", msg, parent=self):
                # Send command
                self.runtime["ftb_cmd_q"].put({
                    "cmd": "ftb_apply_job",
                    "listing_id": id(listing)  # Use object id as unique identifier
                })
        
        def _show_job_details(self, listing):
            """Show detailed job information"""
            team_name = listing.team.name if listing.team else listing.team_name
            team_budget = format_currency(listing.team.budget.cash) if listing.team else "Unknown"
            details = f"""Position: {listing.role}
Team: {team_name}

Expectations: {listing.expectation_band}
Patience: {listing.patience_profile:.0%}
Risk Tolerance: {listing.risk_profile:.0%}

Team Budget: {team_budget}

Requirements:
- Legitimacy: 30+ (minimum)
- Reputation: Varies by expectations
"""
            messagebox.showinfo("Position Details", details, parent=self)
        
        def _refresh_team_browser(self):
            """Update team browser display with all teams organized by tier"""
            if not self.sim_state:
                return
            
            # Clear existing
            for widget in self.team_browser_container.winfo_children():
                widget.destroy()
            
            # Group teams by tier
            teams_by_tier = {}
            tier_order = ['grassroots', 'formula_v', 'formula_x', 'formula_y', 'formula_z']
            tier_names_display = {
                'grassroots': 'Grassroots',
                'formula_v': 'Formula V',
                'formula_x': 'Formula X',
                'formula_y': 'Formula Y',
                'formula_z': 'Formula Z'
            }
            
            # Collect all teams (player + AI)
            all_teams = []
            if self.sim_state.player_team:
                all_teams.append(self.sim_state.player_team)
            all_teams.extend(self.sim_state.ai_teams)
            
            # Organize by tier
            for team in all_teams:
                tier_name = team.tier_name if hasattr(team, 'tier_name') else 'grassroots'
                if tier_name not in teams_by_tier:
                    teams_by_tier[tier_name] = []
                teams_by_tier[tier_name].append(team)
            
            # Display each tier
            for tier_key in tier_order:
                if tier_key not in teams_by_tier:
                    continue
                
                teams = teams_by_tier[tier_key]
                tier_display = tier_names_display.get(tier_key, tier_key.replace('_', ' ').title())
                
                # Tier section
                tier_section = ctk.CTkFrame(self.team_browser_container, fg_color=FTBTheme.CARD, corner_radius=8)
                tier_section.pack(fill=tk.X, pady=(0, 10))
                
                # Tier header (collapsible)
                tier_header = ctk.CTkFrame(tier_section, fg_color="transparent")
                tier_header.pack(fill=tk.X, padx=15, pady=10)
                
                ctk.CTkLabel(
                    tier_header,
                    text=f"🏆 {tier_display}",
                    font=("Arial", 13, "bold"),
                    text_color=FTBTheme.TEXT,
                    anchor="w"
                ).pack(side=tk.LEFT)
                
                ctk.CTkLabel(
                    tier_header,
                    text=f"({len(teams)} teams)",
                    font=("Arial", 11),
                    text_color=FTBTheme.TEXT_MUTED
                ).pack(side=tk.LEFT, padx=(5, 0))
                
                # Team list (showing first 5, with "show all" button)
                teams_to_show = sorted(teams, key=lambda t: t.name)[:5]
                
                for team in teams_to_show:
                    self._add_team_browser_card(tier_section, team)
                
                # Show all button if there are more teams
                if len(teams) > 5:
                    show_all_btn = ctk.CTkButton(
                        tier_section,
                        text=f"📋 Show All {len(teams)} Teams",
                        command=lambda t=teams, tn=tier_display: self._show_tier_teams(t, tn),
                        fg_color=FTBTheme.SURFACE,
                        hover_color=FTBTheme.BUTTON_SECONDARY_HOVER,
                        height=30,
                        font=("Arial", 10)
                    )
                    show_all_btn.pack(padx=15, pady=(5, 10))
        
        def _add_team_browser_card(self, parent, team):
            """Add a team card to the browser"""
            card = ctk.CTkFrame(parent, fg_color=FTBTheme.SURFACE, corner_radius=6)
            card.pack(fill=tk.X, padx=15, pady=3)
            
            info_frame = ctk.CTkFrame(card, fg_color="transparent")
            info_frame.pack(fill=tk.X, padx=10, pady=8)
            
            # Team name - safe check for state
            is_player = False
            if self.sim_state and hasattr(self.sim_state, 'player_team'):
                is_player = team == self.sim_state.player_team
            name_text = f"{team.name} {'(YOU)' if is_player else ''}"
            name_label = ctk.CTkLabel(
                info_frame,
                text=name_text,
                font=("Arial", 11, "bold" if is_player else "normal"),
                text_color=FTBTheme.ACCENT if is_player else FTBTheme.TEXT,
                anchor="w"
            )
            name_label.pack(side=tk.LEFT, fill=tk.X, expand=True)
            
            # Budget info
            budget_text = format_currency(team.budget.cash)
            ctk.CTkLabel(
                info_frame,
                text=budget_text,
                font=("Arial", 9),
                text_color=FTBTheme.TEXT_MUTED
            ).pack(side=tk.LEFT, padx=5)
            
            # View details button
            ctk.CTkButton(
                info_frame,
                text="👁️",
                command=lambda t=team: self._show_team_detail(t),
                fg_color=FTBTheme.ACCENT,
                hover_color=FTBTheme.ACCENT_HOVER,
                width=30,
                height=24,
                font=("Arial", 10)
            ).pack(side=tk.RIGHT)

            ctk.CTkButton(
                info_frame,
                text="🏎️",
                command=lambda t=team: self._show_team_lineup(t),
                fg_color=FTBTheme.SURFACE,
                hover_color=FTBTheme.BUTTON_SECONDARY_HOVER,
                width=30,
                height=24,
                font=("Arial", 10)
            ).pack(side=tk.RIGHT, padx=(0, 6))
        
        def _show_tier_teams(self, teams, tier_name):
            """Show all teams in a tier in a popup"""
            popup = ctk.CTkToplevel(self)
            popup.title(f"{tier_name} Teams")
            popup.geometry("600x700")
            popup.configure(fg_color=FTBTheme.BG)
            
            # Make modal
            popup.transient(self)
            popup.grab_set()
            
            # Header
            header = ctk.CTkFrame(popup, fg_color=FTBTheme.CARD, corner_radius=8)
            header.pack(fill=tk.X, padx=10, pady=10)
            
            ctk.CTkLabel(
                header,
                text=f"🏆 {tier_name} ({len(teams)} teams)",
                font=("Arial", 16, "bold"),
                text_color=FTBTheme.TEXT
            ).pack(padx=15, pady=15)
            
            # Scrollable list
            teams_list = ctk.CTkScrollableFrame(popup, fg_color="transparent")
            teams_list.pack(fill=tk.BOTH, expand=True, padx=10, pady=(0, 10))
            
            for team in sorted(teams, key=lambda t: t.name):
                self._add_team_browser_card(teams_list, team)
            
            # Close button
            ctk.CTkButton(
                popup,
                text="Close",
                command=popup.destroy,
                fg_color=FTBTheme.SURFACE,
                hover_color=FTBTheme.BUTTON_SECONDARY_HOVER,
                width=150,
                height=40
            ).pack(pady=10)
        
        def _show_team_detail(self, team):
            """Show detailed team information in a popup"""
            popup = ctk.CTkToplevel(self)
            popup.title(f"Team: {team.name}")
            popup.geometry("700x800")
            popup.configure(fg_color=FTBTheme.BG)
            
            # Make modal
            popup.transient(self)
            popup.grab_set()
            
            try:
                team.normalize_roster()
            except Exception as e:
                _dbg(f"[FTB] Error normalizing roster: {e}")

            # Scrollable container
            container = ctk.CTkScrollableFrame(popup, fg_color="transparent")
            container.pack(fill=tk.BOTH, expand=True, padx=10, pady=10)
            
            try:
                # Team header
                header = ctk.CTkFrame(container, fg_color=FTBTheme.CARD, corner_radius=8)
                header.pack(fill=tk.X, pady=(0, 10))
                
                # Safe check for state
                is_player = False
                if self.sim_state and hasattr(self.sim_state, 'player_team'):
                    is_player = team == self.sim_state.player_team
                team_title = f"{team.name} {'(Your Team)' if is_player else ''}"
                
                ctk.CTkLabel(
                    header,
                    text=team_title,
                    font=("Arial", 18, "bold"),
                    text_color=FTBTheme.ACCENT if is_player else FTBTheme.TEXT
                ).pack(padx=15, pady=15)
                
                # Financial info
                fin_card = ctk.CTkFrame(container, fg_color=FTBTheme.CARD, corner_radius=8)
                fin_card.pack(fill=tk.X, pady=(0, 10))
                
                ctk.CTkLabel(
                    fin_card,
                    text="💰 Financials",
                    font=("Arial", 14, "bold"),
                    text_color=FTBTheme.TEXT
                ).pack(padx=15, pady=(15, 10), anchor="w")
                
                fin_info = f"""Budget: {format_currency(team.budget.cash)}
Weekly Expenses: {format_currency(sum(team.budget.staff_salaries.values()))}"""
                
                ctk.CTkLabel(
                    fin_card,
                    text=fin_info,
                    font=("Arial", 11),
                    text_color=FTBTheme.TEXT,
                    justify="left"
                ).pack(padx=15, pady=(0, 15), anchor="w")
                
                # Drivers
                if team.drivers:
                    drivers_card = ctk.CTkFrame(container, fg_color=FTBTheme.CARD, corner_radius=8)
                    drivers_card.pack(fill=tk.X, pady=(0, 10))
                
                ctk.CTkLabel(
                    drivers_card,
                    text="🏎️ Drivers",
                    font=("Arial", 14, "bold"),
                    text_color=FTBTheme.TEXT
                ).pack(padx=15, pady=(15, 10), anchor="w")
                
                for driver in team.drivers:
                    driver_info = f"{driver.name} (Age {driver.age}) - Rating: {driver.overall_rating:.0f}"
                    
                    # Add contract info if available
                    if (self.sim_state and hasattr(self.sim_state, 'contracts') and 
                        hasattr(driver, 'entity_id') and driver.entity_id in self.sim_state.contracts):
                        contract = self.sim_state.contracts[driver.entity_id]
                        if hasattr(self.sim_state, 'sim_day_of_year'):
                            seasons_left = contract.seasons_remaining(self.sim_state.sim_day_of_year)
                            driver_info += f" - Contract: {seasons_left:.1f} seasons"
                    
                    ctk.CTkLabel(
                        drivers_card,
                        text=driver_info,
                        font=("Arial", 10),
                        text_color=FTBTheme.TEXT
                    ).pack(padx=15, pady=2, anchor="w")
                
                ctk.CTkLabel(drivers_card, text="").pack(pady=5)  # Spacing
            
                # Engineers
                if team.engineers:
                    eng_card = ctk.CTkFrame(container, fg_color=FTBTheme.CARD, corner_radius=8)
                    eng_card.pack(fill=tk.X, pady=(0, 10))
                    
                    ctk.CTkLabel(
                        eng_card,
                        text="🔧 Engineers",
                        font=("Arial", 14, "bold"),
                        text_color=FTBTheme.TEXT
                    ).pack(padx=15, pady=(15, 10), anchor="w")
                    
                    for eng in team.engineers:
                        eng_info = f"{eng.name} (Age {eng.age}) - Rating: {eng.overall_rating:.0f}"
                        ctk.CTkLabel(
                            eng_card,
                            text=eng_info,
                            font=("Arial", 10),
                            text_color=FTBTheme.TEXT
                        ).pack(padx=15, pady=2, anchor="w")
                    
                    ctk.CTkLabel(eng_card, text="").pack(pady=5)
                
                # Mechanics
                if team.mechanics:
                    mech_card = ctk.CTkFrame(container, fg_color=FTBTheme.CARD, corner_radius=8)
                    mech_card.pack(fill=tk.X, pady=(0, 10))
                    
                    ctk.CTkLabel(
                        mech_card,
                        text="⚙️ Mechanics",
                        font=("Arial", 14, "bold"),
                        text_color=FTBTheme.TEXT
                    ).pack(padx=15, pady=(15, 10), anchor="w")
                    
                    for mech in team.mechanics:
                        mech_info = f"{mech.name} (Age {mech.age}) - Rating: {mech.overall_rating:.0f}"
                        ctk.CTkLabel(
                            mech_card,
                            text=mech_info,
                            font=("Arial", 10),
                            text_color=FTBTheme.TEXT
                        ).pack(padx=15, pady=2, anchor="w")
                    
                    ctk.CTkLabel(mech_card, text="").pack(pady=5)
                
                # Car and Parts
                if team.car:
                    car_card = ctk.CTkFrame(container, fg_color=FTBTheme.CARD, corner_radius=8)
                    car_card.pack(fill=tk.X, pady=(0, 10))
                
                ctk.CTkLabel(
                    car_card,
                    text="🏎️ Car",
                    font=("Arial", 14, "bold"),
                    text_color=FTBTheme.TEXT
                ).pack(padx=15, pady=(15, 10), anchor="w")
                
                car = team.car
                car_info = f"{car.name} (Mk{car.version})"
                ctk.CTkLabel(
                    car_card,
                    text=car_info,
                    font=("Arial", 11, "bold"),
                    text_color=FTBTheme.TEXT
                ).pack(padx=15, pady=2, anchor="w")
                
                # Car performance metrics
                perf_text = f"Performance: {car.performance_envelope:.1f} | Reliability: {car.reliability_score:.1f}"
                ctk.CTkLabel(
                    car_card,
                    text=perf_text,
                    font=("Arial", 10),
                    text_color=FTBTheme.TEXT_DIM
                ).pack(padx=15, pady=2, anchor="w")
                
                # Equipped parts summary
                if team.equipped_parts:
                    ctk.CTkLabel(
                        car_card,
                        text=f"\nEquipped Parts ({len(team.equipped_parts)}):",
                        font=("Arial", 11, "bold"),
                        text_color=FTBTheme.TEXT
                    ).pack(padx=15, pady=(5, 2), anchor="w")
                    
                    for part_type, part in sorted(team.equipped_parts.items()):
                        part_display = part_type.replace('_', ' ').title()
                        part_text = f"  • {part_display}: {part.name} (Mk{part.generation})"
                        eff = part.effectiveness_modifier
                        if eff < 0.7:
                            part_text += f" ⚠️ {eff*100:.0f}%"
                        ctk.CTkLabel(
                            car_card,
                            text=part_text,
                            font=("Arial", 9),
                            text_color=FTBTheme.TEXT_DIM if eff >= 0.7 else FTBTheme.DANGER
                        ).pack(padx=15, pady=1, anchor="w")
                
                ctk.CTkLabel(car_card, text="").pack(pady=5)
            
            except Exception as e:
                # Display error message in popup
                error_card = ctk.CTkFrame(container, fg_color=FTBTheme.CARD, corner_radius=8)
                error_card.pack(fill=tk.X, pady=(0, 10))
                
                ctk.CTkLabel(
                    error_card,
                    text="⚠️ Error Loading Team Details",
                    font=("Arial", 14, "bold"),
                    text_color=FTBTheme.DANGER
                ).pack(padx=15, pady=(15, 10), anchor="w")
                
                ctk.CTkLabel(
                    error_card,
                    text=str(e),
                    font=("Arial", 10),
                    text_color=FTBTheme.TEXT,
                    wraplength=650
                ).pack(padx=15, pady=(0, 15), anchor="w")
                
                _dbg(f"[FTB] Error showing team detail for {team.name}: {e}")
                import traceback
                traceback.print_exc()
            
            # Close button
            ctk.CTkButton(
                popup,
                text="Close",
                command=popup.destroy,
                fg_color=FTBTheme.SURFACE,
                hover_color=FTBTheme.BUTTON_SECONDARY_HOVER,
                width=150,
                height=40
            ).pack(pady=10)

        def _show_team_lineup(self, team):
            """Show lineup and talent summary for a team"""
            popup = ctk.CTkToplevel(self)
            popup.title(f"Lineup: {team.name}")
            popup.geometry("700x750")
            popup.configure(fg_color=FTBTheme.BG)
            popup.transient(self)
            popup.grab_set()

            team.normalize_roster()

            container = ctk.CTkScrollableFrame(popup, fg_color="transparent")
            container.pack(fill=tk.BOTH, expand=True, padx=10, pady=10)

            header = ctk.CTkFrame(container, fg_color=FTBTheme.CARD, corner_radius=8)
            header.pack(fill=tk.X, pady=(0, 10))

            ctk.CTkLabel(
                header,
                text=f"🏁 {team.name} Lineup",
                font=("Arial", 18, "bold"),
                text_color=FTBTheme.TEXT
            ).pack(padx=15, pady=15)

            def render_summary(title, entries):
                ratings = [e.overall_rating for e in entries if e and hasattr(e, 'overall_rating')]
                summary = "None" if not ratings else f"{len(ratings)} staff | Avg {sum(ratings)/len(ratings):.1f} | Best {max(ratings):.0f} | Worst {min(ratings):.0f}"

                card = ctk.CTkFrame(container, fg_color=FTBTheme.CARD, corner_radius=8)
                card.pack(fill=tk.X, pady=(0, 10))

                ctk.CTkLabel(
                    card,
                    text=title,
                    font=("Arial", 14, "bold"),
                    text_color=FTBTheme.TEXT
                ).pack(padx=15, pady=(15, 5), anchor="w")

                ctk.CTkLabel(
                    card,
                    text=summary,
                    font=("Arial", 11),
                    text_color=FTBTheme.TEXT_MUTED
                ).pack(padx=15, pady=(0, 10), anchor="w")

                for entry in [e for e in entries if e]:
                    entry_text = f"{entry.name} (Age {entry.age}) - OVR {entry.overall_rating:.0f}"
                    ctk.CTkLabel(
                        card,
                        text=entry_text,
                        font=("Arial", 10),
                        text_color=FTBTheme.TEXT
                    ).pack(padx=15, pady=2, anchor="w")

                ctk.CTkLabel(card, text="").pack(pady=5)

            render_summary("🏎️ Drivers", team.drivers)
            render_summary("🔧 Engineers", team.engineers)
            render_summary("⚙️ Mechanics", team.mechanics)
            render_summary("📊 Strategist", [team.strategist] if team.strategist else [])
            render_summary("👔 Principal", [team.principal] if team.principal else [])

            ctk.CTkButton(
                popup,
                text="Close",
                command=popup.destroy,
                fg_color=FTBTheme.SURFACE,
                hover_color=FTBTheme.BUTTON_SECONDARY_HOVER,
                width=150,
                height=40
            ).pack(pady=10)
        
        def _build_manager_career_tab(self):
            """Build Manager Career tab - Career stats, history, achievements"""
            tab = self.tab_manager_career
            
            # Main scrollable container
            container = ctk.CTkScrollableFrame(tab, fg_color="transparent")
            container.pack(fill=tk.BOTH, expand=True)
            
            # Header
            header = ctk.CTkFrame(container, fg_color=FTBTheme.CARD, corner_radius=8)
            header.pack(fill=tk.X, padx=10, pady=(10, 10))

            # Header content frame for title and refresh button
            header_content = ctk.CTkFrame(header, fg_color="transparent")
            header_content.pack(fill=tk.X, padx=15, pady=15)

            ctk.CTkLabel(
                header_content,
                text="🏆 Manager Career Statistics",
                font=("Arial", 16, "bold"),
                text_color=FTBTheme.TEXT
            ).pack(side=tk.LEFT)

            ctk.CTkButton(
                header_content,
                text="🔄 Refresh",
                command=self._refresh_manager_career,
                fg_color=FTBTheme.ACCENT,
                hover_color=FTBTheme.ACCENT_HOVER,
                width=100,
                height=30,
                font=("Arial", 11)
            ).pack(side=tk.RIGHT)

            # Manager Career Stats container
            self.manager_career_container = ctk.CTkFrame(container, fg_color="transparent")
            self.manager_career_container.pack(fill=tk.BOTH, expand=True, padx=10, pady=(0, 10))

            # Initial refresh to populate data
            self._refresh_manager_career()
        
        def _refresh_manager_career(self):
            """Refresh manager career stats display"""
            if not self.sim_state or not self.sim_state.manager_career_stats:
                return
            
            # Clear existing
            for widget in self.manager_career_container.winfo_children():
                widget.destroy()
            
            stats = self.sim_state.manager_career_stats
            
            # Manager Profile Card
            profile_card = ctk.CTkFrame(self.manager_career_container, fg_color=FTBTheme.CARD, corner_radius=8)
            profile_card.pack(fill=tk.X, pady=(0, 10))
            
            ctk.CTkLabel(
                profile_card,
                text="Manager Profile",
                font=("Arial", 14, "bold"),
                text_color=FTBTheme.TEXT
            ).pack(padx=15, pady=(15, 10), anchor="w")
            
            profile_info = ctk.CTkFrame(profile_card, fg_color="transparent")
            profile_info.pack(fill=tk.X, padx=15, pady=(0, 15))
            
            identity = ", ".join(self.sim_state.player_identity) if self.sim_state.player_identity else "Unknown"
            current_team = self.sim_state.player_team.name if self.sim_state.player_team else "No team"
            
            # Build manager name display
            manager_name_parts = []
            if self.sim_state.manager_first_name:
                manager_name_parts.append(self.sim_state.manager_first_name)
            if self.sim_state.manager_last_name:
                manager_name_parts.append(self.sim_state.manager_last_name)
            manager_name = " ".join(manager_name_parts) if manager_name_parts else "Not Set"
            
            info_text = f"""Manager: {manager_name}
Age: {self.sim_state.player_age} years old
Identity: {identity}
Current Team: {current_team}
Career Started: Year {stats.career_start_year}
Seasons Managed: {stats.seasons_managed}
Teams Managed: {len(stats.teams_managed)}"""
            
            ctk.CTkLabel(
                profile_info,
                text=info_text,
                font=("Arial", 12),
                text_color=FTBTheme.TEXT,
                justify="left",
                anchor="w"
            ).pack(fill=tk.X)
            
            # Racing Achievement Stats
            racing_card = ctk.CTkFrame(self.manager_career_container, fg_color=FTBTheme.CARD, corner_radius=8)
            racing_card.pack(fill=tk.X, pady=(0, 10))
            
            ctk.CTkLabel(
                racing_card,
                text="🏁 Racing Achievements",
                font=("Arial", 14, "bold"),
                text_color=FTBTheme.TEXT
            ).pack(padx=15, pady=(15, 10), anchor="w")
            
            racing_grid = ctk.CTkFrame(racing_card, fg_color="transparent")
            racing_grid.pack(fill=tk.X, padx=15, pady=(0, 15))
            
            racing_stats = [
                ("Total Races", stats.total_races),
                ("Wins", stats.wins),
                ("Podiums", stats.podiums),
                ("Pole Positions", stats.poles),
                ("Championships", stats.championships),
                ("Best Finish", f"P{stats.best_championship_finish}" if stats.best_championship_finish < 999 else "N/A"),
            ]
            
            for i, (label, value) in enumerate(racing_stats):
                stat_frame = ctk.CTkFrame(racing_grid, fg_color=FTBTheme.SURFACE, corner_radius=6)
                stat_frame.grid(row=i//2, column=i%2, padx=5, pady=5, sticky="ew")
                racing_grid.columnconfigure(0, weight=1)
                racing_grid.columnconfigure(1, weight=1)
                
                ctk.CTkLabel(
                    stat_frame,
                    text=label,
                    font=("Arial", 11),
                    text_color=FTBTheme.TEXT_MUTED
                ).pack(side=tk.LEFT, padx=10, pady=8)
                
                ctk.CTkLabel(
                    stat_frame,
                    text=str(value),
                    font=("Arial", 12, "bold"),
                    text_color=FTBTheme.ACCENT
                ).pack(side=tk.RIGHT, padx=10, pady=8)
            
            # Teams Managed History
            if stats.teams_managed:
                teams_card = ctk.CTkFrame(self.manager_career_container, fg_color=FTBTheme.CARD, corner_radius=8)
                teams_card.pack(fill=tk.X, pady=(0, 10))
                
                ctk.CTkLabel(
                    teams_card,
                    text="👔 Teams Managed",
                    font=("Arial", 14, "bold"),
                    text_color=FTBTheme.TEXT
                ).pack(padx=15, pady=(15, 10), anchor="w")
                
                teams_list = ctk.CTkFrame(teams_card, fg_color="transparent")
                teams_list.pack(fill=tk.X, padx=15, pady=(0, 15))
                
                for i, team_name in enumerate(stats.teams_managed, 1):
                    team_entry = ctk.CTkFrame(teams_list, fg_color=FTBTheme.SURFACE, corner_radius=4)
                    team_entry.pack(fill=tk.X, pady=2)
                    
                    ctk.CTkLabel(
                        team_entry,
                        text=f"{i}. {team_name}",
                        font=("Arial", 11),
                        text_color=FTBTheme.TEXT
                    ).pack(side=tk.LEFT, padx=10, pady=6)
                    
                    if team_name == self.sim_state.player_team.name:
                        ctk.CTkLabel(
                            team_entry,
                            text="(Current)",
                            font=("Arial", 10, "italic"),
                            text_color=FTBTheme.ACCENT
                        ).pack(side=tk.RIGHT, padx=10, pady=6)
            
            # Season History
            if stats.season_history:
                history_card = ctk.CTkFrame(self.manager_career_container, fg_color=FTBTheme.CARD, corner_radius=8)
                history_card.pack(fill=tk.X, pady=(0, 10))
                
                ctk.CTkLabel(
                    history_card,
                    text="📊 Season-by-Season Results",
                    font=("Arial", 14, "bold"),
                    text_color=FTBTheme.TEXT
                ).pack(padx=15, pady=(15, 10), anchor="w")
                
                history_list = ctk.CTkFrame(history_card, fg_color="transparent")
                history_list.pack(fill=tk.X, padx=15, pady=(0, 15))
                
                # Header row
                header_row = ctk.CTkFrame(history_list, fg_color=FTBTheme.SURFACE, corner_radius=4)
                header_row.pack(fill=tk.X, pady=(0, 5))
                
                for text in ["Year", "Team", "Position", "Points"]:
                    ctk.CTkLabel(
                        header_row,
                        text=text,
                        font=("Arial", 11, "bold"),
                        text_color=FTBTheme.TEXT
                    ).pack(side=tk.LEFT, padx=10, pady=6, expand=True)
                
                # Data rows(most recent first)
                for season in reversed(stats.season_history[-10:]):  # Show last 10 seasons
                    row = ctk.CTkFrame(history_list, fg_color=FTBTheme.SURFACE, corner_radius=4)
                    row.pack(fill=tk.X, pady=2)
                    
                    year_label = ctk.CTkLabel(
                        row,
                        text=f"Year {season['year']}",
                        font=("Arial", 11),
                        text_color=FTBTheme.TEXT
                    )
                    year_label.pack(side=tk.LEFT, padx=10, pady=6, expand=True)
                    
                    team_label = ctk.CTkLabel(
                        row,
                        text=season['team'][:20],  # Truncate long names
                        font=("Arial", 11),
                        text_color=FTBTheme.TEXT
                    )
                    team_label.pack(side=tk.LEFT, padx=10, pady=6, expand=True)
                    
                    pos_color = FTBTheme.ACCENT if season['position'] == 1 else FTBTheme.TEXT
                    pos_label = ctk.CTkLabel(
                        row,
                        text=f"P{season['position']}",
                        font=("Arial", 11, "bold" if season['position'] <= 3 else "normal"),
                        text_color=pos_color
                    )
                    pos_label.pack(side=tk.LEFT, padx=10, pady=6, expand=True)
                    
                    pts_label = ctk.CTkLabel(
                        row,
                        text=f"{season['points']:.0f}",
                        font=("Arial", 11),
                        text_color=FTBTheme.TEXT
                    )
                    pts_label.pack(side=tk.LEFT, padx=10, pady=6, expand=True)
        
        def _build_car_tab(self):
            """Build Car tab - Car overview, equipped parts, inventory, and marketplace"""
            tab = self.tab_car
            
            # Two column layout
            left_panel = ctk.CTkScrollableFrame(tab, fg_color="transparent")
            left_panel.pack(side=tk.LEFT, fill=tk.BOTH, expand=True, padx=(0, 5))
            
            right_panel = ctk.CTkScrollableFrame(tab, fg_color="transparent")
            right_panel.pack(side=tk.RIGHT, fill=tk.BOTH, expand=True, padx=(5, 0))
            
            # Left: Car Overview & Equipped Parts
            car_overview_header = ctk.CTkFrame(left_panel, fg_color=FTBTheme.CARD, corner_radius=8)
            car_overview_header.pack(fill=tk.X, pady=(0, 10))
            
            car_overview_header_content = ctk.CTkFrame(car_overview_header, fg_color="transparent")
            car_overview_header_content.pack(fill=tk.X, padx=15, pady=15)
            
            ctk.CTkLabel(
                car_overview_header_content,
                text="🏎️ Car Overview",
                font=("Arial", 16, "bold"),
                text_color=FTBTheme.TEXT
            ).pack(side=tk.LEFT)
            
            ctk.CTkButton(
                car_overview_header_content,
                text="↻ Refresh",
                command=lambda: (self._refresh_car_overview(), self._refresh_car_parts_visual()),
                fg_color=FTBTheme.ACCENT,
                hover_color=FTBTheme.ACCENT_HOVER,
                width=100,
                height=28,
                font=("Arial", 11)
            ).pack(side=tk.RIGHT)
            
            self.car_overview_container = ctk.CTkFrame(left_panel, fg_color="transparent")
            self.car_overview_container.pack(fill=tk.X, pady=(0, 15))
            
            self.car_parts_visual_container = ctk.CTkFrame(left_panel, fg_color="transparent")
            self.car_parts_visual_container.pack(fill=tk.X, pady=(0, 15))
            
            # Parts Inventory
            inventory_header = ctk.CTkFrame(left_panel, fg_color=FTBTheme.CARD, corner_radius=8)
            inventory_header.pack(fill=tk.X, pady=(0, 10))

            # Inventory header content frame for title and refresh button
            inventory_header_content = ctk.CTkFrame(inventory_header, fg_color="transparent")
            inventory_header_content.pack(fill=tk.X, padx=15, pady=15)

            ctk.CTkLabel(
                inventory_header_content,
                text="📦 Parts Inventory",
                font=("Arial", 16, "bold"),
                text_color=FTBTheme.TEXT
            ).pack(side=tk.LEFT)

            ctk.CTkButton(
                inventory_header_content,
                text="🔄 Refresh",
                command=self._refresh_parts_inventory,
                fg_color=FTBTheme.ACCENT,
                hover_color=FTBTheme.ACCENT_HOVER,
                width=100,
                height=30,
                font=("Arial", 11)
            ).pack(side=tk.RIGHT)

            self.parts_inventory_container = ctk.CTkFrame(left_panel, fg_color="transparent")
            self.parts_inventory_container.pack(fill=tk.BOTH, expand=True, pady=(0, 15))
            
            # Right: Parts Marketplace with filters
            marketplace_header = ctk.CTkFrame(right_panel, fg_color=FTBTheme.CARD, corner_radius=8)
            marketplace_header.pack(fill=tk.X, pady=(0, 10))
            
            header_top = ctk.CTkFrame(marketplace_header, fg_color="transparent")
            header_top.pack(fill=tk.X, padx=15, pady=(15, 5))
            
            ctk.CTkLabel(
                header_top,
                text="🛒 Parts Marketplace",
                font=("Arial", 16, "bold"),
                text_color=FTBTheme.TEXT
            ).pack(side=tk.LEFT)
            
            ctk.CTkButton(
                header_top,
                text="🔄 Refresh",
                command=self._force_parts_marketplace_refresh,
                fg_color=FTBTheme.BUTTON_SECONDARY,
                hover_color=FTBTheme.BUTTON_SECONDARY_HOVER,
                width=100,
                height=28,
                font=("Arial", 11)
            ).pack(side=tk.RIGHT)
            
            # Market controls
            controls_frame = ctk.CTkFrame(marketplace_header, fg_color="transparent")
            controls_frame.pack(fill=tk.X, padx=15, pady=(0, 10))
            
            # Filter by part type dropdown
            filter_row1 = ctk.CTkFrame(controls_frame, fg_color="transparent")
            filter_row1.pack(fill=tk.X, pady=(0, 5))
            
            ctk.CTkLabel(
                filter_row1,
                text="Type:",
                font=("Arial", 10),
                text_color=FTBTheme.TEXT_MUTED,
                width=60
            ).pack(side=tk.LEFT)
            
            self.marketplace_type_var = tk.StringVar(value="All Types")
            self.marketplace_type_filter = ctk.CTkOptionMenu(
                filter_row1,
                variable=self.marketplace_type_var,
                values=["All Types"],
                command=lambda _: self._refresh_parts_marketplace(),
                fg_color=FTBTheme.SURFACE,
                button_color=FTBTheme.ACCENT,
                button_hover_color=FTBTheme.CARD_HOVER,
                width=160,
                height=28,
                font=("Arial", 10)
            )
            self.marketplace_type_filter.pack(side=tk.LEFT, padx=(0, 10))
            
            # Sort dropdown
            ctk.CTkLabel(
                filter_row1,
                text="Sort:",
                font=("Arial", 10),
                text_color=FTBTheme.TEXT_MUTED,
                width=40
            ).pack(side=tk.LEFT)
            
            self.marketplace_sort_var = tk.StringVar(value="Latest")
            self.marketplace_sort_menu = ctk.CTkOptionMenu(
                filter_row1,
                variable=self.marketplace_sort_var,
                values=["Latest", "Performance", "Price (Low)", "Price (High)", "Manufacturer"],
                command=lambda _: self._refresh_parts_marketplace(),
                fg_color=FTBTheme.SURFACE,
                button_color=FTBTheme.ACCENT,
                button_hover_color=FTBTheme.CARD_HOVER,
                width=120,
                height=28,
                font=("Arial", 10)
            )
            self.marketplace_sort_menu.pack(side=tk.LEFT)
            
            # Search and manufacturer filter
            filter_row2 = ctk.CTkFrame(controls_frame, fg_color="transparent")
            filter_row2.pack(fill=tk.X)
            
            ctk.CTkLabel(
                filter_row2,
                text="Search:",
                font=("Arial", 10),
                text_color=FTBTheme.TEXT_MUTED,
                width=60
            ).pack(side=tk.LEFT)
            
            self.marketplace_search_var = tk.StringVar()
            self.marketplace_search_var.trace_add("write", lambda *args: self._refresh_parts_marketplace())
            self.marketplace_search_entry = ctk.CTkEntry(
                filter_row2,
                textvariable=self.marketplace_search_var,
                placeholder_text="Search parts...",
                fg_color=FTBTheme.SURFACE,
                border_color=FTBTheme.CARD_HOVER,
                width=180,
                height=28,
                font=("Arial", 10)
            )
            self.marketplace_search_entry.pack(side=tk.LEFT, padx=(0, 10))
            
            ctk.CTkLabel(
                filter_row2,
                text="Brand:",
                font=("Arial", 10),
                text_color=FTBTheme.TEXT_MUTED,
                width=40
            ).pack(side=tk.LEFT)
            
            self.marketplace_mfr_var = tk.StringVar(value="All Brands")
            self.marketplace_mfr_filter = ctk.CTkOptionMenu(
                filter_row2,
                variable=self.marketplace_mfr_var,
                values=["All Brands"],
                command=lambda _: self._refresh_parts_marketplace(),
                fg_color=FTBTheme.SURFACE,
                button_color=FTBTheme.ACCENT,
                button_hover_color=FTBTheme.CARD_HOVER,
                width=140,
                height=28,
                font=("Arial", 10)
            )
            self.marketplace_mfr_filter.pack(side=tk.LEFT)
            
            self.parts_marketplace_container = ctk.CTkFrame(right_panel, fg_color="transparent")
            self.parts_marketplace_container.pack(fill=tk.BOTH, expand=True)
            
            # Initial refresh to populate data
            self._refresh_car_overview()
            self._refresh_car_parts_visual()
            self._refresh_parts_inventory()
            self._refresh_parts_marketplace()
        
        def _refresh_car_overview(self):
            """Update car overview section"""
            if not self.sim_state or not self.sim_state.player_team or not self.sim_state.player_team.car:
                return
            
            # Clear existing
            for widget in self.car_overview_container.winfo_children():
                widget.destroy()
            
            car = self.sim_state.player_team.car
            team = self.sim_state.player_team
            
            # Car overview card
            overview_card = ctk.CTkFrame(self.car_overview_container, fg_color=FTBTheme.CARD, corner_radius=8)
            overview_card.pack(fill=tk.X, pady=(0, 10))
            
            # Car name header (editable)
            name_frame = ctk.CTkFrame(overview_card, fg_color="transparent")
            name_frame.pack(fill=tk.X, padx=15, pady=15)
            
            name_button = ctk.CTkButton(
                name_frame,
                text=f"🏎️ {car.name}",
                command=self._rename_car,
                fg_color="transparent",
                hover_color=FTBTheme.CARD_HOVER,
                font=("Arial", 20, "bold"),
                text_color=FTBTheme.ACCENT,
                anchor="w"
            )
            name_button.pack(side=tk.LEFT, anchor="w")
            
            ctk.CTkLabel(
                name_frame,
                text="✏️ Click to rename",
                font=("Arial", 9, "italic"),
                text_color=FTBTheme.TEXT_DIM
            ).pack(side=tk.LEFT, padx=(10, 0))
            
            # Performance metrics
            metrics_frame = ctk.CTkFrame(overview_card, fg_color=FTBTheme.SURFACE, corner_radius=6)
            metrics_frame.pack(fill=tk.X, padx=15, pady=(0, 15))
            
            # Performance envelope
            perf = car.performance_envelope
            StatBar(
                metrics_frame,
                label="Performance",
                value=perf,
                max_value=100,
                width=300,
                show_value=True
            ).pack(padx=15, pady=8)
            
            # Usability
            usability = car.usability
            StatBar(
                metrics_frame,
                label="Drivability",
                value=usability,
                max_value=100,
                width=300,
                show_value=True
            ).pack(padx=15, pady=8)
            
            # Reliability
            reliability = car.reliability_score
            StatBar(
                metrics_frame,
                label="Reliability",
                value=reliability,
                max_value=100,
                width=300,
                show_value=True
            ).pack(padx=15, pady=8)
            
            # Car metadata
            meta_frame = ctk.CTkFrame(overview_card, fg_color="transparent")
            meta_frame.pack(fill=tk.X, padx=15, pady=(0, 15))
            
            ctk.CTkLabel(
                meta_frame,
                text=f"Version: Mk{car.version} | Architecture: {', '.join(car.architecture_tags[:3]) if car.architecture_tags else 'Standard'}",
                font=("Arial", 10),
                text_color=FTBTheme.TEXT_DIM
            ).pack(anchor="w")
            
            # Active developments affecting car
            active_devs = [p for p in team.active_rd_projects if not p.completed and not p.cancelled]
            if active_devs:
                dev_header = ctk.CTkFrame(overview_card, fg_color="transparent")
                dev_header.pack(fill=tk.X, padx=15, pady=(5, 10))
                
                ctk.CTkLabel(
                    dev_header,
                    text="⚙️ Active Developments",
                    font=("Arial", 12, "bold"),
                    text_color=FTBTheme.TEXT
                ).pack(anchor="w")
                
                for dev in active_devs[:3]:  # Show max 3
                    dev_frame = ctk.CTkFrame(overview_card, fg_color=FTBTheme.SURFACE, corner_radius=4)
                    dev_frame.pack(fill=tk.X, padx=15, pady=3)
                    
                    ticks_remaining = max(0, dev.duration_ticks - dev.progress_ticks)
                    progress = dev.progress_ticks / dev.duration_ticks if dev.duration_ticks > 0 else 0.0
                    
                    info_frame = ctk.CTkFrame(dev_frame, fg_color="transparent")
                    info_frame.pack(fill=tk.X, padx=10, pady=6)
                    
                    ctk.CTkLabel(
                        info_frame,
                        text=dev.project_name,
                        font=("Arial", 10, "bold"),
                        text_color=FTBTheme.TEXT
                    ).pack(side=tk.LEFT)
                    
                    ctk.CTkLabel(
                        info_frame,
                        text=f"{ticks_remaining} ticks",
                        font=("Arial", 9),
                        text_color=FTBTheme.TEXT_DIM
                    ).pack(side=tk.RIGHT)
                    
                    # Progress bar
                    progress_bar = ctk.CTkProgressBar(
                        dev_frame,
                        width=250,
                        height=6,
                        progress_color=FTBTheme.ACCENT
                    )
                    progress_bar.set(progress)
                    progress_bar.pack(padx=10, pady=(0, 6))
            
            # Link to development tab
            link_frame = ctk.CTkFrame(overview_card, fg_color="transparent")
            link_frame.pack(fill=tk.X, padx=15, pady=(5, 15))
            
            ctk.CTkButton(
                link_frame,
                text="→ Open Development Tab",
                command=lambda: self.tabview.set("Development"),
                fg_color=FTBTheme.SURFACE,
                hover_color=FTBTheme.CARD_HOVER,
                height=30,
                font=("Arial", 10)
            ).pack(fill=tk.X)
        
        def _refresh_car_parts_visual(self):
            """Update visual parts display with car silhouette"""
            if not self.sim_state or not self.sim_state.player_team or not self.sim_state.player_team.car:
                return
            
            # Clear existing
            for widget in self.car_parts_visual_container.winfo_children():
                widget.destroy()
            
            team = self.sim_state.player_team
            car = team.car
            
            # Parts visual card
            visual_card = ctk.CTkFrame(self.car_parts_visual_container, fg_color=FTBTheme.CARD, corner_radius=8)
            visual_card.pack(fill=tk.BOTH, expand=True)
            
            header_frame = ctk.CTkFrame(visual_card, fg_color="transparent")
            header_frame.pack(fill=tk.X, padx=15, pady=15)
            
            ctk.CTkLabel(
                header_frame,
                text="🔧 Equipped Parts",
                font=("Arial", 16, "bold"),
                text_color=FTBTheme.TEXT
            ).pack(anchor="w")
            
            # Get available part types for this tier
            available_types = {ptype: tiers for ptype, tiers in PART_TYPES.items() if team.tier in tiers}
            
            # Car silhouette layout (grid-based)
            parts_grid = ctk.CTkFrame(visual_card, fg_color="transparent")
            parts_grid.pack(fill=tk.BOTH, expand=True, padx=15, pady=10)
            
            # Part slot layout positions (row, col, rowspan, colspan)
            slot_layout = {
                'aero_package': (0, 1, 1, 1, "🌪️ Aero"),
                'electronics': (1, 0, 1, 1, "💻 Electronics"),
                'engine': (1, 1, 1, 1, "⚡ Engine"),
                'cooling': (1, 2, 1, 1, "❄️ Cooling"),
                'suspension': (2, 0, 1, 1, "🔧 Suspension"),
                'chassis': (2, 1, 1, 1, "🏗️ Chassis"),
                'transmission': (2, 2, 1, 1, "⚙️ Trans"),
                'brakes': (3, 0, 1, 1, "🛑 Brakes"),
                'tires': (3, 1, 1, 1, "⭕ Tires"),
            }
            
            for part_type, (row, col, rowspan, colspan, icon_label) in slot_layout.items():
                if part_type not in available_types:
                    continue  # Skip if not available at this tier
                
                part_slot = ctk.CTkFrame(parts_grid, fg_color=FTBTheme.SURFACE, corner_radius=6)
                part_slot.grid(row=row, column=col, rowspan=rowspan, columnspan=colspan, padx=5, pady=5, sticky="nsew")
                
                # Configure grid weights
                parts_grid.grid_rowconfigure(row, weight=1)
                parts_grid.grid_columnconfigure(col, weight=1)
                
                # Check if part is equipped
                equipped_part = team.equipped_parts.get(part_type)
                
                if equipped_part:
                    # Show equipped part
                    part_frame = ctk.CTkFrame(part_slot, fg_color="transparent")
                    part_frame.pack(fill=tk.BOTH, expand=True, padx=8, pady=8)
                    
                    # Icon and type label
                    ctk.CTkLabel(
                        part_frame,
                        text=icon_label,
                        font=("Arial", 11, "bold"),
                        text_color=FTBTheme.TEXT_DIM
                    ).pack(anchor="w")
                    
                    # Part name
                    ctk.CTkLabel(
                        part_frame,
                        text=equipped_part.name,
                        font=("Arial", 10, "bold"),
                        text_color=FTBTheme.TEXT
                    ).pack(anchor="w", pady=(2, 0))
                    
                    # Generation and effectiveness
                    gen_text = f"Mk{equipped_part.generation}"
                    eff = equipped_part.effectiveness_modifier
                    
                    # Color based on effectiveness
                    if eff >= 0.9:
                        eff_color = FTBTheme.SUCCESS
                        eff_icon = "✓"
                    elif eff >= 0.7:
                        eff_color = FTBTheme.TEXT
                        eff_icon = "•"
                    else:
                        eff_color = FTBTheme.DANGER
                        eff_icon = "⚠️"
                    
                    info_row = ctk.CTkFrame(part_frame, fg_color="transparent")
                    info_row.pack(fill=tk.X, pady=(4, 0))
                    
                    ctk.CTkLabel(
                        info_row,
                        text=gen_text,
                        font=("Arial", 9),
                        text_color=FTBTheme.TEXT_DIM
                    ).pack(side=tk.LEFT)
                    
                    ctk.CTkLabel(
                        info_row,
                        text=f"{eff_icon} {eff*100:.0f}%",
                        font=("Arial", 9),
                        text_color=eff_color
                    ).pack(side=tk.RIGHT)
                    
                    # Click to view details
                    detail_btn = ctk.CTkButton(
                        part_frame,
                        text="View",
                        command=lambda p=equipped_part: self._show_part_details(p),
                        fg_color=FTBTheme.ACCENT,
                        hover_color=FTBTheme.CARD_HOVER,
                        height=24,
                        width=60,
                        font=("Arial", 9)
                    )
                    detail_btn.pack(pady=(6, 0))
                else:
                    # Empty slot
                    empty_frame = ctk.CTkFrame(part_slot, fg_color="transparent")
                    empty_frame.pack(fill=tk.BOTH, expand=True, padx=8, pady=8)
                    
                    ctk.CTkLabel(
                        empty_frame,
                        text=icon_label,
                        font=("Arial", 11, "bold"),
                        text_color=FTBTheme.TEXT_DIM
                    ).pack(anchor="w")
                    
                    ctk.CTkLabel(
                        empty_frame,
                        text="No part equipped",
                        font=("Arial", 9, "italic"),
                        text_color=FTBTheme.TEXT_DIM
                    ).pack(anchor="w", pady=(4, 0))
                    
                    # Equip button (if inventory has parts of this type)
                    inventory_parts = [p for p in team.parts_inventory if p.part_type == part_type]
                    if inventory_parts:
                        ctk.CTkButton(
                            empty_frame,
                            text="Equip",
                            command=lambda pt=part_type: self._quick_equip_part(pt),
                            fg_color=FTBTheme.SUCCESS,
                            hover_color=FTBTheme.CARD_HOVER,
                            height=24,
                            width=60,
                            font=("Arial", 9)
                        ).pack(pady=(6, 0))
        
        def _refresh_parts_inventory(self):
            """Update parts inventory browser"""
            if not self.sim_state or not self.sim_state.player_team:
                return
            
            # Clear existing
            for widget in self.parts_inventory_container.winfo_children():
                widget.destroy()
            
            team = self.sim_state.player_team
            inventory = team.parts_inventory
            _dbg(f"[FTB WIDGET] _refresh_parts_inventory called: inventory has {len(inventory)} parts")
            if inventory:
                for part in inventory[:3]:  # Show first 3
                    _dbg(f"[FTB WIDGET]   - {part.name} ({part.part_type})")
            
            if not inventory:
                # Empty state
                empty_frame = ctk.CTkFrame(self.parts_inventory_container, fg_color=FTBTheme.CARD, corner_radius=8)
                empty_frame.pack(fill=tk.BOTH, expand=True, pady=10)
                
                ctk.CTkLabel(
                    empty_frame,
                    text="No parts in inventory",
                    font=("Arial", 12),
                    text_color=FTBTheme.TEXT_DIM
                ).pack(pady=40)
                
                ctk.CTkLabel(
                    empty_frame,
                    text="Purchase parts from the Development tab",
                    font=("Arial", 10, "italic"),
                    text_color=FTBTheme.TEXT_DIM
                ).pack(pady=(0, 40))
                return
            
            # Group by part type
            parts_by_type = {}
            for part in inventory:
                if part.part_type not in parts_by_type:
                    parts_by_type[part.part_type] = []
                parts_by_type[part.part_type].append(part)
            
            # Display each group
            for part_type, parts in sorted(parts_by_type.items()):
                type_card = ctk.CTkFrame(self.parts_inventory_container, fg_color=FTBTheme.CARD, corner_radius=8)
                type_card.pack(fill=tk.X, pady=(0, 10))
                
                # Type header
                type_header = ctk.CTkFrame(type_card, fg_color=FTBTheme.SURFACE, corner_radius=6)
                type_header.pack(fill=tk.X, padx=10, pady=10)
                
                ctk.CTkLabel(
                    type_header,
                    text=f"{part_type.replace('_', ' ').title()} ({len(parts)})",
                    font=("Arial", 12, "bold"),
                    text_color=FTBTheme.TEXT
                ).pack(padx=10, pady=8, anchor="w")
                
                # Parts in this type
                parts_list = ctk.CTkFrame(type_card, fg_color="transparent")
                parts_list.pack(fill=tk.X, padx=10, pady=(0, 10))
                
                # Sort by generation (newest first)
                sorted_parts = sorted(parts, key=lambda p: p.generation, reverse=True)
                
                for part in sorted_parts:
                    self._create_inventory_part_card(parts_list, part)
        
        def _create_inventory_part_card(self, parent, part):
            """Create a card for an inventory part"""
            card = ctk.CTkFrame(parent, fg_color=FTBTheme.SURFACE, corner_radius=6)
            card.pack(fill=tk.X, pady=3)
            
            content = ctk.CTkFrame(card, fg_color="transparent")
            content.pack(fill=tk.X, padx=10, pady=8)
            
            # Left: Part info
            info_frame = ctk.CTkFrame(content, fg_color="transparent")
            info_frame.pack(side=tk.LEFT, fill=tk.BOTH, expand=True)
            
            # Name and generation
            name_row = ctk.CTkFrame(info_frame, fg_color="transparent")
            name_row.pack(fill=tk.X, anchor="w")
            
            ctk.CTkLabel(
                name_row,
                text=part.name,
                font=("Arial", 11, "bold"),
                text_color=FTBTheme.TEXT
            ).pack(side=tk.LEFT)
            
            ctk.CTkLabel(
                name_row,
                text=f"Mk{part.generation}",
                font=("Arial", 9),
                text_color=FTBTheme.ACCENT
            ).pack(side=tk.LEFT, padx=(8, 0))
            
            # Manufacturer and effectiveness
            meta_row = ctk.CTkFrame(info_frame, fg_color="transparent")
            meta_row.pack(fill=tk.X, anchor="w", pady=(2, 0))
            
            ctk.CTkLabel(
                meta_row,
                text=f"{part.manufacturer_id}",
                font=("Arial", 9),
                text_color=FTBTheme.TEXT_DIM
            ).pack(side=tk.LEFT)
            
            eff_color = FTBTheme.SUCCESS if part.effectiveness_modifier >= 0.7 else FTBTheme.DANGER
            ctk.CTkLabel(
                meta_row,
                text=f"• {part.effectiveness_modifier*100:.0f}% effective",
                font=("Arial", 9),
                text_color=eff_color
            ).pack(side=tk.LEFT, padx=(8, 0))
            
            # Performance score
            perf_score = part.performance_score
            score_color = FTBTheme.get_stat_color(perf_score)
            
            ctk.CTkLabel(
                meta_row,
                text=f"• Performance: {perf_score:.1f}",
                font=("Arial", 9),
                text_color=score_color
            ).pack(side=tk.LEFT, padx=(8, 0))
            
            # Right: Actions
            actions_frame = ctk.CTkFrame(content, fg_color="transparent")
            actions_frame.pack(side=tk.RIGHT)
            
            # Check if better than equipped
            team = self.sim_state.player_team
            equipped = team.equipped_parts.get(part.part_type)
            is_upgrade = False
            if equipped:
                is_upgrade = part.performance_score > equipped.performance_score
            
            # Equip button
            equip_text = "⬆️ UPGRADE" if is_upgrade else "Equip"
            equip_color = FTBTheme.SUCCESS if is_upgrade else FTBTheme.ACCENT
            
            ctk.CTkButton(
                actions_frame,
                text=equip_text,
                command=lambda p=part: self._equip_part_from_inventory(p),
                fg_color=equip_color,
                hover_color=FTBTheme.CARD_HOVER,
                width=80,
                height=28,
                font=("Arial", 10, "bold" if is_upgrade else "normal")
            ).pack(side=tk.LEFT, padx=2)
            
            # Details button
            ctk.CTkButton(
                actions_frame,
                text="Details",
                command=lambda p=part: self._show_part_details(p),
                fg_color=FTBTheme.SURFACE,
                hover_color=FTBTheme.CARD_HOVER,
                width=70,
                height=28,
                font=("Arial", 9)
            ).pack(side=tk.LEFT, padx=2)
            
            # Sell button
            sell_value = int(FTBSimulation.calculate_part_cost(part) * 0.4)  # 40% resale value
            ctk.CTkButton(
                actions_frame,
                text=f"Sell ${sell_value//1000}k",
                command=lambda p=part: self._sell_part(p),
                fg_color=FTBTheme.DANGER,
                hover_color=FTBTheme.CARD_HOVER,
                width=90,
                height=28,
                font=("Arial", 9)
            ).pack(side=tk.LEFT, padx=2)
        
        def _rename_car(self):
            """Open car rename dialog"""
            if not self.sim_state or not self.sim_state.player_team or not self.sim_state.player_team.car:
                return
            
            car = self.sim_state.player_team.car
            
            dialog = ctk.CTkInputDialog(
                text=f"Enter new name for your car:\n(Current: {car.name})",
                title="Rename Car"
            )
            new_name = dialog.get_input()
            
            if new_name and new_name.strip() and len(new_name.strip()) >= 3:
                self.runtime["ftb_cmd_q"].put({
                    "cmd": "ftb_rename_car",
                    "new_name": new_name.strip()
                })
        
        def _show_part_details(self, part):
            """Show detailed part information modal"""
            if not self.sim_state or not self.sim_state.player_team:
                return
            
            # Create modal window
            modal = ctk.CTkToplevel(self)
            modal.title(f"Part Details: {part.name}")
            modal.geometry("600x700")
            modal.configure(fg_color=FTBTheme.BG)
            modal.transient(self)
            modal.grab_set()
            
            # Scrollable content
            scroll = ctk.CTkScrollableFrame(modal, fg_color="transparent")
            scroll.pack(fill=tk.BOTH, expand=True, padx=20, pady=20)
            
            # Header
            header = ctk.CTkFrame(scroll, fg_color=FTBTheme.CARD, corner_radius=8)
            header.pack(fill=tk.X, pady=(0, 15))
            
            ctk.CTkLabel(
                header,
                text=part.name,
                font=("Arial", 18, "bold"),
                text_color=FTBTheme.TEXT
            ).pack(padx=20, pady=15)
            
            # Basic info
            info_card = ctk.CTkFrame(scroll, fg_color=FTBTheme.CARD, corner_radius=8)
            info_card.pack(fill=tk.X, pady=(0, 10))
            
            info_grid = ctk.CTkFrame(info_card, fg_color="transparent")
            info_grid.pack(fill=tk.X, padx=20, pady=15)
            
            info_items = [
                ("Type:", part.part_type.replace('_', ' ').title()),
                ("Manufacturer:", part.manufacturer_id),
                ("Generation:", f"Mk{part.generation}"),
                ("Effectiveness:", f"{part.effectiveness_modifier*100:.0f}%"),
                ("Performance Score:", f"{part.performance_score:.1f}"),
                ("Introduced:", f"Year {part.introduction_year}")
            ]
            
            for i, (label, value) in enumerate(info_items):
                row = ctk.CTkFrame(info_grid, fg_color="transparent")
                row.pack(fill=tk.X, pady=3)
                
                ctk.CTkLabel(
                    row,
                    text=label,
                    font=("Arial", 11, "bold"),
                    text_color=FTBTheme.TEXT_DIM
                ).pack(side=tk.LEFT)
                
                ctk.CTkLabel(
                    row,
                    text=value,
                    font=("Arial", 11),
                    text_color=FTBTheme.TEXT
                ).pack(side=tk.RIGHT)
            
            # Part stats
            stats_card = ctk.CTkFrame(scroll, fg_color=FTBTheme.CARD, corner_radius=8)
            stats_card.pack(fill=tk.X, pady=(0, 10))
            
            ctk.CTkLabel(
                stats_card,
                text="Part Statistics",
                font=("Arial", 14, "bold"),
                text_color=FTBTheme.TEXT
            ).pack(padx=20, pady=(15, 10), anchor="w")
            
            stats_container = ctk.CTkFrame(stats_card, fg_color="transparent")
            stats_container.pack(fill=tk.X, padx=20, pady=(0, 15))
            
            # Diagnostic logging and defensive fallback
            if not part.current_ratings or len(part.current_ratings) == 0:
                part.current_ratings = STATS_SCHEMAS['Part'].copy()
            
            for stat_name, value in part.current_ratings.items():
                StatBar(
                    stats_container,
                    label=stat_name.replace('_', ' ').title(),
                    value=value,
                    max_value=100,
                    width=450,
                    show_value=True
                ).pack(pady=4)
            
            # Compatibility tags
            if part.compatibility_tags:
                compat_card = ctk.CTkFrame(scroll, fg_color=FTBTheme.CARD, corner_radius=8)
                compat_card.pack(fill=tk.X, pady=(0, 10))
                
                ctk.CTkLabel(
                    compat_card,
                    text="Compatibility Tags",
                    font=("Arial", 14, "bold"),
                    text_color=FTBTheme.TEXT
                ).pack(padx=20, pady=(15, 10), anchor="w")
                
                tags_container = ctk.CTkFrame(compat_card, fg_color="transparent")
                tags_container.pack(fill=tk.X, padx=20, pady=(0, 15))
                
                ctk.CTkLabel(
                    tags_container,
                    text=", ".join(part.compatibility_tags),
                    font=("Arial", 10),
                    text_color=FTBTheme.TEXT,
                    wraplength=500
                ).pack(anchor="w")
            
            # Comparison with equipped (if applicable)
            team = self.sim_state.player_team
            equipped = team.equipped_parts.get(part.part_type)
            
            if equipped and equipped.part_id != part.part_id:
                comp_card = ctk.CTkFrame(scroll, fg_color=FTBTheme.CARD, corner_radius=8)
                comp_card.pack(fill=tk.X, pady=(0, 10))
                
                ctk.CTkLabel(
                    comp_card,
                    text="Comparison vs Currently Equipped",
                    font=("Arial", 14, "bold"),
                    text_color=FTBTheme.TEXT
                ).pack(padx=20, pady=(15, 10), anchor="w")
                
                comp_grid = ctk.CTkFrame(comp_card, fg_color="transparent")
                comp_grid.pack(fill=tk.X, padx=20, pady=(0, 15))
                
                perf_delta = part.performance_score - equipped.performance_score
                eff_delta = part.effectiveness_modifier - equipped.effectiveness_modifier
                
                delta_color_perf = FTBTheme.SUCCESS if perf_delta > 0 else FTBTheme.DANGER
                delta_color_eff = FTBTheme.SUCCESS if eff_delta > 0 else FTBTheme.DANGER
                
                ctk.CTkLabel(
                    comp_grid,
                    text=f"Performance: {perf_delta:+.1f} ({'+' if perf_delta > 0 else ''}{perf_delta:.1f})",
                    font=("Arial", 11),
                    text_color=delta_color_perf
                ).pack(pady=2, anchor="w")
                
                ctk.CTkLabel(
                    comp_grid,
                    text=f"Effectiveness: {eff_delta*100:+.0f}% ({'+' if eff_delta > 0 else ''}{eff_delta*100:.0f}%)",
                    font=("Arial", 11),
                    text_color=delta_color_eff
                ).pack(pady=2, anchor="w")
            
            # Close button
            ctk.CTkButton(
                scroll,
                text="Close",
                command=modal.destroy,
                fg_color=FTBTheme.SURFACE,
                hover_color=FTBTheme.CARD_HOVER,
                height=35,
                font=("Arial", 12)
            ).pack(pady=15, fill=tk.X)
        
        def _quick_equip_part(self, part_type):
            """Quick equip first available part of type"""
            if not self.sim_state or not self.sim_state.player_team:
                return
            
            team = self.sim_state.player_team
            inventory_parts = [p for p in team.parts_inventory if p.part_type == part_type]
            
            if inventory_parts:
                # Sort by performance score, equip best
                best_part = max(inventory_parts, key=lambda p: p.performance_score)
                self._equip_part_from_inventory(best_part)
        
        def _equip_part_from_inventory(self, part):
            """Equip a part from inventory"""
            if not self.sim_state or not self.sim_state.player_team:
                return
            
            self.runtime["ftb_cmd_q"].put({
                "cmd": "ftb_equip_part",
                "part_id": part.part_id
            })
        
        def _sell_part(self, part):
            """Sell a part from inventory"""
            if not self.sim_state or not self.sim_state.player_team:
                return
            
            sell_value = int(FTBSimulation.calculate_part_cost(part) * 0.4)
            
            # Confirmation dialog
            confirm = ctk.CTkInputDialog(
                text=f"Sell {part.name} for ${sell_value:,}?\nType 'yes' to confirm:",
                title="Confirm Sale"
            )
            response = confirm.get_input()
            
            if response and response.lower() == 'yes':
                self.runtime["ftb_cmd_q"].put({
                    "cmd": "ftb_sell_part",
                    "part_id": part.part_id
                })
        
        def _build_development_tab(self):
            """Build Development tab - Projects, Infrastructure"""
            tab = self.tab_development
            
            # Two column layout
            left_panel = ctk.CTkScrollableFrame(tab, fg_color="transparent")
            left_panel.pack(side=tk.LEFT, fill=tk.BOTH, expand=True, padx=(0, 5))
            
            right_panel = ctk.CTkScrollableFrame(tab, fg_color="transparent")
            right_panel.pack(side=tk.RIGHT, fill=tk.BOTH, expand=True, padx=(5, 0))
            
            # Left: Active Projects
            projects_header = ctk.CTkFrame(left_panel, fg_color=FTBTheme.CARD, corner_radius=8)
            projects_header.pack(fill=tk.X, pady=(0, 10))
            
            header_frame = ctk.CTkFrame(projects_header, fg_color="transparent")
            header_frame.pack(fill=tk.X, padx=15, pady=15)
            
            ctk.CTkLabel(
                header_frame,
                text="🔧 Active Projects",
                font=("Arial", 16, "bold"),
                text_color=FTBTheme.TEXT
            ).pack(side=tk.LEFT)
            
            ctk.CTkButton(
                header_frame,
                text="↻ Refresh",
                command=self._refresh_development_projects,
                fg_color=FTBTheme.ACCENT,
                hover_color=FTBTheme.ACCENT_HOVER,
                width=100,
                height=28,
                font=("Arial", 11)
            ).pack(side=tk.RIGHT, padx=(10, 0))
            
            ctk.CTkButton(
                header_frame,
                text="+ New Project",
                command=self._start_new_project,
                fg_color=FTBTheme.ACCENT,
                hover_color=FTBTheme.CARD_HOVER,
                width=120,
                height=30,
                font=("Arial", 11, "bold")
            ).pack(side=tk.RIGHT)
            
            self.projects_container = ctk.CTkFrame(left_panel, fg_color="transparent")
            self.projects_container.pack(fill=tk.BOTH, expand=True)
            
            # Right: Infrastructure
            infra_header = ctk.CTkFrame(right_panel, fg_color=FTBTheme.CARD, corner_radius=8)
            infra_header.pack(fill=tk.X, pady=(0, 10))
            
            ctk.CTkLabel(
                infra_header,
                text="🏭 Infrastructure",
                font=("Arial", 16, "bold"),
                text_color=FTBTheme.TEXT
            ).pack(side=tk.LEFT, padx=15, pady=15)
            
            ctk.CTkButton(
                infra_header,
                text="↻ Refresh",
                command=self._refresh_infrastructure,
                fg_color=FTBTheme.ACCENT,
                hover_color=FTBTheme.ACCENT_HOVER,
                width=100,
                height=28,
                font=("Arial", 11)
            ).pack(side=tk.RIGHT, padx=15, pady=15)
            
            self.infrastructure_container = ctk.CTkFrame(right_panel, fg_color="transparent")
            self.infrastructure_container.pack(fill=tk.BOTH, expand=True)
        
        def _refresh_development_projects(self):
            """Update active projects display"""
            if not self.sim_state or not self.sim_state.player_team:
                return
            
            # Clear existing
            for widget in self.projects_container.winfo_children():
                widget.destroy()
            
            active_projects = self.sim_state.player_team.active_rd_projects
            active_projects = [p for p in active_projects if not p.completed and not p.cancelled]
            
            if not active_projects:
                empty_label = ctk.CTkLabel(
                    self.projects_container,
                    text="No active projects.\n\nClick 'New Project' to begin development.",
                    font=("Arial", 13),
                    text_color=FTBTheme.TEXT_MUTED,
                    justify="center"
                )
                empty_label.pack(pady=50)
                return
            
            # Show each project
            for project in active_projects:
                self._add_project_card(self.projects_container, project)
        
        def _add_project_card(self, parent, project):
            """Add a project progress card"""
            card = ctk.CTkFrame(parent, fg_color=FTBTheme.CARD, corner_radius=8)
            card.pack(fill=tk.X, pady=(0, 10))
            
            # Project name and type badge
            header_frame = ctk.CTkFrame(card, fg_color="transparent")
            header_frame.pack(fill=tk.X, padx=15, pady=(15, 5))
            
            ctk.CTkLabel(
                header_frame,
                text=project.project_name,
                font=("Arial", 14, "bold"),
                text_color=FTBTheme.TEXT
            ).pack(side=tk.LEFT)
            
            # Type badge
            type_colors = {
                'car_upgrade': FTBTheme.ACCENT,
                'part_development': FTBTheme.SUCCESS,
                'infrastructure_unlock': FTBTheme.WARNING,
                'infrastructure_upgrade': FTBTheme.WARNING
            }
            type_color = type_colors.get(project.project_type, FTBTheme.TEXT_MUTED)
            
            ctk.CTkLabel(
                header_frame,
                text=project.project_type.replace('_', ' ').upper(),
                font=("Arial", 8, "bold"),
                text_color=FTBTheme.BG,
                fg_color=type_color,
                corner_radius=3,
                padx=6,
                pady=2
            ).pack(side=tk.LEFT, padx=(8, 0))
            
            # Description
            if project.description:
                ctk.CTkLabel(
                    card,
                    text=project.description,
                    font=("Arial", 10),
                    text_color=FTBTheme.TEXT_MUTED,
                    wraplength=400
                ).pack(padx=15, pady=(0, 10), anchor="w")
            
            # Progress calculation
            progress = project.progress_ticks / project.duration_ticks if project.duration_ticks > 0 else 0.0
            progress = max(0.0, min(1.0, progress))
            ticks_remaining = max(0, project.duration_ticks - project.progress_ticks)
            
            # Progress bar
            progress_frame = ctk.CTkFrame(card, fg_color="transparent")
            progress_frame.pack(fill=tk.X, padx=15, pady=10)
            
            progress_bar = ctk.CTkProgressBar(
                progress_frame,
                width=300,
                progress_color=FTBTheme.ACCENT,
                fg_color=FTBTheme.SURFACE
            )
            progress_bar.set(progress)
            progress_bar.pack(fill=tk.X)
            
            progress_label = ctk.CTkLabel(
                progress_frame,
                text=f"{progress*100:.0f}% complete • {ticks_remaining} ticks remaining",
                font=("Arial", 10),
                text_color=FTBTheme.TEXT_MUTED
            )
            progress_label.pack(pady=(5, 0))
            
            # Details
            details_frame = ctk.CTkFrame(card, fg_color=FTBTheme.SURFACE, corner_radius=6)
            details_frame.pack(fill=tk.X, padx=15, pady=(0, 10))
            
            detail_grid = ctk.CTkFrame(details_frame, fg_color="transparent")
            detail_grid.pack(padx=10, pady=10, fill=tk.X)
            
            # Row 1: Cost and Success Rate
            row1 = ctk.CTkFrame(detail_grid, fg_color="transparent")
            row1.pack(fill=tk.X, pady=2)
            
            ctk.CTkLabel(
                row1,
                text=f"💰 Cost: {format_currency(project.total_cost)}",
                font=("Arial", 10),
                text_color=FTBTheme.TEXT_MUTED
            ).pack(side=tk.LEFT, padx=5)
            
            success_color = FTBTheme.SUCCESS if project.current_success_rate >= 0.7 else FTBTheme.WARNING if project.current_success_rate >= 0.5 else FTBTheme.DANGER
            ctk.CTkLabel(
                row1,
                text=f"📊 Success: {project.current_success_rate*100:.1f}%",
                font=("Arial", 10),
                text_color=success_color
            ).pack(side=tk.LEFT, padx=5)
            
            # Row 2: Risk and Duration
            row2 = ctk.CTkFrame(detail_grid, fg_color="transparent")
            row2.pack(fill=tk.X, pady=2)
            
            risk_color = FTBTheme.DANGER if project.risk_level == "high" else FTBTheme.WARNING if project.risk_level == "medium" else FTBTheme.SUCCESS
            ctk.CTkLabel(
                row2,
                text=f"⚠️ Risk: {project.risk_level.title()}",
                font=("Arial", 10),
                text_color=risk_color
            ).pack(side=tk.LEFT, padx=5)
            
            ctk.CTkLabel(
                row2,
                text=f"⏱️ Duration: {project.duration_ticks} ticks",
                font=("Arial", 10),
                text_color=FTBTheme.TEXT_MUTED
            ).pack(side=tk.LEFT, padx=5)
            
            # Row 3: Assigned engineers (if any)
            if project.assigned_engineer_ids:
                row3 = ctk.CTkFrame(detail_grid, fg_color="transparent")
                row3.pack(fill=tk.X, pady=2)
                
                engineer_names = []
                for eng_id in project.assigned_engineer_ids:
                    for eng in self.sim_state.player_team.engineers:
                        if eng.entity_id == eng_id:
                            engineer_names.append(eng.name)
                            break
                
                ctk.CTkLabel(
                    row3,
                    text=f"👥 Engineers: {', '.join(engineer_names) if engineer_names else 'None'}",
                    font=("Arial", 10),
                    text_color=FTBTheme.TEXT
                ).pack(side=tk.LEFT, padx=5)
            
            # Cancel button
            ctk.CTkButton(
                card,
                text="❌ Cancel Project",
                command=lambda p=project: self._cancel_rd_project(p),
                fg_color=FTBTheme.DANGER,
                hover_color="#cc0000",
                height=30,
                width=130,
                font=("Arial", 10)
            ).pack(padx=15, pady=(0, 15), anchor="e")
        
        def _refresh_infrastructure(self):
            """Update infrastructure display"""
            if not self.sim_state or not self.sim_state.player_team:
                return
            if not hasattr(self, 'infrastructure_container') or not self.infrastructure_container:
                return
            try:
                if not self.infrastructure_container.winfo_exists():
                    return
            except (tk.TclError, RuntimeError):
                return
            
            # Clear existing
            try:
                for widget in self.infrastructure_container.winfo_children():
                    widget.destroy()
            except (tk.TclError, RuntimeError):
                return
            
            infra = self.sim_state.player_team.infrastructure
            
            # Show each facility
            for facility_name, quality in infra.items():
                self._add_infrastructure_card(self.infrastructure_container, facility_name, _coerce_float(quality, 0.0))
        
        def _add_infrastructure_card(self, parent, facility_name: str, quality: float):
            """Add an infrastructure facility card"""
            # Skip internal flags like _unlocked
            if facility_name.endswith('_unlocked'):
                return

            quality = _coerce_float(quality, 0.0)
            
            card = ctk.CTkFrame(parent, fg_color=FTBTheme.CARD, corner_radius=8)
            card.pack(fill=tk.X, pady=(0, 10))
            
            # Check if facility is unlocked
            unlock_key = facility_name + '_unlocked'
            is_unlocked = self.sim_state.player_team.infrastructure.get(unlock_key, False)
            
            # Facility name with lock status
            header_frame = ctk.CTkFrame(card, fg_color="transparent")
            header_frame.pack(fill=tk.X, padx=15, pady=(15, 5))
            
            display_name = facility_name.replace('_', ' ').title()
            ctk.CTkLabel(
                header_frame,
                text=display_name,
                font=("Arial", 14, "bold"),
                text_color=FTBTheme.TEXT if is_unlocked else FTBTheme.TEXT_DIM
            ).pack(side=tk.LEFT)
            
            # Lock/unlock badge
            if not is_unlocked:
                ctk.CTkLabel(
                    header_frame,
                    text="🔒 LOCKED",
                    font=("Arial", 9, "bold"),
                    text_color=FTBTheme.BG,
                    fg_color=FTBTheme.DANGER,
                    corner_radius=3,
                    padx=6,
                    pady=2
                ).pack(side=tk.LEFT, padx=(8, 0))
            
            if is_unlocked:
                # Quality bar
                quality_color = FTBTheme.get_stat_color(quality)
                stat_bar = StatBar(
                    card,
                    label="Quality",
                    value=quality,
                    max_value=100.0,
                    show_value=True
                )
                stat_bar.pack(fill=tk.X, padx=15, pady=5)
                
                # Upkeep cost
                from plugins.ftb_game import INFRASTRUCTURE_UPKEEP_COST
                upkeep_func = INFRASTRUCTURE_UPKEEP_COST.get(facility_name)
                if upkeep_func:
                    upkeep = upkeep_func(quality)
                    ctk.CTkLabel(
                        card,
                        text=f"💰 Upkeep: {format_currency(upkeep)}/tick",
                        font=("Arial", 10),
                        text_color=FTBTheme.TEXT_MUTED
                    ).pack(padx=15, pady=2, anchor="w")
                
                # Benefits info
                benefits_text = ""
                if facility_name == "factory_quality":
                    benefits_text = "⚡ Speeds all projects, improves success rates"
                elif facility_name == "wind_tunnel":
                    benefits_text = "🌪️ Boosts aero project success rates"
                elif facility_name == "simulator":
                    benefits_text = "🎮 Enhances driveability & systems projects"
                
                if benefits_text:
                    ctk.CTkLabel(
                        card,
                        text=benefits_text,
                        font=("Arial", 9, "italic"),
                        text_color=FTBTheme.TEXT_MUTED
                    ).pack(padx=15, pady=2, anchor="w")
                
                # Upgrade cost estimate (aligned with direct upgrade economics)
                base_cost_per_point = get_facility_base_cost_per_point(facility_name)
                upgrade_exponent = INFRASTRUCTURE_EFFECTS['direct_upgrade_cost_exponent']
                quality_for_cost = max(50.0, quality)
                upgrade_cost = int(base_cost_per_point * ((quality_for_cost / 50.0) ** upgrade_exponent) * 10.0)
                
                # Actions
                actions_frame = ctk.CTkFrame(card, fg_color="transparent")
                actions_frame.pack(fill=tk.X, padx=15, pady=(10, 15))
                
                if quality < 100:
                    ctk.CTkButton(
                        actions_frame,
                        text=f"⬆️ Upgrade +10 ({format_currency(upgrade_cost)})",
                        command=lambda f=facility_name, c=upgrade_cost: self._upgrade_infrastructure(f, c),
                        fg_color=FTBTheme.ACCENT,
                        hover_color=FTBTheme.CARD_HOVER,
                        height=32,
                        font=("Arial", 11)
                    ).pack(side=tk.LEFT, padx=(0, 8))
                else:
                    ctk.CTkLabel(
                        actions_frame,
                        text="✓ Max Quality",
                        font=("Arial", 11, "bold"),
                        text_color=FTBTheme.SUCCESS
                    ).pack(side=tk.LEFT, padx=(0, 8))
                
                # Sell button (always available for unlocked facilities with quality > 0)
                if quality > 0:
                    # Determine facility tier for warning
                    from plugins.ftb_game import FACILITY_TIER_MAP
                    facility_tier = FACILITY_TIER_MAP.get(facility_name, 1)
                    
                    # Estimate recovery cash
                    base_cost_per_point = get_facility_base_cost_per_point(facility_name)
                    avg_quality_factor = (quality / 50.0) ** 1.4
                    estimated_rebuild_cost = base_cost_per_point * avg_quality_factor * quality
                    recovery_ratio = FACILITY_SELL_RECOVERY.get(facility_tier, 0.35)
                    recovery_cash = estimated_rebuild_cost * recovery_ratio
                    if facility_tier == 5:
                        recovery_cash *= 0.85
                    
                    # Danger color for Formula Z facilities
                    sell_btn_color = FTBTheme.DANGER if facility_tier >= 5 else FTBTheme.WARNING
                    sell_btn_hover = FTBTheme.DANGER_HOVER if facility_tier >= 5 else FTBTheme.WARNING_HOVER
                    sell_btn_text = "⚠️ SELL" if facility_tier >= 4 else "💰 Sell"
                    
                    ctk.CTkButton(
                        actions_frame,
                        text=f"{sell_btn_text} ({format_currency(recovery_cash)})",
                        command=lambda f=facility_name, q=quality, t=facility_tier: self._sell_infrastructure(f, q, t),
                        fg_color=sell_btn_color,
                        hover_color=sell_btn_hover,
                        height=32,
                        font=("Arial", 11)
                    ).pack(side=tk.LEFT)
            else:
                # Locked facility - show unlock info
                info_frame = ctk.CTkFrame(card, fg_color=FTBTheme.SURFACE, corner_radius=6)
                info_frame.pack(fill=tk.X, padx=15, pady=10)
                
                ctk.CTkLabel(
                    info_frame,
                    text="This facility must be unlocked through an R&D project.\nStart an infrastructure unlock project from the development wizard.",
                    font=("Arial", 10),
                    text_color=FTBTheme.TEXT_MUTED,
                    wraplength=350,
                    justify="left"
                ).pack(padx=10, pady=10)
        
        def _refresh_parts_marketplace(self):
            """Update parts marketplace display with filtering, sorting, and search"""
            if not self.sim_state or not self.sim_state.player_team:
                return
            
            # Clear existing
            for widget in self.parts_marketplace_container.winfo_children():
                widget.destroy()
            
            team = self.sim_state.player_team
            catalog = self.sim_state.parts_catalog
            
            # Get available part types for this tier
            available_types = {ptype: tiers for ptype, tiers in PART_TYPES.items() if team.tier in tiers}
            
            if not catalog:
                empty_label = ctk.CTkLabel(
                    self.parts_marketplace_container,
                    text="No parts available in catalog",
                    font=("Arial", 12),
                    text_color=FTBTheme.TEXT_DIM
                )
                empty_label.pack(pady=20)
                return
            
            # Filter parts
            filtered_parts = []
            manufacturers = set()
            part_types_available = set()
            
            for part in catalog.values():
                # Filter by tier access
                if team.tier < part.tier_minimum or team.tier > part.tier_maximum:
                    continue
                # Filter obsolete parts (effectiveness < 50%)
                if part.effectiveness_modifier < 0.5:
                    continue
                # Skip already owned
                if part.part_id in [p.part_id for p in team.parts_inventory]:
                    continue
                # Skip already equipped
                if part.part_id in [p.part_id for p in team.equipped_parts.values() if p]:
                    continue
                # Check if part type is available for this tier
                if part.part_type not in available_types:
                    continue
                
                filtered_parts.append(part)
                manufacturers.add(part.manufacturer_id)
                part_types_available.add(part.part_type)
            
            # Update filter dropdowns with available options
            if hasattr(self, 'marketplace_type_filter'):
                type_options = ["All Types"] + sorted([t.replace('_', ' ').title() for t in part_types_available])
                current_type = self.marketplace_type_var.get()
                self.marketplace_type_filter.configure(values=type_options)
                if current_type not in type_options:
                    self.marketplace_type_var.set("All Types")
            
            if hasattr(self, 'marketplace_mfr_filter'):
                mfr_options = ["All Brands"] + sorted(list(manufacturers))
                current_mfr = self.marketplace_mfr_var.get()
                self.marketplace_mfr_filter.configure(values=mfr_options)
                if current_mfr not in mfr_options:
                    self.marketplace_mfr_var.set("All Brands")
            
            # Apply filters
            selected_type = self.marketplace_type_var.get() if hasattr(self, 'marketplace_type_var') else "All Types"
            selected_mfr = self.marketplace_mfr_var.get() if hasattr(self, 'marketplace_mfr_var') else "All Brands"
            search_text = self.marketplace_search_var.get().lower() if hasattr(self, 'marketplace_search_var') else ""
            
            if selected_type != "All Types":
                selected_type_key = selected_type.lower().replace(' ', '_')
                filtered_parts = [p for p in filtered_parts if p.part_type == selected_type_key]
            
            if selected_mfr != "All Brands":
                filtered_parts = [p for p in filtered_parts if p.manufacturer_id == selected_mfr]
            
            if search_text:
                filtered_parts = [p for p in filtered_parts if 
                    search_text in p.name.lower() or 
                    search_text in p.manufacturer_id.lower() or
                    search_text in p.part_type.lower()]
            
            # Apply sorting
            sort_mode = self.marketplace_sort_var.get() if hasattr(self, 'marketplace_sort_var') else "Latest"
            
            if sort_mode == "Latest":
                filtered_parts.sort(key=lambda p: (p.generation, p.introduction_tick), reverse=True)
            elif sort_mode == "Performance":
                filtered_parts.sort(key=lambda p: p.performance_score, reverse=True)
            elif sort_mode == "Price (Low)":
                filtered_parts.sort(key=lambda p: FTBSimulation.calculate_part_cost(p))
            elif sort_mode == "Price (High)":
                filtered_parts.sort(key=lambda p: FTBSimulation.calculate_part_cost(p), reverse=True)
            elif sort_mode == "Manufacturer":
                filtered_parts.sort(key=lambda p: (p.manufacturer_id, p.part_type, p.generation))
            
            # Check if no parts remain after filtering
            if not filtered_parts:
                empty_label = ctk.CTkLabel(
                    self.parts_marketplace_container,
                    text="No parts match your search criteria",
                    font=("Arial", 12),
                    text_color=FTBTheme.TEXT_DIM
                )
                empty_label.pack(pady=20)
                return
            
            # Display results count
            results_header = ctk.CTkFrame(self.parts_marketplace_container, fg_color=FTBTheme.SURFACE, corner_radius=6)
            results_header.pack(fill=tk.X, pady=(0, 10))
            
            ctk.CTkLabel(
                results_header,
                text=f"{len(filtered_parts)} parts available",
                font=("Arial", 11, "bold"),
                text_color=FTBTheme.TEXT
            ).pack(padx=12, pady=8, side=tk.LEFT)
            
            # Show balance
            balance_text = f"Budget: {format_currency(team.budget.cash)}"
            ctk.CTkLabel(
                results_header,
                text=balance_text,
                font=("Arial", 11),
                text_color=FTBTheme.TEXT_MUTED
            ).pack(padx=12, pady=8, side=tk.RIGHT)
            
            # Display all filtered parts as cards
            for part in filtered_parts:
                self._create_marketplace_part_card(self.parts_marketplace_container, part)
        
        def _create_marketplace_part_card(self, parent, part):
            """Create an enhanced marketplace part card with purchase option"""
            card = ctk.CTkFrame(parent, fg_color=FTBTheme.SURFACE, corner_radius=6)
            card.pack(fill=tk.X, padx=5, pady=5)
            
            content = ctk.CTkFrame(card, fg_color="transparent")
            content.pack(fill=tk.X, padx=12, pady=10)
            
            # Top row: Name, badges, and generation
            top_row = ctk.CTkFrame(content, fg_color="transparent")
            top_row.pack(fill=tk.X, pady=(0, 6))
            
            # Part name and type
            name_frame = ctk.CTkFrame(top_row, fg_color="transparent")
            name_frame.pack(side=tk.LEFT, fill=tk.X, expand=True)
            
            ctk.CTkLabel(
                name_frame,
                text=part.name,
                font=("Arial", 12, "bold"),
                text_color=FTBTheme.TEXT,
                anchor="w"
            ).pack(side=tk.LEFT)
            
            # Part type badge
            ctk.CTkLabel(
                name_frame,
                text=part.part_type.replace('_', ' ').title(),
                font=("Arial", 8),
                text_color=FTBTheme.TEXT_MUTED,
                fg_color=FTBTheme.CARD,
                corner_radius=3,
                padx=6,
                pady=2
            ).pack(side=tk.LEFT, padx=(8, 0))
            
            # Generation badge (right side)
            gen_color = FTBTheme.SUCCESS if part.generation >= 3 else (FTBTheme.ACCENT if part.generation >= 2 else FTBTheme.TEXT_MUTED)
            ctk.CTkLabel(
                top_row,
                text=f"Gen {part.generation}",
                font=("Arial", 10, "bold"),
                text_color=FTBTheme.BG,
                fg_color=gen_color,
                corner_radius=4,
                padx=8,
                pady=3
            ).pack(side=tk.RIGHT, padx=(8, 0))
            
            # NEW badge if recently introduced
            if self.sim_state.tick - part.introduction_tick < 14:  # Within 2 weeks
                ctk.CTkLabel(
                    top_row,
                    text="NEW",
                    font=("Arial", 9, "bold"),
                    text_color=FTBTheme.BG,
                    fg_color=FTBTheme.ACCENT,
                    corner_radius=4,
                    padx=6,
                    pady=3
                ).pack(side=tk.RIGHT)
            
            # Middle row: Manufacturer and stats
            mid_row = ctk.CTkFrame(content, fg_color="transparent")
            mid_row.pack(fill=tk.X, pady=(0, 8))
            
            # Manufacturer
            ctk.CTkLabel(
                mid_row,
                text=f"🏭 {part.manufacturer_id}",
                font=("Arial", 10),
                text_color=FTBTheme.TEXT_DIM,
                anchor="w"
            ).pack(side=tk.LEFT)
            
            # Stats preview
            stats_frame = ctk.CTkFrame(mid_row, fg_color="transparent")
            stats_frame.pack(side=tk.LEFT, padx=(20, 0))
            
            # Performance score
            perf_score = part.performance_score
            score_color = FTBTheme.get_stat_color(perf_score)
            ctk.CTkLabel(
                stats_frame,
                text=f"⚡ {perf_score:.1f}",
                font=("Arial", 10, "bold"),
                text_color=score_color
            ).pack(side=tk.LEFT, padx=(0, 12))
            
            # Reliability
            reliability = part.current_ratings.get('reliability', 50)
            rel_color = FTBTheme.get_stat_color(reliability)
            ctk.CTkLabel(
                stats_frame,
                text=f"🛡️ {reliability:.0f}",
                font=("Arial", 10),
                text_color=rel_color
            ).pack(side=tk.LEFT, padx=(0, 12))
            
            # Effectiveness
            eff_percent = part.effectiveness_modifier * 100
            eff_color = FTBTheme.SUCCESS if part.effectiveness_modifier >= 0.9 else (FTBTheme.TEXT if part.effectiveness_modifier >= 0.7 else FTBTheme.WARNING)
            ctk.CTkLabel(
                stats_frame,
                text=f"📊 {eff_percent:.0f}%",
                font=("Arial", 10),
                text_color=eff_color
            ).pack(side=tk.LEFT)
            
            # Upgrade indicator
            team = self.sim_state.player_team
            prev_gen_owned = False
            for inventory_part in team.parts_inventory + list(team.equipped_parts.values()):
                if inventory_part and \
                   inventory_part.part_type == part.part_type and \
                   inventory_part.manufacturer_id == part.manufacturer_id and \
                   inventory_part.generation == part.generation - 1:
                    prev_gen_owned = True
                    break
            
            if prev_gen_owned:
                ctk.CTkLabel(
                    mid_row,
                    text=f"⬆️ UPGRADE",
                    font=("Arial", 9, "bold"),
                    text_color=FTBTheme.BG,
                    fg_color=FTBTheme.SUCCESS,
                    corner_radius=3,
                    padx=6,
                    pady=2
                ).pack(side=tk.RIGHT, padx=(8, 0))
            
            # Bottom row: Price and actions
            bottom_row = ctk.CTkFrame(content, fg_color=FTBTheme.CARD, corner_radius=4)
            bottom_row.pack(fill=tk.X, pady=(0, 0))
            
            # Calculate cost
            cost = int(FTBSimulation.calculate_part_cost(part))
            can_afford = self.sim_state.player_team.budget.cash >= cost
            
            # Price display
            price_frame = ctk.CTkFrame(bottom_row, fg_color="transparent")
            price_frame.pack(side=tk.LEFT, padx=10, pady=8)
            
            ctk.CTkLabel(
                price_frame,
                text="Price:",
                font=("Arial", 9),
                text_color=FTBTheme.TEXT_MUTED
            ).pack(side=tk.LEFT, padx=(0, 4))
            
            price_color = FTBTheme.TEXT if can_afford else FTBTheme.WARNING
            ctk.CTkLabel(
                price_frame,
                text=format_currency(cost),
                font=("Arial", 11, "bold"),
                text_color=price_color
            ).pack(side=tk.LEFT)
            
            # Action buttons
            actions_frame = ctk.CTkFrame(bottom_row, fg_color="transparent")
            actions_frame.pack(side=tk.RIGHT, padx=8, pady=6)
            
            # Details button
            ctk.CTkButton(
                actions_frame,
                text="📋 Details",
                command=lambda p=part: self._show_part_details(p),
                fg_color=FTBTheme.SURFACE,
                hover_color=FTBTheme.CARD_HOVER,
                width=90,
                height=30,
                font=("Arial", 10),
                border_width=1,
                border_color=FTBTheme.CARD_HOVER
            ).pack(side=tk.LEFT, padx=3)
            
            # Purchase button
            purchase_btn = ctk.CTkButton(
                actions_frame,
                text=f"🛒 Buy" if can_afford else "❌ Too Expensive",
                command=lambda p=part, c=cost: self._purchase_part(p, c),
                fg_color=FTBTheme.ACCENT if can_afford else FTBTheme.SURFACE,
                hover_color=FTBTheme.SUCCESS if can_afford else FTBTheme.SURFACE,
                width=110,
                height=30,
                font=("Arial", 10, "bold" if can_afford else "normal"),
                state="normal" if can_afford else "disabled",
                border_width=0 if can_afford else 1,
                border_color=FTBTheme.WARNING if not can_afford else None
            )
            purchase_btn.pack(side=tk.LEFT, padx=3)
        
        def _purchase_part(self, part, cost):
            """Purchase a part and add to inventory with confirmation"""
            if not self.sim_state or not self.sim_state.player_team:
                return
            
            team = self.sim_state.player_team
            
            if team.budget.cash < cost:
                messagebox.showwarning("Insufficient Funds", f"Cannot afford {part.name}. Need {format_currency(cost)}.", parent=self)
                return
            
            # Show confirmation dialog
            remaining_cash = team.budget.cash - cost
            msg = f"Purchase {part.name}?\n\n"
            msg += f"Cost: {format_currency(cost)}\n"
            msg += f"Cash remaining: {format_currency(remaining_cash)}\n\n"
            msg += f"Generation: MK{part.generation}\n"
            msg += f"Performance: {part.performance_score:.1f}\n"
            msg += f"Manufacturer: {part.manufacturer_id}"
            
            confirm = messagebox.askyesno(
                "Confirm Purchase", 
                msg,
                parent=self
            )
            
            if not confirm:
                return
            
            # Send purchase command (processed asynchronously by controller)
            self.runtime["ftb_cmd_q"].put({
                "cmd": "ftb_purchase_part",
                "part_id": part.part_id,
                "cost": cost
            })
            
            # Show success message (command will complete shortly)
            messagebox.showinfo(
                "Purchase Queued",
                f"Purchasing {part.name}...\n\nIt will appear in your Parts Inventory momentarily.",
                parent=self
            )
        
        def _start_new_project(self):
            """Open development wizard"""
            if not self.sim_state or not self.sim_state.player_team:
                messagebox.showwarning("No Team", "You need a team first!", parent=self)
                return
            
            available_engineers = self.sim_state.player_team.engineers
            budget = self.sim_state.player_team.budget.cash
            
            def on_submit(config):
                # Send command to controller
                self.runtime["ftb_cmd_q"].put({
                    "cmd": "ftb_start_development",
                    "config": config
                })
                self._refresh_development_projects()
            
            DevelopmentWizard(self, available_engineers, budget, on_submit)
        
        def _cancel_rd_project(self, project):
            """Cancel an R&D project"""
            def confirm_cancel():
                self.runtime["ftb_cmd_q"].put({
                    "cmd": "ftb_cancel_rd_project",
                    "project_id": project.project_id
                })
                self._refresh_development_projects()
            
            ConfirmDialog(
                self,
                title="Cancel Project",
                message=f"Cancel '{project.project_name}'?\n\nProgress will be lost and no refund will be given.",
                on_confirm=confirm_cancel,
                confirm_text="Cancel Project",
                cancel_text="Keep Working"
            )
        
        def _upgrade_infrastructure(self, facility_name: str, cost: float):
            """Launch upgrade wizard for infrastructure facility"""
            if not self.sim_state or not self.sim_state.player_team:
                return
            
            current_quality = self.sim_state.player_team.infrastructure.get(facility_name, 0.0)
            
            # Get available engineers for R&D path
            available_engineers = []
            if hasattr(self.sim_state.player_team, 'engineers'):
                available_engineers = self.sim_state.player_team.engineers
            
            def on_submit(config):
                # Route command based on path
                if config['path'] == 'direct':
                    self.runtime["ftb_cmd_q"].put({
                        "cmd": "ftb_upgrade_infrastructure",
                        "facility": config['facility'],
                        "amount": config['amount']
                    })
                else:  # R&D path
                    self.runtime["ftb_cmd_q"].put({
                        "cmd": "ftb_start_development",
                        "config": config
                    })
                # Don't refresh immediately - let dirty flag trigger refresh
                # self._refresh_infrastructure()
            
            # Launch UpgradeWizard
            try:
                UpgradeWizard(
                    self,
                    facility_key=facility_name,
                    current_quality=current_quality,
                    team=self.sim_state.player_team,
                    state=self.sim_state,
                    available_engineers=available_engineers,
                    on_submit=on_submit
                )
            except Exception as e:
                _dbg(f"[FTB] ERROR launching UpgradeWizard: {e}")
                import traceback
                traceback.print_exc()
                messagebox.showerror("Error", f"Failed to open upgrade wizard: {e}", parent=self)
        
        def _sell_infrastructure(self, facility_name: str, quality: float, tier: int):
            """Sell infrastructure facility for emergency cash"""
            if not self.sim_state or not self.sim_state.player_team:
                return
            
            # Build warning message based on tier
            display_name = facility_name.replace('_', ' ').title()
            tier_names = {1: "Grassroots", 2: "Formula V", 4: "Formula Y", 5: "Formula Z"}
            tier_name = tier_names.get(tier, "Unknown")
            
            # Calculate recovery estimate
            base_cost_per_point = get_facility_base_cost_per_point(facility_name)
            avg_quality_factor = (quality / 50.0) ** 1.4
            estimated_rebuild_cost = base_cost_per_point * avg_quality_factor * quality
            recovery_ratio = FACILITY_SELL_RECOVERY.get(tier, 0.35)
            recovery_cash = estimated_rebuild_cost * recovery_ratio
            if tier == 5:
                recovery_cash *= 0.85
            
            # Build consequences message
            consequences = "\n\nCONSEQUENCES:\n"
            consequences += "• Facility quality drops to 0\n"
            consequences += "• Performance suffers immediately\n"
            
            if tier >= 4:
                consequences += "• ⚠️ SPONSORS may lose confidence\n"
                consequences += "• ⚠️ Staff development slows\n"
            if tier == 5:
                consequences += "• ⚠️⚠️ CRITICAL ASSET - Elite sponsors will flee!\n"
                consequences += "• ⚠️⚠️ This is a DESPERATE move!\n"
            
            consequences += "\nYou can rebuild later, but at high cost."
            
            msg = f"Sell {display_name}?\n\n"
            msg += f"Tier: {tier_name}\n"
            msg += f"Current Quality: {quality:.0f}\n"
            msg += f"Recovery: {format_currency(recovery_cash)} (~{int(recovery_ratio*100)}% of rebuild cost)\n"
            msg += consequences
            
            title = "⚠️ SELL CRITICAL ASSET" if tier >= 5 else "Sell Infrastructure"
            
            if messagebox.askyesno(title, msg, parent=self, icon='warning'):
                self.runtime["ftb_cmd_q"].put({
                    "cmd": "ftb_sell_infrastructure",
                    "facility": facility_name
                })
                self._refresh_infrastructure()
        
        def _build_finance_tab(self):
            """Build Finance tab - Budget Dashboard, Loans"""
            tab = self.tab_finance
            
            # Main scrollable container
            container = ctk.CTkScrollableFrame(tab, fg_color="transparent")
            container.pack(fill=tk.BOTH, expand=True)
            
            # Budget Overview
            overview_card = ctk.CTkFrame(container, fg_color=FTBTheme.CARD, corner_radius=8)
            overview_card.pack(fill=tk.X, padx=10, pady=(10, 10))

            # Header with refresh button
            overview_header = ctk.CTkFrame(overview_card, fg_color="transparent")
            overview_header.pack(fill=tk.X, padx=15, pady=(15, 10))

            ctk.CTkLabel(
                overview_header,
                text="💰 Financial Overview",
                font=("Arial", 16, "bold"),
                text_color=FTBTheme.TEXT
            ).pack(side=tk.LEFT)

            ctk.CTkButton(
                overview_header,
                text="🔄 Refresh",
                command=self._refresh_finance,
                fg_color=FTBTheme.ACCENT,
                hover_color=FTBTheme.ACCENT_HOVER,
                width=100,
                height=30,
                font=("Arial", 11)
            ).pack(side=tk.RIGHT)            # Metrics grid
            metrics_grid = ctk.CTkFrame(overview_card, fg_color="transparent")
            metrics_grid.pack(fill=tk.X, padx=15, pady=(0, 15))
            
            self.cash_metric = MetricDisplay(
                metrics_grid,
                label="Current Cash",
                value="$0",
                color=FTBTheme.TEXT
            )
            self.cash_metric.pack(side=tk.LEFT, fill=tk.BOTH, expand=True, padx=5)
            
            self.burn_metric = MetricDisplay(
                metrics_grid,
                label="Weekly Burn",
                value="$0",
                color=FTBTheme.DANGER,
                sublabel="per week"
            )
            self.burn_metric.pack(side=tk.LEFT, fill=tk.BOTH, expand=True, padx=5)
            
            self.runway_finance_metric = MetricDisplay(
                metrics_grid,
                label="Runway",
                value="--",
                color=FTBTheme.TEXT_MUTED,
                sublabel="weeks"
            )
            self.runway_finance_metric.pack(side=tk.LEFT, fill=tk.BOTH, expand=True, padx=5)
            
            # Breakdown section
            breakdown_card = ctk.CTkFrame(container, fg_color=FTBTheme.CARD, corner_radius=8)
            breakdown_card.pack(fill=tk.X, padx=10, pady=(0, 10))
            
            ctk.CTkLabel(
                breakdown_card,
                text="📊 Expense Breakdown",
                font=("Arial", 14, "bold"),
                text_color=FTBTheme.TEXT
            ).pack(padx=15, pady=(15, 10), anchor="w")
            
            self.expense_container = ctk.CTkFrame(breakdown_card, fg_color="transparent")
            self.expense_container.pack(fill=tk.X, padx=15, pady=(0, 15))
            
            # Income section
            income_card = ctk.CTkFrame(container, fg_color=FTBTheme.CARD, corner_radius=8)
            income_card.pack(fill=tk.X, padx=10, pady=(0, 10))
            
            ctk.CTkLabel(
                income_card,
                text="💵 Income Streams",
                font=("Arial", 14, "bold"),
                text_color=FTBTheme.TEXT
            ).pack(padx=15, pady=(15, 10), anchor="w")
            
            self.income_container = ctk.CTkFrame(income_card, fg_color="transparent")
            self.income_container.pack(fill=tk.X, padx=15, pady=(0, 15))
            
            # Actions section
            actions_card = ctk.CTkFrame(container, fg_color=FTBTheme.CARD, corner_radius=8)
            actions_card.pack(fill=tk.X, padx=10, pady=(0, 10))
            
            ctk.CTkLabel(
                actions_card,
                text="⚙️ Financial Actions",
                font=("Arial", 14, "bold"),
                text_color=FTBTheme.TEXT
            ).pack(padx=15, pady=(15, 10), anchor="w")
            
        def _refresh_finance(self):
            """Update finance tab with current budget data"""
            if not self.sim_state or not self.sim_state.player_team:
                return
            
            team = self.sim_state.player_team
            budget = team.budget

            team.ensure_staff_salaries()
            
            # Update metrics
            self.cash_metric.update(format_currency(budget.cash), FTBTheme.TEXT)
            
            # Calculate weekly burn (assuming 7 ticks per week)
            payroll = budget.calculate_staff_payroll()
            infra_upkeep = sum(
                INFRASTRUCTURE_UPKEEP_COST.get(k, lambda x: 0)(v)
                for k, v in team.infrastructure.items()
                if not k.endswith('_unlocked') and team.infrastructure.get(f"{k}_unlocked", False) and k in INFRASTRUCTURE_UPKEEP_COST
            )
            weekly_burn = (payroll + infra_upkeep + budget.burn_rate) * 7
            
            burn_color = FTBTheme.DANGER if weekly_burn > budget.cash / 10 else FTBTheme.WARNING
            self.burn_metric.update(format_currency(weekly_burn), burn_color, "per week")
            
            # Update runway
            runway = FTBSimulation.calculate_cash_runway(team)
            if runway == float('inf'):
                self.runway_finance_metric.update("∞", FTBTheme.SUCCESS, "No burn")
            else:
                runway_color = FTBTheme.DANGER if runway < 10 else FTBTheme.WARNING if runway < 30 else FTBTheme.SUCCESS
                self.runway_finance_metric.update(f"{runway:.1f}", runway_color, "weeks")
            
            # Update expense breakdown
            for widget in self.expense_container.winfo_children():
                widget.destroy()
            
            expenses = [
                ("Payroll", payroll),
                ("Infrastructure", infra_upkeep),
                ("Operations", budget.burn_rate)
            ]
            
            total_expenses = sum(e[1] for e in expenses)
            
            for name, amount in expenses:
                if total_expenses > 0:
                    percentage = (amount / total_expenses) * 100
                else:
                    percentage = 0
                
                expense_row = ctk.CTkFrame(self.expense_container, fg_color=FTBTheme.SURFACE, corner_radius=6)
                expense_row.pack(fill=tk.X, pady=3)
                
                ctk.CTkLabel(
                    expense_row,
                    text=name,
                    font=("Arial", 11),
                    text_color=FTBTheme.TEXT,
                    anchor="w"
                ).pack(side=tk.LEFT, padx=10, pady=8)
                
                ctk.CTkLabel(
                    expense_row,
                    text=f"{format_currency(amount)}/tick",
                    font=("Arial", 11, "bold"),
                    text_color=FTBTheme.TEXT_MUTED,
                    anchor="e"
                ).pack(side=tk.RIGHT, padx=10, pady=8)
                
                ctk.CTkLabel(
                    expense_row,
                    text=f"{percentage:.0f}%",
                    font=("Arial", 10),
                    text_color=FTBTheme.TEXT_DIM,
                    anchor="e",
                    width=50
                ).pack(side=tk.RIGHT, padx=(10, 0), pady=8)
            
            # Update income streams
            for widget in self.income_container.winfo_children():
                widget.destroy()

            display_streams = list(budget.income_streams)

            # Add sponsor income estimates as per-tick display items
            if hasattr(self.sim_state, 'sponsorships') and team.name in self.sim_state.sponsorships:
                economic_multiplier = getattr(self.sim_state, 'economic_state', {}).get('sponsor_market_multiplier', 1.0)
                for sponsor in self.sim_state.sponsorships.get(team.name, []):
                    monthly_base = sponsor.base_payment_per_season // 12
                    perf_multiplier = 0.5 + (sponsor.confidence / 100.0)
                    perf_multiplier = max(0.5, min(2.0, perf_multiplier))
                    estimated_monthly = int(monthly_base * perf_multiplier * economic_multiplier)
                    per_tick = estimated_monthly / 30.0
                    display_streams.append(
                        IncomeSource(
                            name=f"Sponsor: {sponsor.sponsor_name}",
                            amount=per_tick,
                            frequency="per tick (est.)"
                        )
                    )

            if display_streams:
                for income in display_streams:
                    income_row = ctk.CTkFrame(self.income_container, fg_color=FTBTheme.SURFACE, corner_radius=6)
                    income_row.pack(fill=tk.X, pady=3)
                    
                    ctk.CTkLabel(
                        income_row,
                        text=income.name,
                        font=("Arial", 11),
                        text_color=FTBTheme.TEXT,
                        anchor="w"
                    ).pack(side=tk.LEFT, padx=10, pady=8)
                    
                    ctk.CTkLabel(
                        income_row,
                        text=f"{format_currency(income.amount)} ({income.frequency})",
                        font=("Arial", 11, "bold"),
                        text_color=FTBTheme.SUCCESS,
                        anchor="e"
                    ).pack(side=tk.RIGHT, padx=10, pady=8)
            else:
                ctk.CTkLabel(
                    self.income_container,
                    text="No active income streams",
                    font=("Arial", 11),
                    text_color=FTBTheme.TEXT_MUTED
                ).pack(pady=10)
        
        def _show_cost_cutting(self):
            """Show cost-cutting wizard - placeholder"""
            messagebox.showinfo(
                "Cost-Cutting Wizard",
                "Cost-cutting wizard coming soon.\n\nWill help identify and implement expense reductions.",
                parent=self
            )
        
        def _request_loan(self):
            """Request loan - placeholder"""
            messagebox.showinfo(
                "Request Loan",
                "Loan system coming soon.\n\nWill allow borrowing funds with interest and repayment terms.",
                parent=self
            )
        
        def _seek_investment(self):
            """Seek investment - placeholder"""
            messagebox.showinfo(
                "Seek Investment",
                "Investment system coming soon.\n\nWill allow raising capital in exchange for equity.",
                parent=self
            )
        
        def _build_race_ops_tab(self):
            """Build Race Operations tab - Race Status, Driver Lineup, Results"""
            tab = self.tab_race_ops
            
            # Main scrollable container
            container = ctk.CTkScrollableFrame(tab, fg_color="transparent")
            container.pack(fill=tk.BOTH, expand=True)
            
            # Race Status Card
            status_card = ctk.CTkFrame(container, fg_color=FTBTheme.CARD, corner_radius=8)
            status_card.pack(fill=tk.X, padx=10, pady=(10, 10))
            
            ctk.CTkLabel(
                status_card,
                text="🏁 Race Weekend Status",
                font=("Arial", 16, "bold"),
                text_color=FTBTheme.TEXT
            ).pack(padx=15, pady=(15, 10), anchor="w")
            
            # Phase indicator
            self.race_phase_label = ctk.CTkLabel(
                status_card,
                text="Phase: --",
                font=("Arial", 12),
                text_color=FTBTheme.TEXT
            )
            self.race_phase_label.pack(padx=15, pady=5, anchor="w")
            
            self.race_countdown_label = ctk.CTkLabel(
                status_card,
                text="Next race: --",
                font=("Arial", 11),
                text_color=FTBTheme.TEXT_MUTED
            )
            self.race_countdown_label.pack(padx=15, pady=(0, 15), anchor="w")

            # Live Race Play button (hidden by default, shown when quali complete)
            self.live_race_btn = ctk.CTkButton(
                status_card,
                text="▶️  Play Live Race",
                font=("Arial", 14, "bold"),
                fg_color="#00aa44",
                hover_color="#00cc55",
                text_color="#ffffff",
                height=40,
                corner_radius=8,
                command=self._on_play_live_race
            )
            # Don't pack yet — shown dynamically by _refresh_race_ops

            # Track Info Card
            track_card = ctk.CTkFrame(container, fg_color=FTBTheme.CARD, corner_radius=8)
            track_card.pack(fill=tk.X, padx=10, pady=(0, 10))

            ctk.CTkLabel(
                track_card,
                text="🗺️ Track Info",
                font=("Arial", 14, "bold"),
                text_color=FTBTheme.TEXT
            ).pack(padx=15, pady=(15, 8), anchor="w")

            self.track_info_name_label = ctk.CTkLabel(
                track_card,
                text="Next Track: --",
                font=("Arial", 12, "bold"),
                text_color=FTBTheme.TEXT
            )
            self.track_info_name_label.pack(padx=15, pady=(0, 4), anchor="w")

            self.track_info_meta_label = ctk.CTkLabel(
                track_card,
                text="Type: --  |  Length: --  |  Corners: --  |  Laps: --",
                font=("Arial", 10),
                text_color=FTBTheme.TEXT_MUTED
            )
            self.track_info_meta_label.pack(padx=15, pady=(0, 4), anchor="w")

            self.track_info_character_label = ctk.CTkLabel(
                track_card,
                text="Characteristics: --",
                font=("Arial", 10),
                text_color=FTBTheme.TEXT_MUTED
            )
            self.track_info_character_label.pack(padx=15, pady=(0, 4), anchor="w")

            self.track_info_demands_label = ctk.CTkLabel(
                track_card,
                text="Demands: Aero -- | Power -- | Tire --",
                font=("Arial", 10),
                text_color=FTBTheme.TEXT_MUTED
            )
            self.track_info_demands_label.pack(padx=15, pady=(0, 12), anchor="w")
            
            # Driver Lineup Card
            lineup_card = ctk.CTkFrame(container, fg_color=FTBTheme.CARD, corner_radius=8)
            lineup_card.pack(fill=tk.X, padx=10, pady=(0, 10))
            
            ctk.CTkLabel(
                lineup_card,
                text="🏎️ Driver Lineup",
                font=("Arial", 14, "bold"),
                text_color=FTBTheme.TEXT
            ).pack(padx=15, pady=(15, 10), anchor="w")
            
            self.driver_lineup_container = ctk.CTkFrame(lineup_card, fg_color="transparent")
            self.driver_lineup_container.pack(fill=tk.X, padx=15, pady=(0, 15))
            
            # Recent Race Results
            recent_card = ctk.CTkFrame(container, fg_color=FTBTheme.CARD, corner_radius=8)
            recent_card.pack(fill=tk.BOTH, expand=True, padx=10, pady=(0, 10))
            
            ctk.CTkLabel(
                recent_card,
                text="🏆 Recent Race Results",
                font=("Arial", 14, "bold"),
                text_color=FTBTheme.TEXT
            ).pack(padx=15, pady=(15, 10), anchor="w")
            
            self.race_results_container = ctk.CTkFrame(recent_card, fg_color="transparent")
            self.race_results_container.pack(fill=tk.BOTH, expand=True, padx=15, pady=(0, 15))
        
        def _refresh_race_ops(self):
            """Refresh race operations display"""
            if not self.sim_state or not self.sim_state.player_team:
                return

            self.sim_state.player_team.normalize_roster()
            
            # Show/hide live race button based on race day state
            try:
                rds = getattr(self.sim_state, 'race_day_state', None)
                if rds and ftb_race_day:
                    from plugins.ftb_race_day import RaceDayPhase
                    if rds.phase == RaceDayPhase.QUALI_COMPLETE:
                        if not self.live_race_btn.winfo_ismapped():
                            self.live_race_btn.pack(padx=15, pady=(0, 15), fill=tk.X)
                            _dbg(f"[FTB] ▶️  Live race button SHOWN (phase=QUALI_COMPLETE)")
                    elif rds.phase == RaceDayPhase.RACE_RUNNING:
                        if self.live_race_btn.winfo_ismapped():
                            self.live_race_btn.configure(text="🔴 Race In Progress...", state="disabled", fg_color="#555555")
                    else:
                        if self.live_race_btn.winfo_ismapped():
                            self.live_race_btn.pack_forget()
                            self.live_race_btn.configure(text="▶️  Play Live Race", state="normal", fg_color="#00aa44")
                else:
                    if self.live_race_btn.winfo_ismapped():
                        self.live_race_btn.pack_forget()
            except Exception as e:
                _dbg(f"[FTB] Warning: live race button update error: {e}")
            
            # Update phase indicator
            phase = self.sim_state.phase
            phase_map = {
                "offseason": "⏸️ Off-Season",
                "race_weekend": "🏁 Race Weekend!",
                "development": "🔧 Development Phase"
            }
            phase_text = phase_map.get(phase, phase)
            
            phase_colors = {
                "offseason": FTBTheme.TEXT_MUTED,
                "race_weekend": FTBTheme.ACCENT,
                "development": FTBTheme.WARNING
            }
            
            self.race_phase_label.configure(
                text=f"Phase: {phase_text}",
                text_color=phase_colors.get(phase, FTBTheme.TEXT)
            )
            
            # Update countdown (simplified - show races completed)
            races_completed = self.sim_state.races_completed_this_season
            races_remaining = max(0, 16 - races_completed)
            self.race_countdown_label.configure(
                text=f"Races completed this season: {races_completed}/16  |  Remaining: {races_remaining}"
            )
            
            # Update driver lineup
            for widget in self.driver_lineup_container.winfo_children():
                widget.destroy()
            
            drivers = [driver for driver in self.sim_state.player_team.drivers if driver]
            if not drivers:
                ctk.CTkLabel(
                    self.driver_lineup_container,
                    text="No drivers assigned",
                    font=("Arial", 11),
                    text_color=FTBTheme.TEXT_MUTED
                ).pack(pady=10)
            else:
                for i, driver in enumerate(drivers, 1):
                    driver_row = ctk.CTkFrame(
                        self.driver_lineup_container,
                        fg_color=FTBTheme.SURFACE,
                        corner_radius=6
                    )
                    driver_row.pack(fill=tk.X, pady=3)
                    
                    # Driver number and name
                    ctk.CTkLabel(
                        driver_row,
                        text=f"#{i}",
                        font=("Arial", 11, "bold"),
                        text_color=FTBTheme.ACCENT,
                        width=40
                    ).pack(side=tk.LEFT, padx=(10, 5), pady=8)
                    
                    ctk.CTkLabel(
                        driver_row,
                        text=driver.name,
                        font=("Arial", 11),
                        text_color=FTBTheme.TEXT
                    ).pack(side=tk.LEFT, padx=5)
                    
                    # Overall rating
                    rating = driver.overall_rating
                    rating_color = FTBTheme.get_stat_color(rating)
                    ctk.CTkLabel(
                        driver_row,
                        text=f"OVR: {rating:.0f}",
                        font=("Arial", 10, "bold"),
                        text_color=rating_color,
                        width=60
                    ).pack(side=tk.RIGHT, padx=10)

            # Update track info (next race in calendar)
            if hasattr(self, 'track_info_name_label'):
                next_race = None
                try:
                    calendar = self.sim_state.get_calendar_projection(days_ahead=90)
                    next_race = next((e for e in calendar if e.get('entry_type') == 'race'), None)
                except Exception:
                    next_race = None

                if next_race:
                    track_id = next_race.get('metadata', {}).get('track_id')
                    track = self.sim_state.tracks.get(track_id) if track_id else None
                    track_name = track.name if track else next_race.get('metadata', {}).get('track_name', 'Unknown Circuit')
                    track_type = track.track_type if track else '--'
                    length_km = f"{track.length_km:.2f} km" if track else '--'
                    corners = f"{track.corner_count}" if track else '--'
                    laps = f"{track.lap_count}" if track else '--'
                    characteristics = ", ".join(track.characteristics) if track and track.characteristics else "--"
                    aero = track.aero_demand if track else '--'
                    power = track.power_sensitivity if track else '--'
                    tire = track.tire_stress if track else '--'

                    self.track_info_name_label.configure(text=f"Next Track: {track_name}")
                    self.track_info_meta_label.configure(
                        text=f"Type: {track_type}  |  Length: {length_km}  |  Corners: {corners}  |  Laps: {laps}"
                    )
                    self.track_info_character_label.configure(text=f"Characteristics: {characteristics}")
                    self.track_info_demands_label.configure(text=f"Demands: Aero {aero} | Power {power} | Tire {tire}")
                else:
                    self.track_info_name_label.configure(text="Next Track: --")
                    self.track_info_meta_label.configure(text="Type: --  |  Length: --  |  Corners: --  |  Laps: --")
                    self.track_info_character_label.configure(text="Characteristics: --")
                    self.track_info_demands_label.configure(text="Demands: Aero -- | Power -- | Tire --")
            
            # Update race results
            for widget in self.race_results_container.winfo_children():
                widget.destroy()
            
            # Get recent race results for player team (robust filtering)
            race_results = []
            for e in self.sim_state.event_history[-100:]:  # Check more events
                # Handle both category and event_type naming
                event_cat = getattr(e, 'category', None) or getattr(e, 'event_type', '')
                
                if event_cat == "race_result":
                    # Check all possible team key names
                    event_team = (e.data.get("team") or 
                                 e.data.get("team_name") or 
                                 e.data.get("player_team_name"))
                    
                    if event_team == self.sim_state.player_team.name:
                        race_results.append(e)
            
            # Debug logging if no results found despite races completed
            if not race_results and self.sim_state.races_completed_this_season > 0:
                _dbg(f"[FTB Debug] No race results found despite {self.sim_state.races_completed_this_season} races completed")
                _dbg(f"[FTB Debug] Event history size: {len(self.sim_state.event_history)}")
                if self.sim_state.event_history:
                    _dbg(f"[FTB Debug] Sample categories: {[getattr(e, 'category', getattr(e, 'event_type', 'unknown')) for e in self.sim_state.event_history[-10:]]}")
            
            if not race_results:
                ctk.CTkLabel(
                    self.race_results_container,
                    text="No races completed yet",
                    font=("Arial", 11),
                    text_color=FTBTheme.TEXT_MUTED
                ).pack(pady=20)
            else:
                # Group results by race to show both drivers together
                races_dict = {}
                for result_event in race_results[-20:]:  # Last 20 results (up to 10 races if 2 drivers)
                    data = result_event.data
                    # Create race identifier
                    race_key = (
                        data.get('race_id') or 
                        data.get('track_name', 'Unknown') + f"_R{data.get('round_number', 0)}"
                    )
                    if race_key not in races_dict:
                        races_dict[race_key] = {
                            'track': data.get('track_name', 'Unknown Track'),
                            'round': data.get('round_number', 0),
                            'results': []
                        }
                    races_dict[race_key]['results'].append(result_event)
                
                # Show last 5 races
                race_keys = list(races_dict.keys())[-5:]
                for race_key in race_keys:
                    race_info = races_dict[race_key]
                    
                    # Race header frame
                    race_frame = ctk.CTkFrame(
                        self.race_results_container,
                        fg_color=FTBTheme.SURFACE,
                        corner_radius=6
                    )
                    race_frame.pack(fill=tk.X, pady=5)
                    
                    # Race title
                    ctk.CTkLabel(
                        race_frame,
                        text=f"🏁 R{race_info['round']} - {race_info['track']}",
                        font=("Arial", 10, "bold"),
                        text_color=FTBTheme.TEXT
                    ).pack(anchor="w", padx=10, pady=(8, 4))
                    
                    # Show each driver's result
                    for result_event in race_info['results']:
                        data = result_event.data
                        position = data.get('position', '--')
                        points = data.get('points', 0)
                        driver = data.get('driver', 'Unknown')
                        grid_pos = data.get('grid_position', '--')
                        status = data.get('status', 'finished')
                        
                        # Color based on position/status
                        if status != 'finished':
                            pos_color = FTBTheme.ERROR
                        elif position <= 3:
                            pos_color = FTBTheme.SUCCESS
                        elif position <= 10:
                            pos_color = FTBTheme.ACCENT
                        else:
                            pos_color = FTBTheme.TEXT_MUTED
                        
                        # Driver result row
                        driver_row = ctk.CTkFrame(race_frame, fg_color="transparent")
                        driver_row.pack(fill=tk.X, padx=10, pady=2)
                        
                        # Position indicator
                        pos_text = f"P{position}" if status == 'finished' else status.upper()
                        ctk.CTkLabel(
                            driver_row,
                            text=pos_text,
                            font=("Arial", 11, "bold"),
                            text_color=pos_color,
                            width=50
                        ).pack(side=tk.LEFT, padx=(0, 5))
                        
                        # Driver name and details
                        detail_text = f"{driver}"
                        if status == 'finished':
                            detail_text += f" (Grid: P{grid_pos})"
                        if points > 0:
                            detail_text += f" • +{points} pts"
                        
                        ctk.CTkLabel(
                            driver_row,
                            text=detail_text,
                            font=("Arial", 9),
                            text_color=FTBTheme.TEXT
                        ).pack(side=tk.LEFT)
                    
                    # Add spacing after race
                    ctk.CTkFrame(race_frame, fg_color="transparent", height=4).pack()
        
        def _on_play_live_race(self):
            """Handle Play Live Race button click from Race Operations tab."""
            _dbg(f"[FTB] ▶️  _on_play_live_race CLICKED")
            try:
                cmd_q = self.runtime.get("ftb_cmd_q")
                if cmd_q:
                    cmd_q.put({"cmd": "ftb_start_live_race", "speed": 10.0})
                    _dbg(f"[FTB] ▶️  ftb_start_live_race command SENT to queue")
                    # Update button immediately to prevent double-click
                    self.live_race_btn.configure(
                        text="🔴 Starting race...",
                        state="disabled",
                        fg_color="#555555"
                    )
                    # Activate PBP widget tab so user sees the live race immediately
                    ui_q = self.runtime.get('ui_q')
                    if ui_q:
                        ui_q.put(("activate_widget_tab", {"widget_key": "ftb_pbp"}))
                        _dbg("[FTB] 📺 Sent activate_widget_tab for ftb_pbp")
                else:
                    _dbg(f"[FTB] ⚠️  ftb_cmd_q not found in runtime!")
            except Exception as e:
                _dbg(f"[FTB] ❌ _on_play_live_race error: {e}")
                import traceback
                traceback.print_exc()
        
        def _build_racing_stats_tab(self):
            """Build Racing Stats tab with Teams/Drivers tabs and tier/league filtering"""
            tab = self.tab_racing_stats
            
            # Main container
            main_container = ctk.CTkFrame(tab, fg_color="transparent")
            main_container.pack(fill=tk.BOTH, expand=True, padx=10, pady=10)
            
            # === HEADER ===
            header = ctk.CTkFrame(main_container, fg_color="transparent")
            header.pack(fill=tk.X, pady=(0, 10))
            
            ctk.CTkLabel(
                header,
                text="🏁 Racing Statistics & Standings",
                font=("Arial", 20, "bold"),
                text_color=FTBTheme.ACCENT
            ).pack(side=tk.LEFT)
            
            ctk.CTkButton(
                header,
                text="🔄 Refresh",
                command=self._refresh_racing_stats,
                fg_color=FTBTheme.ACCENT,
                hover_color=FTBTheme.CARD_HOVER,
                width=100,
                height=30
            ).pack(side=tk.RIGHT)
            
            # === FILTER CONTROLS ===
            filter_panel = ctk.CTkFrame(main_container, fg_color=FTBTheme.CARD, corner_radius=8)
            filter_panel.pack(fill= tk.X, pady=(0, 10))
            
            filter_row = ctk.CTkFrame(filter_panel, fg_color="transparent")
            filter_row.pack(fill=tk.X, padx=15, pady=10)
            
            # Tier selection
            ctk.CTkLabel(
                filter_row,
                text="Tier:",
                font=("Arial", 11),
                text_color=FTBTheme.TEXT_MUTED
            ).pack(side=tk.LEFT, padx=(0, 5))
            
            # Determine default tier (Player's tier or Grassroots)
            default_tier_name = "Grassroots"
            tier_names = {1: "Grassroots", 2: "Formula V", 3: "Formula X", 4: "Formula Y", 5: "Formula Z"}
            if self.sim_state and self.sim_state.player_team:
                default_tier_name = tier_names.get(self.sim_state.player_team.tier, "Grassroots")
            
            self._stats_tier_var = tk.StringVar(value=default_tier_name)
            self._stats_tier_dropdown = ctk.CTkComboBox(
                filter_row,
                variable=self._stats_tier_var,
                values=["Grassroots", "Formula V", "Formula X", "Formula Y", "Formula Z"],
                command=lambda _: self._on_tier_changed(),
                fg_color=FTBTheme.SURFACE,
                button_color=FTBTheme.ACCENT,
                button_hover_color=FTBTheme.CARD_HOVER,
                width=180
            )
            self._stats_tier_dropdown.pack(side=tk.LEFT, padx=(0, 20))
            
            # League selection
            ctk.CTkLabel(
                filter_row,
                text="League:",
                font=("Arial", 11),
                text_color=FTBTheme.TEXT_MUTED
            ).pack(side=tk.LEFT, padx=(0, 5))
            
            self._stats_league_var = tk.StringVar(value="Select League")
            self._stats_league_dropdown = ctk.CTkComboBox(
                filter_row,
                variable=self._stats_league_var,
                values=["Select League"],
                command=lambda _: self._refresh_racing_stats(),
                fg_color=FTBTheme.SURFACE,
                button_color=FTBTheme.ACCENT,
                button_hover_color=FTBTheme.CARD_HOVER,
                width=280
            )
            self._stats_league_dropdown.pack(side=tk.LEFT)
            
            # Populate initial league options based on default tier (only if state exists)
            if self.sim_state and hasattr(self.sim_state, 'leagues') and self.sim_state.leagues:
                self._on_tier_changed()
            else:
                # Set a loading message if state isn't available yet
                self._stats_league_var.set("Loading leagues...")
                self._stats_league_dropdown.configure(values=["Loading leagues..."])
            
            # === TABS ===
            self.stats_tabview = ctk.CTkTabview(main_container, fg_color=FTBTheme.CARD, corner_radius=8)
            self.stats_tabview.pack(fill=tk.BOTH, expand=True)
            
            # Create tabs
            self.stats_tabview.add("Teams")
            self.stats_tabview.add("Drivers")
            
            # Teams tab content containers
            self.teams_tab = self.stats_tabview.tab("Teams")
            teams_scroll = ctk.CTkScrollableFrame(self.teams_tab, fg_color="transparent")
            teams_scroll.pack(fill=tk.BOTH, expand=True, padx=5, pady=5)
            
            self.teams_latest_race_container = ctk.CTkFrame(teams_scroll, fg_color="transparent")
            self.teams_latest_race_container.pack(fill=tk.X, pady=(0, 10))
            
            self.teams_standings_container = ctk.CTkFrame(teams_scroll, fg_color="transparent")
            self.teams_standings_container.pack(fill=tk.BOTH, expand=True, pady=(0, 10))
            
            self.teams_history_container = ctk.CTkFrame(teams_scroll, fg_color="transparent")
            self.teams_history_container.pack(fill=tk.X, pady=(10, 0))
            
            # Drivers tab content containers
            self.drivers_tab = self.stats_tabview.tab("Drivers")
            drivers_scroll = ctk.CTkScrollableFrame(self.drivers_tab, fg_color="transparent")
            drivers_scroll.pack(fill=tk.BOTH, expand=True, padx=5, pady=5)
            
            self.drivers_latest_race_container = ctk.CTkFrame(drivers_scroll, fg_color="transparent")
            self.drivers_latest_race_container.pack(fill=tk.X, pady=(0, 10))
            
            self.drivers_standings_container = ctk.CTkFrame(drivers_scroll, fg_color="transparent")
            self.drivers_standings_container.pack(fill=tk.BOTH, expand=True, pady=(0, 10))
            
            self.drivers_history_container = ctk.CTkFrame(drivers_scroll, fg_color="transparent")
            self.drivers_history_container.pack(fill=tk.X, pady=(10, 0))
            
            # Variables for sorting
            self._teams_sort_column = 'position'
            self._teams_sort_reverse = False
            self._drivers_sort_column = 'position'
            self._drivers_sort_reverse = False
        
        def _on_tier_changed(self):
            """Handle tier dropdown change - update league dropdown options"""
            if not self.sim_state:
                _dbg("[FTB] _on_tier_changed: No state available")
                self._stats_league_dropdown.configure(values=["No game loaded"])
                self._stats_league_var.set("No game loaded")
                return
            
            # Check if leagues exist
            if not hasattr(self.sim_state, 'leagues') or not self.sim_state.leagues:
                _dbg("[FTB] _on_tier_changed: No leagues found in state")
                self._stats_league_dropdown.configure(values=["No leagues available"])
                self._stats_league_var.set("No leagues available")
                return
            
            selected_tier = self._stats_tier_var.get()
            tier_map = {"Grassroots": 1, "Formula V": 2, "Formula X": 3, "Formula Y": 4, "Formula Z": 5}
            
            _dbg(f"[FTB] _on_tier_changed: Selected tier = {selected_tier}")
            _dbg(f"[FTB] _on_tier_changed: Total leagues = {len(self.sim_state.leagues)}")
            
            # Filter leagues by tier - NO "All Leagues" option
            league_options = []
            if selected_tier == "All Tiers":
                for lg in self.sim_state.leagues.values():
                    if lg and hasattr(lg, 'name') and lg.name:  # Safety check
                        league_options.append(f"{lg.name} (T{lg.tier})")
            elif selected_tier in tier_map:
                tier_num = tier_map[selected_tier]
                _dbg(f"[FTB] _on_tier_changed: Filtering for tier {tier_num}")
                for lg in self.sim_state.leagues.values():
                    if lg and hasattr(lg, 'name') and hasattr(lg, 'tier') and lg.name:
                        _dbg(f"[FTB]   League: {lg.name}, Tier: {lg.tier}")
                        if lg.tier == tier_num:  # Safety check
                            league_options.append(f"{lg.name} (T{lg.tier})")
            
            _dbg(f"[FTB] _on_tier_changed: Found {len(league_options)} leagues for selected tier")
            
            # Fallback if no leagues found
            if not league_options:
                league_options = [f"No leagues in {selected_tier}"]
            
            # Update league dropdown - ensure all values are strings
            league_options = [str(opt) for opt in league_options]
            league_options.sort()  # Sort alphabetically for easier browsing
            self._stats_league_dropdown.configure(values=league_options)
            
            # Default to player's league if available, otherwise first option
            if self.sim_state.player_team and hasattr(self.sim_state, 'leagues'):
                for lg in self.sim_state.leagues.values():
                    if lg and hasattr(lg, 'teams') and hasattr(lg, 'name'):
                        if self.sim_state.player_team in lg.teams:
                            player_league_option = f"{lg.name} (T{lg.tier})"
                            if player_league_option in league_options:
                                self._stats_league_var.set(player_league_option)
                                _dbg(f"[FTB] _on_tier_changed: Set to player's league: {player_league_option}")
                                self._refresh_racing_stats()
                                return
            
            # Fallback to first option if player league not found
            if league_options:
                self._stats_league_var.set(league_options[0])
                _dbg(f"[FTB] _on_tier_changed: Set to first option: {league_options[0]}")
            
            # Refresh display
            self._refresh_racing_stats()

        
        
        def _refresh_racing_stats(self):
            """Refresh Teams and Drivers tabs with tier/league filtering"""
            if not self.sim_state:
                return

            containers = [
                self.teams_latest_race_container,
                self.teams_standings_container,
                self.teams_history_container,
                self.drivers_latest_race_container,
                self.drivers_standings_container,
                self.drivers_history_container
            ]
            if not all(container and container.winfo_exists() for container in containers):
                return
            
            try:
                # Get tier and league filters
                tier_map = {"Grassroots": 1, "Formula V": 2, "Formula X": 3, "Formula Y": 4, "Formula Z": 5}
                selected_tier_name = self._stats_tier_var.get()
                selected_tier = tier_map.get(selected_tier_name, None)
                
                selected_league_display = self._stats_league_var.get()
                
                # PERFORMANCE OPTIMIZATION: Check if we need to refresh
                current_tick = self.sim_state.tick if hasattr(self.sim_state, 'tick') else 0
                cache = self._stats_cache
                
                # Check if stats are marked dirty (overrides cache)
                force_refresh = hasattr(self.sim_state, '_stats_dirty') and self.sim_state._stats_dirty
                
                # Skip refresh if nothing changed and not forced
                if (not force_refresh and
                    cache['last_tier'] == selected_tier_name and 
                    cache['last_league'] == selected_league_display and 
                    cache['last_tick'] == current_tick):
                    _dbg(f"[FTB STATS] Cache hit - skipping refresh (tier={selected_tier_name}, league={selected_league_display}, tick={current_tick})")
                    return
                
                # Update cache
                cache['last_tier'] = selected_tier_name
                cache['last_league'] = selected_league_display
                cache['last_tick'] = current_tick
                
                _dbg(f"[FTB STATS] Cache miss - performing refresh (tier={selected_tier_name}, league={selected_league_display}, tick={current_tick})")
                
                selected_league = None
                
                _dbg(f"[FTB] _refresh_racing_stats: Selected league display = {selected_league_display}")
                
                # Find the selected league - check if leagues exist and are valid
                if hasattr(self.sim_state, 'leagues') and self.sim_state.leagues:
                    for lg in self.sim_state.leagues.values():
                        if lg and hasattr(lg, 'name') and lg.name:
                            # Match by checking if display starts with league name
                            league_display_name = f"{lg.name} (T{lg.tier})"
                            if selected_league_display == league_display_name:
                                selected_league = lg
                                _dbg(f"[FTB] _refresh_racing_stats: Found league: {lg.name}")
                                break
                
                if not selected_league:
                    _dbg(f"[FTB] _refresh_racing_stats: No league match found for '{selected_league_display}'")
            
                # Clear all containers safely
                for container in [self.teams_latest_race_container, self.teams_standings_container, self.teams_history_container,
                                 self.drivers_latest_race_container, self.drivers_standings_container, self.drivers_history_container]:
                    if container and container.winfo_exists():
                        for widget in container.winfo_children():
                            widget.destroy()
            
                # Build Teams Tab
                self._build_teams_tab(selected_league, selected_tier)
            
                # Build Drivers Tab
                self._build_drivers_tab(selected_league, selected_tier)
                
            except Exception as e:
                _dbg(f"[FTB] ERROR in _refresh_racing_stats: {e}")
                import traceback
                traceback.print_exc()
                
                # Show error message in UI
                try:
                    error_label = ctk.CTkLabel(
                        self.teams_latest_race_container,
                        text=f"⚠️ Error loading stats: {str(e)}\nCheck console for details.",
                        font=("Arial", 11),
                        text_color=FTBTheme.DANGER
                    )
                    error_label.pack(pady=20)
                except:
                    pass

        def _get_archive_results_for_leagues(self, leagues_to_show):
            """Load archived race results for the selected leagues."""
            if not self.sim_state or not self.sim_state.state_db_path:
                return []

            # PERFORMANCE OPTIMIZATION: Cache archive results for current tick
            current_tick = self.sim_state.tick if hasattr(self.sim_state, 'tick') else 0
            cache = self._stats_cache
            
            # Use cached results if available and tick hasn't changed
            if (cache['archive_results'] is not None and 
                cache['archive_timestamp'] == current_tick):
                _dbg(f"[FTB STATS] Using cached archive results for tick {current_tick}")
                results = cache['archive_results']
            else:
                # Query database for fresh results
                try:
                    from plugins import ftb_state_db
                    # PERFORMANCE: Limit to most recent 500 races to prevent UI sluggishness
                    # This covers ~10 seasons of full championship racing easily
                    results = ftb_state_db.query_race_results(
                        self.sim_state.state_db_path,
                        limit=500
                    )
                    
                    # Update cache
                    cache['archive_results'] = results
                    cache['archive_timestamp'] = current_tick
                    _dbg(f"[FTB STATS] Loaded {len(results)} archive results from DB for tick {current_tick}")
                except Exception as e:
                    _dbg(f"[FTB] _get_archive_results_for_leagues: {e}")
                    return []

            league_ids = {
                lg.league_id
                for lg in leagues_to_show
                if lg and hasattr(lg, 'league_id')
            }
            if league_ids:
                results = [r for r in results if r.get('league_id') in league_ids]

            return results

        def _group_archive_by_league(self, archive_results):
            archive_by_league = {}
            for result in archive_results:
                league_id = result.get('league_id')
                if not league_id:
                    continue
                archive_by_league.setdefault(league_id, []).append(result)
            return archive_by_league
        
        def _build_teams_tab(self, selected_league, selected_tier):
            """Populate Teams tab with latest race, standings, and history"""
            from plugins.ftb_components import format_currency

            if not self.teams_standings_container or not self.teams_standings_container.winfo_exists():
                return
            if not self.teams_latest_race_container or not self.teams_latest_race_container.winfo_exists():
                return
            if not self.teams_history_container or not self.teams_history_container.winfo_exists():
                return
            
            try:
                # Determine which leagues to show - filter out None values
                leagues_to_show = []
                if selected_league:
                    leagues_to_show = [selected_league] if selected_league else []
                elif selected_tier:
                    leagues_to_show = [lg for lg in self.sim_state.leagues.values() if lg and lg.tier == selected_tier]
                else:
                    leagues_to_show = [lg for lg in self.sim_state.leagues.values() if lg]

                archive_results = self._get_archive_results_for_leagues(leagues_to_show)
                archive_by_league = self._group_archive_by_league(archive_results)
                use_archive = bool(archive_results)
                
                # Debug logging
                if use_archive:
                    race_result_count = sum(len(results) for results in archive_by_league.values())
                    _dbg(f"[FTB STATS] Building teams tab: {len(leagues_to_show)} leagues, {race_result_count} archived races")
                else:
                    race_result_count = sum(1 for e in self.sim_state.event_history if e.category == "race_result")
                    _dbg(f"[FTB STATS] Building teams tab: {len(leagues_to_show)} leagues, {race_result_count} race results in event_history")
            
                # === LATEST RACE RESULTS ===
                latest_race_events = []
                if use_archive:
                    for lg in leagues_to_show:
                        if not lg or not hasattr(lg, 'league_id'):
                            continue
                        league_results = archive_by_league.get(lg.league_id, [])
                        if league_results:
                            latest_race = max(
                                league_results,
                                key=lambda r: (r.get('season', 0), r.get('round_number', 0), r.get('tick', 0))
                            )
                            latest_race_events.append((lg, latest_race))
                            _dbg(f"[FTB STATS] League {lg.name}: {len(league_results)} archived races")
                else:
                    for lg in leagues_to_show:
                        if not lg or not hasattr(lg, 'league_id'):
                            continue
                        lg_races = [e for e in self.sim_state.event_history if e.category == "race_result" and e.data.get('league_id') == lg.league_id]
                        if lg_races:
                            latest_race_events.append((lg, lg_races[-1]))
                            _dbg(f"[FTB STATS] League {lg.name}: {len(lg_races)} races found")
                
                if not latest_race_events:
                    if use_archive:
                        _dbg("[FTB STATS] No archived race results found")
                    else:
                        _dbg(f"[FTB STATS] No race events found in event_history")
                    total_races_completed = sum(lg.races_this_season for lg in leagues_to_show if hasattr(lg, 'races_this_season'))
                    if total_races_completed > 0:
                        warning_text = "Race data should appear after next race."
                        if not use_archive:
                            warning_text = "Event history may have been cleared. Race data should appear after next race."
                        no_data_label = ctk.CTkLabel(
                            self.teams_latest_race_container,
                            text=f"⚠️ {total_races_completed} races completed but results not in history.\n{warning_text}",
                            font=("Arial", 11),
                            text_color=FTBTheme.WARNING
                        )
                        no_data_label.pack(pady=20)
            
                if latest_race_events:
                    # Get most recent race
                    if use_archive:
                        lg, latest_race = max(
                            latest_race_events,
                            key=lambda x: (x[1].get('season', 0), x[1].get('round_number', 0), x[1].get('tick', 0))
                        )
                    else:
                        lg, latest_race = max(latest_race_events, key=lambda x: x[1].ts)
                    
                    race_card = ctk.CTkFrame(self.teams_latest_race_container, fg_color=FTBTheme.CARD, corner_radius=8)
                    race_card.pack(fill=tk.X, pady=(0, 10))
                    
                    ctk.CTkLabel(
                        race_card,
                        text=(
                            f"🏁 Latest Race - {latest_race.get('track_name', 'Unknown')} (Round {latest_race.get('round_number', '?')})"
                            if use_archive else
                            f"🏁 Latest Race - {latest_race.data.get('track_name', 'Unknown')} (Round {latest_race.data.get('round_number', '?')})"
                        ),
                        font=("Arial", 14, "bold"),
                        text_color=FTBTheme.ACCENT
                    ).pack(anchor=tk.W, padx=15, pady=(10, 5))
                    
                    league_name = lg.name if lg and lg.name else "Unknown League"
                    ctk.CTkLabel(
                        race_card,
                        text=(
                            f"{league_name} - Tick {latest_race.get('tick', 0)}"
                            if use_archive else
                            f"{league_name} - Tick {latest_race.ts}"
                        ),
                        font=("Arial", 10),
                        text_color=FTBTheme.TEXT_MUTED
                    ).pack(anchor=tk.W, padx=15, pady=(0, 10))
                    
                    # Get ALL driver finishers for this race (show every driver, not just one per team)
                    all_race_results = []
                    if use_archive:
                        for entry in latest_race.get('finish_positions', []):
                            team_name = entry.get('team', '')
                            driver_name_entry = entry.get('driver', '')
                            position = entry.get('position', 99)
                            if team_name and driver_name_entry:
                                all_race_results.append({
                                    'position': position,
                                    'driver': driver_name_entry,
                                    'team': team_name,
                                    'points': 0,
                                    'status': entry.get('status', 'finished')
                                })
                    else:
                        for event in [e for e in self.sim_state.event_history if e.category == "race_result" and e.ts == latest_race.ts and e.data.get('league_id') == lg.league_id]:
                            team_name = event.data.get('team', '')
                            driver_name_entry = event.data.get('driver', '')
                            position = event.data.get('position', 99)
                            if team_name and driver_name_entry:
                                all_race_results.append({
                                    'position': position,
                                    'driver': driver_name_entry,
                                    'team': team_name,
                                    'points': event.data.get('points', 0),
                                    'status': event.data.get('status', 'finished')
                                })
                    
                    all_race_results.sort(key=lambda x: x['position'])
                    
                    for result in all_race_results[:20]:
                        result_row = ctk.CTkFrame(race_card, fg_color="transparent")
                        result_row.pack(fill=tk.X, padx=15, pady=2)
                        
                        is_player_result = self.sim_state.player_team and result['team'] == self.sim_state.player_team.name
                        pos_color = FTBTheme.SUCCESS if result['position'] <= 3 else FTBTheme.TEXT
                        team_color = FTBTheme.ACCENT if is_player_result else FTBTheme.TEXT_MUTED
                        driver_weight = "bold" if is_player_result else "normal"
                        status_text = ""
                        if result['status'] != 'finished':
                            status_text = f" [{result['status'].upper()}]"
                        ctk.CTkLabel(result_row, text=f"P{result['position']}", font=("Arial", 10, "bold"), text_color=pos_color, width=35).pack(side=tk.LEFT)
                        ctk.CTkLabel(result_row, text=result['driver'], font=("Arial", 10, driver_weight), width=150, anchor="w").pack(side=tk.LEFT, padx=5)
                        ctk.CTkLabel(result_row, text=f"{result['team']}{status_text}", font=("Arial", 9), text_color=team_color, width=160, anchor="w").pack(side=tk.LEFT)
                        if result['points'] > 0:
                            ctk.CTkLabel(result_row, text=f"+{result['points']} pts", font=("Arial", 10, "bold"), text_color=FTBTheme.ACCENT).pack(side=tk.RIGHT, padx=5)
                    
                    ctk.CTkLabel(race_card, text="", height=5).pack()  # Padding
                
                # === TEAM STANDINGS TABLE ===
                standings_card = ctk.CTkFrame(self.teams_standings_container, fg_color=FTBTheme.CARD, corner_radius=8)
                standings_card.pack(fill=tk.BOTH, expand=True)
                
                league_label = (selected_league.name if selected_league and selected_league.name else "Unknown League") if selected_league else (f"Tier {selected_tier}" if selected_tier else "All Tiers")
                ctk.CTkLabel(
                    standings_card,
                    text=f"🏆 Team Championship Standings - {league_label}",
                    font=("Arial", 14, "bold"),
                    text_color=FTBTheme.TEXT
                ).pack(anchor=tk.W, padx=15, pady=(10, 5))
                
                # Collect all team data
                teams_data = []
                for lg in leagues_to_show:
                    if not lg or not hasattr(lg, 'championship_table') or not hasattr(lg, 'teams'):
                        continue
                    for team_name, points in lg.championship_table.items():
                        if not team_name:
                            continue
                        team_obj = next((t for t in lg.teams if t and t.name == team_name), None)
                        if not team_obj:
                            continue
                        
                        # Calculate wins/podiums/races from archive results when available
                        league_id = getattr(lg, 'league_id', None)
                        if use_archive:
                            league_results = archive_by_league.get(league_id, [])
                            wins = 0
                            podiums = 0
                            races = 0
                            for result in league_results:
                                best_position = None
                                for entry in result.get('finish_positions', []):
                                    if entry.get('team') != team_name:
                                        continue
                                    position = entry.get('position', 99)
                                    if best_position is None or position < best_position:
                                        best_position = position
                                if best_position is not None:
                                    races += 1
                                    if best_position == 1:
                                        wins += 1
                                    if best_position <= 3:
                                        podiums += 1
                        else:
                            wins = sum(1 for e in self.sim_state.event_history if e.category == "race_result" and e.data.get('team') == team_name and e.data.get('position') == 1 and e.data.get('league_id') == league_id)
                            podiums = sum(1 for e in self.sim_state.event_history if e.category == "race_result" and e.data.get('team') == team_name and e.data.get('position', 99) <= 3 and e.data.get('league_id') == league_id)
                            races = sum(1 for e in self.sim_state.event_history if e.category == "race_result" and e.data.get('team') == team_name and e.data.get('league_id') == league_id)
                        
                        teams_data.append({
                            'position': 0,  # Will be calculated after sorting
                            'name': team_name,
                            'points': points,
                            'wins': wins,
                            'podiums': podiums,
                            'races': races,
                            'is_player': self.sim_state.player_team and team_name == self.sim_state.player_team.name
                        })
                
                # Sort by points (descending) and assign positions
                teams_data.sort(key=lambda t: t['points'], reverse=True)
                for i, team in enumerate(teams_data, 1):
                    team['position'] = i
                
                # Display table with sortable headers
                if teams_data:
                    header_row = ctk.CTkFrame(standings_card, fg_color=FTBTheme.SURFACE, corner_radius=4)
                    header_row.pack(fill=tk.X, padx=15, pady=(5, 2))
                    
                    def make_sort_command(column):
                        def sort_command():
                            if self._teams_sort_column == column:
                                self._teams_sort_reverse = not self._teams_sort_reverse
                            else:
                                self._teams_sort_column = column
                                self._teams_sort_reverse = (column != 'position')  # Reverse for most columns except position
                            self._refresh_racing_stats()
                        return sort_command
                    
                    ctk.CTkButton(header_row, text="Pos ↕", command=make_sort_command('position'), width=50, height=24, font=("Arial", 9, "bold"), fg_color="transparent", hover_color=FTBTheme.CARD_HOVER).pack(side=tk.LEFT, padx=2)
                    ctk.CTkButton(header_row, text="Team Name ↕", command=make_sort_command('name'), width=180, height=24, font=("Arial", 9, "bold"), fg_color="transparent", hover_color=FTBTheme.CARD_HOVER, anchor="w").pack(side=tk.LEFT, padx=2)
                    ctk.CTkButton(header_row, text="Points ↕", command=make_sort_command('points'), width=70, height=24, font=("Arial", 9, "bold"), fg_color="transparent", hover_color=FTBTheme.CARD_HOVER).pack(side=tk.LEFT, padx=2)
                    ctk.CTkButton(header_row, text="Wins ↕", command=make_sort_command('wins'), width=55, height=24, font=("Arial", 9, "bold"), fg_color="transparent", hover_color=FTBTheme.CARD_HOVER).pack(side=tk.LEFT, padx=2)
                    ctk.CTkButton(header_row, text="Podiums ↕", command=make_sort_command('podiums'), width=75, height=24, font=("Arial", 9, "bold"), fg_color="transparent", hover_color=FTBTheme.CARD_HOVER).pack(side=tk.LEFT, padx=2)
                    ctk.CTkButton(header_row, text="Races ↕", command=make_sort_command('races'), width=60, height=24, font=("Arial", 9, "bold"), fg_color="transparent", hover_color=FTBTheme.CARD_HOVER).pack(side=tk.LEFT, padx=2)
                    
                    # Re-sort if user clicked a column header
                    if hasattr(self, '_teams_sort_column'):
                        teams_data.sort(key=lambda t: t[self._teams_sort_column], reverse=self._teams_sort_reverse)
                    
                    # Display rows
                    for team in teams_data:
                        row = ctk.CTkFrame(standings_card, fg_color="transparent")
                        row.pack(fill=tk.X, padx=15, pady=1)
                        
                        pos_color = FTBTheme.SUCCESS if team['position'] <= 3 else FTBTheme.TEXT
                        team_color = FTBTheme.ACCENT if team['is_player'] else FTBTheme.TEXT
                        team_weight = "bold" if team['is_player'] else "normal"
                        
                        ctk.CTkLabel(row, text=f"{team['position']}", font=("Arial", 10), text_color=pos_color, width=50).pack(side=tk.LEFT, padx=2)
                        ctk.CTkLabel(row, text=team['name'], font=("Arial", 10, team_weight), text_color=team_color, width=180, anchor="w").pack(side=tk.LEFT, padx=2)
                        ctk.CTkLabel(row, text=f"{team['points']}", font=("Arial", 10, "bold"), text_color=FTBTheme.ACCENT, width=70).pack(side=tk.LEFT, padx=2)
                        ctk.CTkLabel(row, text=f"{team['wins']}", font=("Arial", 10), width=55).pack(side=tk.LEFT, padx=2)
                        ctk.CTkLabel(row, text=f"{team['podiums']}", font=("Arial", 10), width=75).pack(side=tk.LEFT, padx=2)
                        ctk.CTkLabel(row, text=f"{team['races']}", font=("Arial", 10), text_color=FTBTheme.TEXT_MUTED, width=60).pack(side=tk.LEFT, padx=2)
                    
                    ctk.CTkLabel(standings_card, text="", height=5).pack()  # Padding
                else:
                    ctk.CTkLabel(standings_card, text="No standings data available.", font=("Arial", 11), text_color=FTBTheme.TEXT_MUTED).pack(pady=20)
                
                # === SEASON HISTORY ===
                history_card = ctk.CTkFrame(self.teams_history_container, fg_color=FTBTheme.CARD, corner_radius=8)
                history_card.pack(fill=tk.X)
                
                ctk.CTkLabel(history_card, text="📊 Season History & Trends", font=("Arial", 12, "bold"), text_color=FTBTheme.TEXT_MUTED).pack(pady=10)
                if use_archive:
                    season_counts = {}
                    for result in archive_results:
                        season = result.get('season')
                        if season is None:
                            continue
                        season_counts[season] = season_counts.get(season, 0) + 1
                    if season_counts:
                        seasons_tracked = len(season_counts)
                        total_races = sum(season_counts.values())
                        ctk.CTkLabel(
                            history_card,
                            text=f"Seasons tracked: {seasons_tracked} | Races archived: {total_races}",
                            font=("Arial", 10),
                            text_color=FTBTheme.TEXT_MUTED
                        ).pack(pady=5)
                    else:
                        ctk.CTkLabel(history_card, text="No archived races yet.", font=("Arial", 10), text_color=FTBTheme.TEXT_MUTED).pack(pady=5)
                else:
                    ctk.CTkLabel(history_card, text="Historical data coming soon...", font=("Arial", 10), text_color=FTBTheme.TEXT_MUTED).pack(pady=5)
            
            except Exception as e:
                _dbg(f"[FTB] ERROR in _build_teams_tab: {e}")
                import traceback
                traceback.print_exc()
                
                # Show error in UI
                try:
                    error_label = ctk.CTkLabel(
                        self.teams_latest_race_container,
                        text=f"⚠️ Error displaying teams data: {str(e)}",
                        font=("Arial", 11),
                        text_color=FTBTheme.DANGER
                    )
                    error_label.pack(pady=20)
                except:
                    pass
        
        def _build_drivers_tab(self, selected_league, selected_tier):
            """Populate Drivers tab with latest race, standings, and history"""
            if not self.drivers_standings_container or not self.drivers_standings_container.winfo_exists():
                return
            if not self.drivers_latest_race_container or not self.drivers_latest_race_container.winfo_exists():
                return
            if not self.drivers_history_container or not self.drivers_history_container.winfo_exists():
                return
            
            # Determine which leagues to show - filter out None values
            leagues_to_show = []
            if selected_league:
                leagues_to_show = [selected_league] if selected_league else []
            elif selected_tier:
                leagues_to_show = [lg for lg in self.sim_state.leagues.values() if lg and lg.tier == selected_tier]
            else:
                leagues_to_show = [lg for lg in self.sim_state.leagues.values() if lg]

            archive_results = self._get_archive_results_for_leagues(leagues_to_show)
            archive_by_league = self._group_archive_by_league(archive_results)
            use_archive = bool(archive_results)
            
            # === LATEST RACE RESULTS (Drivers) ===
            latest_race_events = []
            if use_archive:
                for lg in leagues_to_show:
                    if not lg or not hasattr(lg, 'league_id'):
                        continue
                    league_results = archive_by_league.get(lg.league_id, [])
                    if league_results:
                        latest_race = max(
                            league_results,
                            key=lambda r: (r.get('season', 0), r.get('round_number', 0), r.get('tick', 0))
                        )
                        latest_race_events.append((lg, latest_race))
            else:
                for lg in leagues_to_show:
                    if not lg or not hasattr(lg, 'league_id'):
                        continue
                    lg_races = [e for e in self.sim_state.event_history if e.category == "race_result" and e.data.get('league_id') == lg.league_id]
                    if lg_races:
                        latest_race_events.append((lg, lg_races[-1]))
            
            if latest_race_events:
                if use_archive:
                    lg, latest_race = max(
                        latest_race_events,
                        key=lambda x: (x[1].get('season', 0), x[1].get('round_number', 0), x[1].get('tick', 0))
                    )
                else:
                    lg, latest_race = max(latest_race_events, key=lambda x: x[1].ts)
                
                race_card = ctk.CTkFrame(self.drivers_latest_race_container, fg_color=FTBTheme.CARD, corner_radius=8)
                race_card.pack(fill=tk.X, pady=(0, 10))
                
                ctk.CTkLabel(
                    race_card,
                    text=(
                        f"🏁 Latest Race - {latest_race.get('track_name', 'Unknown')} (Round {latest_race.get('round_number', '?')})"
                        if use_archive else
                        f"🏁 Latest Race - {latest_race.data.get('track_name', 'Unknown')} (Round {latest_race.data.get('round_number', '?')})"
                    ),
                    font=("Arial", 14, "bold"),
                    text_color=FTBTheme.ACCENT
                ).pack(anchor=tk.W, padx=15, pady=(10, 5))
                
                # Get all driver results for this race
                if use_archive:
                    driver_results = [
                        (entry.get('position', 99), entry.get('driver'), entry.get('team'), 0)
                        for entry in latest_race.get('finish_positions', [])
                    ]
                else:
                    driver_results = [(e.data.get('position', 99), e.data.get('driver'), e.data.get('team'), e.data.get('points', 0))
                                     for e in self.sim_state.event_history
                                     if e.category == "race_result" and e.ts == latest_race.ts and e.data.get('league_id') == lg.league_id]
                driver_results.sort(key=lambda x: x[0])
                
                for position, driver, team, points in driver_results[:10]:
                    result_row = ctk.CTkFrame(race_card, fg_color="transparent")
                    result_row.pack(fill=tk.X, padx=15, pady=2)
                    
                    pos_color = FTBTheme.SUCCESS if position <= 3 else FTBTheme.TEXT
                    ctk.CTkLabel(result_row, text=f"P{position}", font=("Arial", 10, "bold"), text_color=pos_color, width=35).pack(side=tk.LEFT)
                    ctk.CTkLabel(result_row, text=driver, font=("Arial", 10), width=150, anchor="w").pack(side=tk.LEFT, padx=5)
                    ctk.CTkLabel(result_row, text=team, font=("Arial", 9), text_color=FTBTheme.TEXT_MUTED, width=130, anchor="w").pack(side=tk.LEFT)
                    if points > 0:
                        ctk.CTkLabel(result_row, text=f"+{points} pts", font=("Arial", 10, "bold"), text_color=FTBTheme.ACCENT).pack(side=tk.RIGHT, padx=5)
                
                ctk.CTkLabel(race_card, text="", height=5).pack()
            
            # === DRIVER CHAMPIONSHIP STANDINGS ===
            standings_card = ctk.CTkFrame(self.drivers_standings_container, fg_color=FTBTheme.CARD, corner_radius=8)
            standings_card.pack(fill=tk.BOTH, expand=True)
            
            league_label = (selected_league.name if selected_league and selected_league.name else "Unknown League") if selected_league else (f"Tier {selected_tier}" if selected_tier else "All Tiers")
            ctk.CTkLabel(
                standings_card,
                text=f"🏎️ Driver Championship Standings - {league_label}",
                font=("Arial", 14, "bold"),
                text_color=FTBTheme.TEXT
            ).pack(anchor=tk.W, padx=15, pady=(10, 5))
            
            # Collect driver championship data
            drivers_data = []
            for lg in leagues_to_show:
                if not lg or not hasattr(lg, 'driver_championship') or not hasattr(lg, 'teams'):
                    continue
                for driver_name, points in lg.driver_championship.items():
                    if not driver_name:
                        continue
                    # Find driver and team
                    driver_obj = None
                    team_name = ""
                    for team in lg.teams:
                        if not team or not hasattr(team, 'drivers'):
                            continue
                        for driver in team.drivers:
                            if driver and driver.name == driver_name:
                                driver_obj = driver
                                team_name = team.name if team.name else "Unknown Team"
                                break
                        if driver_obj:
                            break
                    
                    if not driver_obj:
                        continue
                    
                    # Calculate stats from archive results when available
                    league_id = getattr(lg, 'league_id', None)
                    if use_archive:
                        league_results = archive_by_league.get(league_id, [])
                        wins = 0
                        podiums = 0
                        races = 0
                        dnfs = 0
                        for result in league_results:
                            for entry in result.get('finish_positions', []):
                                if entry.get('driver') != driver_name:
                                    continue
                                position = entry.get('position', 99)
                                races += 1
                                if position == 1:
                                    wins += 1
                                if position <= 3:
                                    podiums += 1
                                if entry.get('status') != 'finished':
                                    dnfs += 1
                    else:
                        wins = sum(1 for e in self.sim_state.event_history if e.category == "race_result" and e.data.get('driver') == driver_name and e.data.get('position') == 1 and e.data.get('league_id') == league_id)
                        podiums = sum(1 for e in self.sim_state.event_history if e.category == "race_result" and e.data.get('driver') == driver_name and e.data.get('position', 99) <= 3 and e.data.get('league_id') == league_id)
                        races = sum(1 for e in self.sim_state.event_history if e.category == "race_result" and e.data.get('driver') == driver_name and e.data.get('league_id') == league_id)
                        dnfs = sum(1 for e in self.sim_state.event_history if e.category == "race_result" and e.data.get('driver') == driver_name and e.data.get('status') != 'finished' and e.data.get('league_id') == league_id)
                    
                    is_player_driver = self.sim_state.player_team and team_name == self.sim_state.player_team.name
                    
                    drivers_data.append({
                        'position': 0,
                        'name': driver_name,
                        'team': team_name,
                        'points': points,
                        'wins': wins,
                        'podiums': podiums,
                        'races': races,
                        'dnfs': dnfs,
                        'is_player': is_player_driver
                    })
            
            # Sort by points and assign positions
            drivers_data.sort(key=lambda d: d['points'], reverse=True)
            for i, driver in enumerate(drivers_data, 1):
                driver['position'] = i
            
            # Display sortable table
            if drivers_data:
                header_row = ctk.CTkFrame(standings_card, fg_color=FTBTheme.SURFACE, corner_radius=4)
                header_row.pack(fill=tk.X, padx=15, pady=(5, 2))
                
                def make_driver_sort_command(column):
                    def sort_command():
                        if self._drivers_sort_column == column:
                            self._drivers_sort_reverse = not self._drivers_sort_reverse
                        else:
                            self._drivers_sort_column = column
                            self._drivers_sort_reverse = (column != 'position')
                        self._refresh_racing_stats()
                    return sort_command
                
                ctk.CTkButton(header_row, text="Pos ↕", command=make_driver_sort_command('position'), width=45, height=24, font=("Arial", 9, "bold"), fg_color="transparent", hover_color=FTBTheme.CARD_HOVER).pack(side=tk.LEFT, padx=1)
                ctk.CTkButton(header_row, text="Driver ↕", command=make_driver_sort_command('name'), width=140, height=24, font=("Arial", 9, "bold"), fg_color="transparent", hover_color=FTBTheme.CARD_HOVER, anchor="w").pack(side=tk.LEFT, padx=1)
                ctk.CTkButton(header_row, text="Team ↕", command=make_driver_sort_command('team'), width=120, height=24, font=("Arial", 9, "bold"), fg_color="transparent", hover_color=FTBTheme.CARD_HOVER, anchor="w").pack(side=tk.LEFT, padx=1)
                ctk.CTkButton(header_row, text="Pts ↕", command=make_driver_sort_command('points'), width=55, height=24, font=("Arial", 9, "bold"), fg_color="transparent", hover_color=FTBTheme.CARD_HOVER).pack(side=tk.LEFT, padx=1)
                ctk.CTkButton(header_row, text="W ↕", command=make_driver_sort_command('wins'), width=40, height=24, font=("Arial", 9, "bold"), fg_color="transparent", hover_color=FTBTheme.CARD_HOVER).pack(side=tk.LEFT, padx=1)
                ctk.CTkButton(header_row, text="P ↕", command=make_driver_sort_command('podiums'), width=40, height=24, font=("Arial", 9, "bold"), fg_color="transparent", hover_color=FTBTheme.CARD_HOVER).pack(side=tk.LEFT, padx=1)
                ctk.CTkButton(header_row, text="R ↕", command=make_driver_sort_command('races'), width=40, height=24, font=("Arial", 9, "bold"), fg_color="transparent", hover_color=FTBTheme.CARD_HOVER).pack(side=tk.LEFT, padx=1)
                ctk.CTkButton(header_row, text="DNF ↕", command=make_driver_sort_command('dnfs'), width=50, height=24, font=("Arial", 9, "bold"), fg_color="transparent", hover_color=FTBTheme.CARD_HOVER).pack(side=tk.LEFT, padx=1)
                
                # Re-sort if needed
                if hasattr(self, '_drivers_sort_column'):
                    drivers_data.sort(key=lambda d: d[self._drivers_sort_column], reverse=self._drivers_sort_reverse)
                
                # Display rows
                for driver in drivers_data:
                    row = ctk.CTkFrame(standings_card, fg_color="transparent")
                    row.pack(fill=tk.X, padx=15, pady=1)
                    
                    pos_color = FTBTheme.SUCCESS if driver['position'] <= 3 else FTBTheme.TEXT
                    driver_color = FTBTheme.ACCENT if driver['is_player'] else FTBTheme.TEXT
                    driver_weight = "bold" if driver['is_player'] else "normal"
                    
                    ctk.CTkLabel(row, text=f"{driver['position']}", font=("Arial", 10), text_color=pos_color, width=45).pack(side=tk.LEFT, padx=1)
                    ctk.CTkLabel(row, text=driver['name'], font=("Arial", 10, driver_weight), text_color=driver_color, width=140, anchor="w").pack(side=tk.LEFT, padx=1)
                    ctk.CTkLabel(row, text=driver['team'], font=("Arial", 9), text_color=FTBTheme.TEXT_MUTED, width=120, anchor="w").pack(side=tk.LEFT, padx=1)
                    ctk.CTkLabel(row, text=f"{driver['points']}", font=("Arial", 10, "bold"), text_color=FTBTheme.ACCENT, width=55).pack(side=tk.LEFT, padx=1)
                    ctk.CTkLabel(row, text=f"{driver['wins']}", font=("Arial", 10), width=40).pack(side=tk.LEFT, padx=1)
                    ctk.CTkLabel(row, text=f"{driver['podiums']}", font=("Arial", 10), width=40).pack(side=tk.LEFT, padx=1)
                    ctk.CTkLabel(row, text=f"{driver['races']}", font=("Arial", 10), text_color=FTBTheme.TEXT_MUTED, width=40).pack(side=tk.LEFT, padx=1)
                    dnf_color = FTBTheme.DANGER if driver['dnfs'] > 0 else FTBTheme.TEXT_MUTED
                    ctk.CTkLabel(row, text=f"{driver['dnfs']}", font=("Arial", 10), text_color=dnf_color, width=50).pack(side=tk.LEFT, padx=1)
                
                ctk.CTkLabel(standings_card, text="", height=5).pack()
            else:
                ctk.CTkLabel(standings_card, text="No driver championship data available.", font=("Arial", 11), text_color=FTBTheme.TEXT_MUTED).pack(pady=20)
            
            # === DRIVER PERFORMANCE TRENDS ===
            history_card = ctk.CTkFrame(self.drivers_history_container, fg_color=FTBTheme.CARD, corner_radius=8)
            history_card.pack(fill=tk.X)
            
            ctk.CTkLabel(history_card, text="📈 Driver Performance Trends", font=("Arial", 12, "bold"), text_color=FTBTheme.TEXT_MUTED).pack(pady=10)
            ctk.CTkLabel(history_card, text="Rating changes and consistency metrics coming soon...", font=("Arial", 10), text_color=FTBTheme.TEXT_MUTED).pack(pady=5)

        
        def _build_analytics_tab(self):
            """Build Analytics tab - Performance Comparison, Entity Stats"""
            tab = self.tab_analytics
            
            # Main scrollable container
            container = ctk.CTkScrollableFrame(tab, fg_color="transparent")
            container.pack(fill=tk.BOTH, expand=True)
            
            # Performance Comparison Card
            comparison_card = ctk.CTkFrame(container, fg_color=FTBTheme.CARD, corner_radius=8)
            comparison_card.pack(fill=tk.X, padx=10, pady=(10, 10))

            # Header with refresh button
            comparison_header = ctk.CTkFrame(comparison_card, fg_color="transparent")
            comparison_header.pack(fill=tk.X, padx=15, pady=(15, 10))

            ctk.CTkLabel(
                comparison_header,
                text="📊 Team Performance Comparison",
                font=("Arial", 16, "bold"),
                text_color=FTBTheme.TEXT
            ).pack(side=tk.LEFT)

            ctk.CTkButton(
                comparison_header,
                text="🔄 Refresh",
                command=self._refresh_analytics,
                fg_color=FTBTheme.ACCENT,
                hover_color=FTBTheme.ACCENT_HOVER,
                width=100,
                height=30,
                font=("Arial", 11)
            ).pack(side=tk.RIGHT)

            self.comparison_table_container = ctk.CTkFrame(comparison_card, fg_color="transparent")
            self.comparison_table_container.pack(fill=tk.X, padx=15, pady=(0, 15))
            
            # Entity Analytics Card
            entity_card = ctk.CTkFrame(container, fg_color=FTBTheme.CARD, corner_radius=8)
            entity_card.pack(fill=tk.BOTH, expand=True, padx=10, pady=(0, 10))
            
            ctk.CTkLabel(
                entity_card,
                text="👥 Entity Performance Analytics",
                font=("Arial", 14, "bold"),
                text_color=FTBTheme.TEXT
            ).pack(padx=15, pady=(15, 10), anchor="w")
            
            self.entity_analytics_container = ctk.CTkFrame(entity_card, fg_color="transparent")
            self.entity_analytics_container.pack(fill=tk.BOTH, expand=True, padx=15, pady=(0, 15))
        
        def _refresh_analytics(self):
            """Refresh analytics displays"""
            if not self.sim_state or not self.sim_state.player_team:
                return
            
            # Performance comparison table
            for widget in self.comparison_table_container.winfo_children():
                widget.destroy()
            
            player_team = self.sim_state.player_team
            
            # Get league stats
            player_league = None
            for league in self.sim_state.leagues.values():
                if player_team in league.teams:
                    player_league = league
                    break
            
            if player_league:
                # Calculate tier averages
                championship_standings = player_league.championship_table
                
                # Get player's points
                player_points = championship_standings.get(player_team.name, 0)
                
                # Calculate tier average
                if championship_standings:
                    tier_avg_points = sum(championship_standings.values()) / len(championship_standings)
                else:
                    tier_avg_points = 0
                
                # Get leader's points
                if championship_standings:
                    leader_points = max(championship_standings.values())
                else:
                    leader_points = 0
                
                # Calculate team's average car rating
                player_car_rating = player_team.car.overall_rating if player_team.car else 50.0
                
                # Calculate tier average car rating (simplified)
                tier_avg_car_rating = sum(
                    t.car.overall_rating for t in player_league.teams if t.car
                ) / len(player_league.teams) if player_league.teams else 50.0
                
                # Get leader's car rating
                leader_car_rating = max(
                    (t.car.overall_rating for t in player_league.teams if t.car),
                    default=50.0
                )
                
                # Build comparison table
                metrics = [
                    ("Championship Points", player_points, tier_avg_points, leader_points),
                    ("Car Rating", player_car_rating, tier_avg_car_rating, leader_car_rating),
                    ("Races Completed", self.sim_state.races_completed_this_season, self.sim_state.races_completed_this_season, self.sim_state.races_completed_this_season),
                ]
                
                # Add team budget comparison
                player_cash = player_team.budget.cash
                tier_avg_cash = sum(t.budget.cash for t in player_league.teams) / len(player_league.teams) if player_league.teams else 0
                leader_cash = max(t.budget.cash for t in player_league.teams) if player_league.teams else 0
                metrics.append(("Team Cash", player_cash, tier_avg_cash, leader_cash))
                
                # Header row
                header_row = ctk.CTkFrame(self.comparison_table_container, fg_color=FTBTheme.SURFACE, corner_radius=6)
                header_row.pack(fill=tk.X, pady=(0, 5))
                
                ctk.CTkLabel(
                    header_row,
                    text="Metric",
                    font=("Arial", 11, "bold"),
                    text_color=FTBTheme.TEXT,
                    width=150,
                    anchor="w"
                ).pack(side=tk.LEFT, padx=(10, 5), pady=8)
                
                ctk.CTkLabel(
                    header_row,
                    text="Your Team",
                    font=("Arial", 11, "bold"),
                    text_color=FTBTheme.ACCENT,
                    width=100
                ).pack(side=tk.LEFT, padx=5)
                
                ctk.CTkLabel(
                    header_row,
                    text="Tier Avg",
                    font=("Arial", 11, "bold"),
                    text_color=FTBTheme.TEXT_MUTED,
                    width=100
                ).pack(side=tk.LEFT, padx=5)
                
                ctk.CTkLabel(
                    header_row,
                    text="Leader",
                    font=("Arial", 11, "bold"),
                    text_color=FTBTheme.WARNING,
                    width=100
                ).pack(side=tk.LEFT, padx=5)
                
                # Data rows
                for metric_name, player_val, tier_avg_val, leader_val in metrics:
                    data_row = ctk.CTkFrame(self.comparison_table_container, fg_color="transparent")
                    data_row.pack(fill=tk.X, pady=2)
                    
                    ctk.CTkLabel(
                        data_row,
                        text=metric_name,
                        font=("Arial", 11),
                        text_color=FTBTheme.TEXT,
                        width=150,
                        anchor="w"
                    ).pack(side=tk.LEFT, padx=(10, 5), pady=5)
                    
                    # Format values based on metric type
                    if "Cash" in metric_name or "Budget" in metric_name:
                        player_str = format_currency(player_val)
                        tier_str = format_currency(tier_avg_val)
                        leader_str = format_currency(leader_val)
                    elif "Rating" in metric_name:
                        player_str = f"{player_val:.1f}"
                        tier_str = f"{tier_avg_val:.1f}"
                        leader_str = f"{leader_val:.1f}"
                    else:
                        player_str = f"{player_val:.0f}"
                        tier_str = f"{tier_avg_val:.1f}"
                        leader_str = f"{leader_val:.0f}"
                    
                    # Player value (with color indication)
                    player_color = FTBTheme.SUCCESS if player_val >= tier_avg_val else FTBTheme.TEXT
                    if player_val < tier_avg_val * 0.8:
                        player_color = FTBTheme.DANGER
                    
                    ctk.CTkLabel(
                        data_row,
                        text=player_str,
                        font=("Arial", 11, "bold"),
                        text_color=player_color,
                        width=100
                    ).pack(side=tk.LEFT, padx=5)
                    
                    ctk.CTkLabel(
                        data_row,
                        text=tier_str,
                        font=("Arial", 11),
                        text_color=FTBTheme.TEXT_MUTED,
                        width=100
                    ).pack(side=tk.LEFT, padx=5)
                    
                    ctk.CTkLabel(
                        data_row,
                        text=leader_str,
                        font=("Arial", 11),
                        text_color=FTBTheme.WARNING,
                        width=100
                    ).pack(side=tk.LEFT, padx=5)
            
            else:
                ctk.CTkLabel(
                    self.comparison_table_container,
                    text="No league data available",
                    font=("Arial", 11),
                    text_color=FTBTheme.TEXT_MUTED
                ).pack(pady=10)
            
            # Entity analytics
            for widget in self.entity_analytics_container.winfo_children():
                widget.destroy()
            
            all_entities = []
            all_entities.extend(player_team.drivers)
            all_entities.extend(player_team.engineers)
            all_entities.extend(player_team.mechanics)
            if player_team.strategist:
                all_entities.append(player_team.strategist)
            
            if not all_entities:
                ctk.CTkLabel(
                    self.entity_analytics_container,
                    text="No entities to analyze",
                    font=("Arial", 11),
                    text_color=FTBTheme.TEXT_MUTED
                ).pack(pady=20)
            else:
                # Sort by overall rating
                all_entities.sort(key=lambda e: e.overall_rating, reverse=True)
                
                for entity in all_entities:
                    entity_row = ctk.CTkFrame(
                        self.entity_analytics_container,
                        fg_color=FTBTheme.SURFACE,
                        corner_radius=6
                    )
                    entity_row.pack(fill=tk.X, pady=3)
                    
                    # Entity info
                    info_frame = ctk.CTkFrame(entity_row, fg_color="transparent")
                    info_frame.pack(side=tk.LEFT, fill=tk.BOTH, expand=True, padx=10, pady=8)
                    
                    ctk.CTkLabel(
                        info_frame,
                        text=entity.name,
                        font=("Arial", 11, "bold"),
                        text_color=FTBTheme.TEXT
                    ).pack(anchor="w")
                    
                    entity_type = type(entity).__name__
                    age = entity.age
                    ctk.CTkLabel(
                        info_frame,
                        text=f"{entity_type} • Age {age}",
                        font=("Arial", 9),
                        text_color=FTBTheme.TEXT_MUTED
                    ).pack(anchor="w")
                    
                    # Stats grid
                    stats_frame = ctk.CTkFrame(entity_row, fg_color="transparent")
                    stats_frame.pack(side=tk.RIGHT, padx=10)
                    
                    # Overall rating
                    rating = entity.overall_rating
                    rating_color = FTBTheme.get_stat_color(rating)
                    ctk.CTkLabel(
                        stats_frame,
                        text=f"OVR: {rating:.0f}",
                        font=("Arial", 10, "bold"),
                        text_color=rating_color,
                        width=70
                    ).pack(side=tk.LEFT, padx=3)
                    
                    # Potential (if available)
                    if hasattr(entity, 'potential'):
                        potential = entity.potential
                        pot_color = FTBTheme.get_stat_color(potential)
                        ctk.CTkLabel(
                            stats_frame,
                            text=f"POT: {potential:.0f}",
                            font=("Arial", 10),
                            text_color=pot_color,
                            width=70
                        ).pack(side=tk.LEFT, padx=3)
        
        def _build_sponsors_tab(self):
            """Build Sponsors tab - View sponsorship deals, offers, and performance"""
            tab = self.tab_sponsors
            
            # Main scrollable container
            container = ctk.CTkScrollableFrame(tab, fg_color="transparent")
            container.pack(fill=tk.BOTH, expand=True)
            
            # Header
            header = ctk.CTkFrame(container, fg_color=FTBTheme.CARD, corner_radius=8)
            header.pack(fill=tk.X, padx=10, pady=(10, 5))
            
            header_content = ctk.CTkFrame(header, fg_color="transparent")
            header_content.pack(fill=tk.X, padx=15, pady=15)
            
            ctk.CTkLabel(
                header_content,
                text="💰 Sponsorship Management",
                font=("Arial", 16, "bold"),
                text_color=FTBTheme.TEXT
            ).pack(side=tk.LEFT)
            
            ctk.CTkButton(
                header_content,
                text="🔄 Refresh All",
                command=self._force_sponsor_offers_refresh,
                fg_color=FTBTheme.BUTTON_SECONDARY,
                hover_color=FTBTheme.BUTTON_SECONDARY_HOVER,
                width=110,
                height=28,
                font=("Arial", 11)
            ).pack(side=tk.RIGHT)
            
            # Two-column layout: left = current sponsors, right = offers and metrics
            content_frame = ctk.CTkFrame(container, fg_color="transparent")
            content_frame.pack(fill=tk.BOTH, expand=True, padx=10, pady=(0, 10))
            content_frame.grid_columnconfigure(0, weight=1)
            content_frame.grid_columnconfigure(1, weight=1)
            content_frame.grid_rowconfigure(0, weight=1)
            
            # Left column: Current sponsors
            left_col = ctk.CTkFrame(content_frame, fg_color="transparent")
            left_col.grid(row=0, column=0, sticky="nsew", padx=(0, 5))
            
            current_header = ctk.CTkFrame(left_col, fg_color=FTBTheme.CARD, corner_radius=6)
            current_header.pack(fill=tk.X, pady=(0, 5))
            
            current_header_content = ctk.CTkFrame(current_header, fg_color="transparent")
            current_header_content.pack(fill=tk.X, padx=10, pady=8)
            
            ctk.CTkLabel(
                current_header_content,
                text="🏢 Current Sponsors",
                font=("Arial", 14, "bold"),
                text_color=FTBTheme.TEXT
            ).pack(side=tk.LEFT)
            
            ctk.CTkButton(
                current_header_content,
                text="↻ Refresh",
                command=self._refresh_sponsors,
                fg_color=FTBTheme.ACCENT,
                hover_color=FTBTheme.ACCENT_HOVER,
                width=90,
                height=26,
                font=("Arial", 10)
            ).pack(side=tk.RIGHT)
            
            self.current_sponsors_container = ctk.CTkFrame(left_col, fg_color="transparent")
            self.current_sponsors_container.pack(fill=tk.BOTH, expand=True)
            
            # Right column: Offers and metrics
            right_col = ctk.CTkFrame(content_frame, fg_color="transparent")
            right_col.grid(row=0, column=1, sticky="nsew", padx=(5, 0))
            
            # Performance metrics
            metrics_header = ctk.CTkFrame(right_col, fg_color=FTBTheme.CARD, corner_radius=6)
            metrics_header.pack(fill=tk.X, pady=(0, 5))
            ctk.CTkLabel(
                metrics_header,
                text="📊 Performance vs Expectations",
                font=("Arial", 13, "bold"),
                text_color=FTBTheme.TEXT
            ).pack(padx=10, pady=8, anchor="w")
            
            self.sponsor_metrics_container = ctk.CTkFrame(right_col, fg_color=FTBTheme.CARD, corner_radius=6)
            self.sponsor_metrics_container.pack(fill=tk.X, pady=(0, 10))
            
            # Pending offers
            offers_header = ctk.CTkFrame(right_col, fg_color=FTBTheme.CARD, corner_radius=6)
            offers_header.pack(fill=tk.X, pady=(0, 5))
            
            offers_header_content = ctk.CTkFrame(offers_header, fg_color="transparent")
            offers_header_content.pack(fill=tk.X, padx=10, pady=8)
            
            ctk.CTkLabel(
                offers_header_content,
                text="📨 Pending Offers",
                font=("Arial", 13, "bold"),
                text_color=FTBTheme.TEXT
            ).pack(side=tk.LEFT)
            
            ctk.CTkButton(
                offers_header_content,
                text="🔄 Refresh",
                command=self._force_sponsor_offers_refresh,
                fg_color=FTBTheme.BUTTON_SECONDARY,
                hover_color=FTBTheme.BUTTON_SECONDARY_HOVER,
                width=90,
                height=24,
                font=("Arial", 10)
            ).pack(side=tk.RIGHT)
            
            self.pending_offers_container = ctk.CTkFrame(right_col, fg_color="transparent")
            self.pending_offers_container.pack(fill=tk.BOTH, expand=True)
        
        def _build_audio_settings_tab(self):
            """Build Audio Settings tab - Control volume levels for different audio channels"""
            tab = self.tab_audio_settings
            
            # Title and description
            header = ctk.CTkFrame(tab, fg_color=FTBTheme.CARD, corner_radius=6)
            header.pack(fill=tk.X, padx=10, pady=(10, 5))
            
            ctk.CTkLabel(
                header,
                text="🔊 Audio Settings",
                font=("Arial", 16, "bold"),
                text_color=FTBTheme.TEXT
            ).pack(padx=15, pady=(10, 5), anchor="w")
            
            ctk.CTkLabel(
                header,
                text="Adjust volume levels for different audio channels in the station",
                font=("Arial", 11),
                text_color=FTBTheme.TEXT_MUTED
            ).pack(padx=15, pady=(0, 10), anchor="w")
            
            # Main container with scrollable frame
            main_container = ctk.CTkScrollableFrame(
                tab,
                fg_color=FTBTheme.CARD,
                corner_radius=6,
                scrollbar_fg_color=FTBTheme.BG,
                scrollbar_button_color=FTBTheme.ACCENT,
                scrollbar_button_hover_color=FTBTheme.ACCENT_HOVER
            )
            main_container.pack(fill=tk.BOTH, expand=True, padx=10, pady=5)
            
            # Volume sliders storage
            self.audio_sliders = {}
            
            # Helper function to create a volume slider
            def create_volume_slider(parent, label, setting_key, min_val=0.0, max_val=2.0):
                slider_frame = ctk.CTkFrame(parent, fg_color="transparent")
                slider_frame.pack(fill=tk.X, padx=15, pady=8)
                
                # Label and value display frame
                label_frame = ctk.CTkFrame(slider_frame, fg_color="transparent")
                label_frame.pack(fill=tk.X, pady=(0, 5))
                label_frame.grid_columnconfigure(1, weight=1)
                
                # Slider label
                ctk.CTkLabel(
                    label_frame,
                    text=label,
                    font=("Arial", 12, "bold"),
                    text_color=FTBTheme.TEXT
                ).grid(row=0, column=0, sticky="w")
                
                # Value label
                value_label = ctk.CTkLabel(
                    label_frame,
                    text="",
                    font=("Arial", 10),
                    text_color=FTBTheme.TEXT_MUTED
                )
                value_label.grid(row=0, column=1, sticky="e")
                
                # Get current value from sim state
                current_value = 0.8
                if self.sim_state and hasattr(self.sim_state, 'audio_settings'):
                    current_value = self.sim_state.audio_settings.get(setting_key, 0.8)
                
                # Volume slider
                def on_slider_change(value):
                    value_label.configure(text=f"{int(value * 100)}%")
                    if self.sim_state and hasattr(self.sim_state, 'audio_settings'):
                        self.sim_state.audio_settings[setting_key] = value
                        self._save_audio_settings_to_manifest()
                        
                slider = ctk.CTkSlider(
                    slider_frame,
                    from_=min_val,
                    to=max_val,
                    number_of_steps=200,
                    command=on_slider_change,
                    progress_color=FTBTheme.ACCENT,
                    button_color=FTBTheme.ACCENT,
                    button_hover_color=FTBTheme.ACCENT_HOVER
                )
                slider.set(current_value)
                slider.pack(fill=tk.X, pady=(0, 5))
                
                # Update value label initially
                on_slider_change(current_value)
                
                # Store slider for updates
                self.audio_sliders[setting_key] = {
                    'slider': slider,
                    'label': value_label,
                    'callback': on_slider_change
                }
                
                return slider
            
            # Create volume sliders
            create_volume_slider(main_container, "🎵 Master Volume", "master_volume", 0.0, 1.0)
            create_volume_slider(main_container, "🎼 Theme Music", "music_volume", 0.0, 1.0)
            create_volume_slider(main_container, "🎤 Voice/Narrator", "voice_volume", 0.0, 2.0)
            create_volume_slider(main_container, "🗣️ Narrator TTS", "narrator_volume", 0.0, 2.0)
            create_volume_slider(main_container, "🏎️ World Audio", "world_volume", 0.0, 1.0)
            create_volume_slider(main_container, "🔔 UI Sounds", "ui_volume", 0.0, 1.0)
            
            # Separator
            separator = ctk.CTkFrame(main_container, fg_color=FTBTheme.BORDER, height=1)
            separator.pack(fill=tk.X, padx=15, pady=15)
            
            # Voice provider info
            voice_info_frame = ctk.CTkFrame(main_container, fg_color="transparent")
            voice_info_frame.pack(fill=tk.X, padx=15, pady=8)
            
            ctk.CTkLabel(
                voice_info_frame,
                text="🎙️ Voice Provider: Kokoro TTS",
                font=("Arial", 12, "bold"),
                text_color=FTBTheme.TEXT
            ).pack(anchor="w")
            
            ctk.CTkLabel(
                voice_info_frame,
                text="Current voices: am_adam (host), bf_alice (Formula Z news), bm_fable (narrator)",
                font=("Arial", 10),
                text_color=FTBTheme.TEXT_MUTED
            ).pack(anchor="w", pady=(2, 0))
            
            # Reset button
            reset_frame = ctk.CTkFrame(main_container, fg_color="transparent")
            reset_frame.pack(fill=tk.X, padx=15, pady=(10, 15))
            
            def reset_to_defaults():
                """Reset all volume settings to defaults"""
                defaults = {
                    'master_volume': 0.8,
                    'music_volume': 0.15,
                    'voice_volume': 1.1,
                    'narrator_volume': 1.2,
                    'world_volume': 0.5,
                    'ui_volume': 0.1
                }
                
                if self.sim_state and hasattr(self.sim_state, 'audio_settings'):
                    self.sim_state.audio_settings.update(defaults)
                    
                    # Update all sliders
                    for key, components in self.audio_sliders.items():
                        if key in defaults:
                            components['slider'].set(defaults[key])
                            components['callback'](defaults[key])
                    
                    self._save_audio_settings_to_manifest()
            
            ctk.CTkButton(
                reset_frame,
                text="🔄 Reset to Defaults",
                command=reset_to_defaults,
                fg_color=FTBTheme.ACCENT,
                hover_color=FTBTheme.ACCENT_HOVER,
                text_color="white",
                font=("Arial", 11, "bold"),
                height=32
            ).pack(anchor="w")
        
        def _build_penalties_tab(self):
            """Build Penalties tab - View penalty history and disciplinary records"""
            tab = self.tab_penalties
            
            # Main scrollable container
            container = ctk.CTkScrollableFrame(tab, fg_color="transparent")
            container.pack(fill=tk.BOTH, expand=True)
            
            # Header
            header = ctk.CTkFrame(container, fg_color=FTBTheme.CARD, corner_radius=8)
            header.pack(fill=tk.X, padx=10, pady=(10, 10))
            
            ctk.CTkLabel(
                header,
                text="⚠️ Penalty History",
                font=("Arial", 16, "bold"),
                text_color=FTBTheme.TEXT
            ).pack(padx=15, pady=15, anchor="w")
            
            # Penalties list container
            self.penalties_list_container = ctk.CTkFrame(container, fg_color="transparent")
            self.penalties_list_container.pack(fill=tk.BOTH, expand=True, padx=10, pady=(0, 10))
        
        def _build_history_tab(self):
            """Build History tab with Decisions, Results, and Transactions sub-tabs"""
            tab = self.tab_history
            
            # Create sub-tabview for history categories
            self.history_tabview = ctk.CTkTabview(tab, fg_color=FTBTheme.BG, segmented_button_selected_color=FTBTheme.ACCENT)
            self.history_tabview.pack(fill=tk.BOTH, expand=True, padx=5, pady=5)
            
            # Add sub-tabs
            self.history_tab_decisions = self.history_tabview.add("Decisions")
            self.history_tab_results = self.history_tabview.add("Results")
            self.history_tab_transactions = self.history_tabview.add("Transactions")
            
            # Build each sub-tab
            self._build_history_decisions_tab()
            self._build_history_results_tab()
            self._build_history_transactions_tab()
        
        def _build_history_decisions_tab(self):
            """Build Decisions history sub-tab"""
            tab = self.history_tab_decisions
            
            # Filter bar
            filter_frame = ctk.CTkFrame(tab, fg_color=FTBTheme.CARD, corner_radius=8)
            filter_frame.pack(fill=tk.X, padx=10, pady=10)
            
            ctk.CTkLabel(
                filter_frame,
                text="Filter:",
                font=("Arial", 12, "bold"),
                text_color=FTBTheme.TEXT
            ).pack(side=tk.LEFT, padx=10, pady=10)
            
            self.history_decision_filter = tk.StringVar(value="all")
            filter_options = ["All", "Hires", "Fires", "Contracts", "Budget", "Focus Changes"]
            for option in filter_options:
                btn = ctk.CTkButton(
                    filter_frame,
                    text=option,
                    width=100,
                    height=28,
                    fg_color=FTBTheme.PANEL,
                    hover_color=FTBTheme.ACCENT,
                    command=lambda o=option.lower().replace(" ", "_"): self._filter_decisions(o)
                )
                btn.pack(side=tk.LEFT, padx=5, pady=10)
            
            # Decisions list (scrollable)
            self.decisions_list_container = ctk.CTkScrollableFrame(tab, fg_color="transparent")
            self.decisions_list_container.pack(fill=tk.BOTH, expand=True, padx=10, pady=10)
        
        def _build_history_results_tab(self):
            """Build Race Results history sub-tab"""
            tab = self.history_tab_results
            
            # Filter bar
            filter_frame = ctk.CTkFrame(tab, fg_color=FTBTheme.CARD, corner_radius=8)
            filter_frame.pack(fill=tk.X, padx=10, pady=10)
            
            ctk.CTkLabel(
                filter_frame,
                text="Season:",
                font=("Arial", 12, "bold"),
                text_color=FTBTheme.TEXT
            ).pack(side=tk.LEFT, padx=10, pady=10)
            
            self.history_results_season_filter = ctk.CTkSegmentedButton(
                filter_frame,
                values=["Current", "All Seasons"],
                command=self._filter_race_results,
                fg_color=FTBTheme.PANEL,
                selected_color=FTBTheme.ACCENT,
                selected_hover_color=FTBTheme.ACCENT_HOVER
            )
            self.history_results_season_filter.set("Current")
            self.history_results_season_filter.pack(side=tk.LEFT, padx=10, pady=10)
            
            # Summary stats
            stats_frame = ctk.CTkFrame(tab, fg_color=FTBTheme.CARD, corner_radius=8)
            stats_frame.pack(fill=tk.X, padx=10, pady=10)
            
            self.results_wins_label = ctk.CTkLabel(stats_frame, text="Wins: 0", font=("Arial", 12), text_color=FTBTheme.TEXT)
            self.results_wins_label.pack(side=tk.LEFT, padx=20, pady=10)
            
            self.results_podiums_label = ctk.CTkLabel(stats_frame, text="Podiums: 0", font=("Arial", 12), text_color=FTBTheme.TEXT)
            self.results_podiums_label.pack(side=tk.LEFT, padx=20, pady=10)
            
            self.results_best_finish_label = ctk.CTkLabel(stats_frame, text="Best Finish: —", font=("Arial", 12), text_color=FTBTheme.TEXT)
            self.results_best_finish_label.pack(side=tk.LEFT, padx=20, pady=10)
            
            # Results list (scrollable table)
            self.results_list_container = ctk.CTkScrollableFrame(tab, fg_color="transparent")
            self.results_list_container.pack(fill=tk.BOTH, expand=True, padx=10, pady=10)
        
        def _build_history_transactions_tab(self):
            """Build Financial Transactions history sub-tab"""
            tab = self.history_tab_transactions
            
            # Filter bar
            filter_frame = ctk.CTkFrame(tab, fg_color=FTBTheme.CARD, corner_radius=8)
            filter_frame.pack(fill=tk.X, padx=10, pady=10)
            
            # Type filter
            ctk.CTkLabel(
                filter_frame,
                text="Type:",
                font=("Arial", 12, "bold"),
                text_color=FTBTheme.TEXT
            ).pack(side=tk.LEFT, padx=10, pady=10)
            
            self.history_txn_type_filter = ctk.CTkSegmentedButton(
                filter_frame,
                values=["All", "Income", "Expenses"],
                command=self._filter_transactions,
                fg_color=FTBTheme.PANEL,
                selected_color=FTBTheme.ACCENT,
                selected_hover_color=FTBTheme.ACCENT_HOVER
            )
            self.history_txn_type_filter.set("All")
            self.history_txn_type_filter.pack(side=tk.LEFT, padx=10, pady=10)
            
            # Category filter
            ctk.CTkLabel(
                filter_frame,
                text="Category:",
                font=("Arial", 12),
                text_color=FTBTheme.TEXT
            ).pack(side=tk.LEFT, padx=20, pady=10)
            
            self.history_txn_category_var = tk.StringVar(value="All")
            category_menu = ctk.CTkOptionMenu(
                filter_frame,
                variable=self.history_txn_category_var,
                values=["All", "Salaries", "Prizes", "Sponsors", "Penalties", "Signing Bonuses"],
                command=lambda _: self._filter_transactions(),
                fg_color=FTBTheme.PANEL,
                button_color=FTBTheme.ACCENT,
                button_hover_color=FTBTheme.ACCENT_HOVER
            )
            category_menu.pack(side=tk.LEFT, padx=5, pady=10)
            
            # Summary panel
            summary_frame = ctk.CTkFrame(tab, fg_color=FTBTheme.CARD, corner_radius=8)
            summary_frame.pack(fill=tk.X, padx=10, pady=10)
            
            self.txn_income_label = ctk.CTkLabel(summary_frame, text="Total Income: $0", font=("Arial", 12), text_color=FTBTheme.SUCCESS)
            self.txn_income_label.pack(side=tk.LEFT, padx=20, pady=10)
            
            self.txn_expenses_label = ctk.CTkLabel(summary_frame, text="Total Expenses: $0", font=("Arial", 12), text_color=FTBTheme.DANGER)
            self.txn_expenses_label.pack(side=tk.LEFT, padx=20, pady=10)
            
            self.txn_net_label = ctk.CTkLabel(summary_frame, text="Net Cashflow: $0", font=("Arial", 12, "bold"), text_color=FTBTheme.TEXT)
            self.txn_net_label.pack(side=tk.LEFT, padx=20, pady=10)
            
            # Transactions list (scrollable table)
            self.transactions_list_container = ctk.CTkScrollableFrame(tab, fg_color="transparent")
            self.transactions_list_container.pack(fill=tk.BOTH, expand=True, padx=10, pady=10)
        
        # ============================================================
        # AI ASSISTANT CALLBACK METHODS
        # ============================================================
        
        def _enable_delegation(self):
            """Enable AI delegation mode"""
            _dbg("[FTB UI] Enabling delegation")
            
            # Update UI state
            self.control_mode = "delegated"
            
            # Sync with sim state immediately 
            if self.sim_state:
                self.sim_state.control_mode = "delegated"
                self.sim_state.time_mode = "auto"
            
            # Update UI
            if hasattr(self, 'ai_mode_label'):
                self.ai_mode_label.configure(
                    text="DELEGATED - AI ACTIVE",
                    text_color=FTBTheme.SUCCESS
                )
            
            if hasattr(self, 'enable_delegation_btn'):
                self.enable_delegation_btn.configure(state="disabled")
            
            if hasattr(self, 'disable_delegation_btn'):
                self.disable_delegation_btn.configure(state="normal")
            
            # Send command to controller
            cmd_q = self.runtime.get("ftb_cmd_q")
            if cmd_q:
                cmd_q.put({
                    "cmd": "ftb_delegate"
                })
        
        def _disable_delegation(self):
            """Disable AI delegation mode"""
            _dbg("[FTB UI] Disabling delegation")
            
            # Update UI state
            self.control_mode = "human"
            
            # Sync with sim state immediately
            if self.sim_state:
                self.sim_state.control_mode = "human"
                self.sim_state.time_mode = "paused"  # Force back to manual control
            
            # Update local time mode to match
            self.time_mode = "paused"
            
            # Update time mode UI if it exists
            if hasattr(self, 'time_mode_selector'):
                self.time_mode_selector.set("Manual")
            
            # Update UI
            if hasattr(self, 'ai_mode_label'):
                self.ai_mode_label.configure(
                    text="MANUAL",
                    text_color=FTBTheme.WARNING
                )
            
            if hasattr(self, 'enable_delegation_btn'):
                self.enable_delegation_btn.configure(state="normal")
            
            if hasattr(self, 'disable_delegation_btn'):
                self.disable_delegation_btn.configure(state="disabled")
            
            # Send command to controller
            cmd_q = self.runtime.get("ftb_cmd_q")
            if cmd_q:
                cmd_q.put({"cmd": "ftb_regain_control"})
        
        def _apply_focus(self):
            """Apply a new delegation focus from user input"""
            focus_text = self.focus_text_entry.get().strip()
            
            if not focus_text:
                _dbg("[FTB UI] Cannot apply empty focus")
                return
            
            _dbg(f"[FTB UI] Applying delegation focus: '{focus_text}'")
            
            # Update UI immediately
            self.current_focus_label.configure(
                text=focus_text,
                text_color=FTBTheme.ACCENT
            )
            
            # Clear entry
            self.focus_text_entry.delete(0, 'end')
            
            # Send command to controller to translate and apply focus
            cmd_q = self.runtime.get("ftb_cmd_q")
            if cmd_q:
                cmd_q.put({
                    "cmd": "ftb_apply_focus",
                    "focus_text": focus_text
                })
            
            # Show toast notification
            try:
                import plugins.ftb_notifications as ftb_notif
                truncated_text = f"{focus_text[:50]}..." if len(focus_text) > 50 else focus_text
                ftb_notif.create_notification(
                    category='management',
                    title="Focus Applied",
                    message=truncated_text,
                    priority=50
                )
            except Exception as e:
                _dbg(f"[FTB UI] Failed to create notification: {e}")
        
        def _clear_focus(self):
            """Clear the current delegation focus"""
            _dbg("[FTB UI] Clearing delegation focus")
            
            # Update UI
            self.current_focus_label.configure(
                text="None (using base personality)",
                text_color=FTBTheme.TEXT
            )
            
            # Clear entry field
            self.focus_text_entry.delete(0, 'end')
            
            # Send command to controller
            cmd_q = self.runtime.get("ftb_cmd_q")
            if cmd_q:
                cmd_q.put({
                    "cmd": "ftb_clear_focus"
                })
            
            # Show toast notification
            try:
                import plugins.ftb_notifications as ftb_notif
                ftb_notif.create_notification(
                    category='management',
                    title="Focus Cleared",
                    message="Using base personality",
                    priority=50
                )
            except Exception as e:
                _dbg(f"[FTB UI] Failed to create notification: {e}")
        
        def _on_time_mode_change(self, value):
            """Handle time mode change from segmented button"""
            _dbg(f"[FTB UI] Time mode changed to: {value}")
            
            # Map UI values to internal modes
            mode_map = {
                "Manual": "manual",
                "Auto-slow": "auto_slow",
                "Auto-fast": "auto_fast"
            }
            
            mode = mode_map.get(value, "manual")
            self.time_mode = mode
            
            # Send command to controller
            cmd_q = self.runtime.get("ftb_cmd_q")
            if cmd_q:
                cmd_q.put({
                    "cmd": "ftb_set_time_mode",
                    "mode": mode
                })
        
        def _refresh_ai_decision_log(self):
            """Refresh AI decision log display"""
            if not hasattr(self, 'ai_decision_log'):
                return
            
            # Clear existing (except empty label)
            for widget in self.ai_decision_log.winfo_children():
                if widget != self.ai_empty_label:
                    widget.destroy()
            
            # Show/hide empty label
            if not self.decision_history:
                if hasattr(self, 'ai_empty_label'):
                    self.ai_empty_label.pack(pady=50)
                return
            else:
                if hasattr(self, 'ai_empty_label'):
                    self.ai_empty_label.pack_forget()
            
            # Display recent decisions (last 20)
            recent_decisions = self.decision_history[-20:]
            for decision in reversed(recent_decisions):
                self._create_decision_card(decision)
        
        def _create_decision_card(self, decision):
            """Create a card displaying an AI decision"""
            card = ctk.CTkFrame(self.ai_decision_log, fg_color=FTBTheme.CARD, corner_radius=6)
            card.pack(fill=tk.X, pady=5, padx=5)
            
            # Header with action and timestamp
            header_frame = ctk.CTkFrame(card, fg_color="transparent")
            header_frame.pack(fill=tk.X, padx=10, pady=(10, 5))
            
            action_text = decision.get('action', 'Unknown Action')
            ctk.CTkLabel(
                header_frame,
                text=action_text,
                font=("Arial", 12, "bold"),
                text_color=FTBTheme.ACCENT,
                anchor="w"
            ).pack(side=tk.LEFT, fill=tk.X, expand=True)
            
            tick = decision.get('tick', 0)
            ctk.CTkLabel(
                header_frame,
                text=f"Tick {tick}",
                font=("Arial", 10),
                text_color=FTBTheme.TEXT_MUTED
            ).pack(side=tk.RIGHT)
            
            # Cost/Impact
            if 'cost' in decision:
                cost_text = f"Cost: ${decision['cost']:,.0f}"
                ctk.CTkLabel(
                    card,
                    text=cost_text,
                    font=("Arial", 10),
                    text_color=FTBTheme.WARNING,
                    anchor="w"
                ).pack(fill=tk.X, padx=10, pady=2)
            
            # Reasoning
            if 'reasoning' in decision:
                reasoning_frame = ctk.CTkFrame(card, fg_color=FTBTheme.SURFACE, corner_radius=4)
                reasoning_frame.pack(fill=tk.X, padx=10, pady=(5, 10))
                
                ctk.CTkLabel(
                    reasoning_frame,
                    text=decision['reasoning'],
                    font=("Arial", 10),
                    text_color=FTBTheme.TEXT_MUTED,
                    anchor="w",
                    wraplength=400,
                    justify="left"
                ).pack(padx=8, pady=6, anchor="w")
        
        # ============================================================
        # TAB REFRESH METHODS
        # ============================================================

        def _update_sidebar(self):
            """Refresh auxiliary panels if present."""
            try:
                if hasattr(self, "financial_overview_container") and self.financial_overview_container.winfo_exists():
                    self._refresh_financial_overview()
            except Exception:
                pass
        
        def _force_dashboard_refresh(self):
            """Force an immediate dashboard refresh (manually triggered)"""
            _dbg(f"[FTB WIDGET {self.widget_id}] 🔄 MANUAL REFRESH TRIGGERED - Dashboard")
            controller = self.runtime.get("ftb_controller")
            if not controller or not controller.state:
                _dbg(f"[FTB WIDGET {self.widget_id}] ❌ Cannot refresh - no controller or state")
                return
            
            # Force update by resetting counter and calling update
            self._update_counter = 0
            self._last_tick = None  # Force tick change detection
            
            _dbg(f"[FTB WIDGET {self.widget_id}] 🔄 Acquiring lock for manual refresh...")
            try:
                lock_acquired = controller.state_lock.acquire(blocking=True, timeout=2.0)
                if lock_acquired:
                    try:
                        _dbg(f"[FTB WIDGET {self.widget_id}] 🔒 Lock acquired, updating from state...")
                        self.update_from_state(controller.state)
                        _dbg(f"[FTB WIDGET {self.widget_id}] ✅ Manual refresh complete")
                    finally:
                        controller.state_lock.release()
                        _dbg(f"[FTB WIDGET {self.widget_id}] 🔓 Lock released")
                else:
                    _dbg(f"[FTB WIDGET {self.widget_id}] ⏸️ Could not acquire lock for refresh")
            except Exception as e:
                import traceback
                _dbg(f"[FTB WIDGET {self.widget_id}] ❌ Error during manual refresh: {e}")
                traceback.print_exc()
        
        def _force_parts_marketplace_refresh(self):
            """Force an immediate parts marketplace + inventory refresh (manually triggered)"""
            _dbg(f"[FTB WIDGET {self.widget_id}] 🔄 MANUAL REFRESH TRIGGERED - Parts Marketplace")
            controller = self.runtime.get("ftb_controller")
            if not controller or not controller.state:
                _dbg(f"[FTB WIDGET {self.widget_id}] ❌ Cannot refresh marketplace - no controller or state")
                return
            
            try:
                lock_acquired = controller.state_lock.acquire(blocking=True, timeout=2.0)
                if lock_acquired:
                    try:
                        self.sim_state = controller.state
                        _dbg(f"[FTB WIDGET {self.widget_id}] 🔒 Lock acquired, refreshing parts marketplace...")
                        self._refresh_parts_inventory()
                        self._refresh_parts_marketplace()
                        _dbg(f"[FTB WIDGET {self.widget_id}] ✅ Parts marketplace refresh complete")
                    finally:
                        controller.state_lock.release()
                        _dbg(f"[FTB WIDGET {self.widget_id}] 🔓 Lock released")
                else:
                    _dbg(f"[FTB WIDGET {self.widget_id}] ⏸️ Could not acquire lock for marketplace refresh")
            except Exception as e:
                import traceback
                _dbg(f"[FTB WIDGET {self.widget_id}] ❌ Error during marketplace refresh: {e}")
                traceback.print_exc()
        
        def _force_sponsor_offers_refresh(self):
            """Force an immediate sponsor offers + current sponsors refresh (manually triggered)"""
            _dbg(f"[FTB WIDGET {self.widget_id}] 🔄 MANUAL REFRESH TRIGGERED - Sponsor Offers")
            controller = self.runtime.get("ftb_controller")
            if not controller or not controller.state:
                _dbg(f"[FTB WIDGET {self.widget_id}] ❌ Cannot refresh sponsors - no controller or state")
                return
            
            try:
                lock_acquired = controller.state_lock.acquire(blocking=True, timeout=2.0)
                if lock_acquired:
                    try:
                        self.sim_state = controller.state
                        _dbg(f"[FTB WIDGET {self.widget_id}] 🔒 Lock acquired, refreshing sponsors...")
                        self._refresh_sponsors()
                        _dbg(f"[FTB WIDGET {self.widget_id}] ✅ Sponsor offers refresh complete")
                    finally:
                        controller.state_lock.release()
                        _dbg(f"[FTB WIDGET {self.widget_id}] 🔓 Lock released")
                else:
                    _dbg(f"[FTB WIDGET {self.widget_id}] ⏸️ Could not acquire lock for sponsor refresh")
            except Exception as e:
                import traceback
                _dbg(f"[FTB WIDGET {self.widget_id}] ❌ Error during sponsor refresh: {e}")
                traceback.print_exc()
        
        def _refresh_sponsors(self):
            """Refresh sponsors display"""
            _dbg(f"[FTB WIDGET {self.widget_id}] 🔄 MANUAL REFRESH TRIGGERED - Sponsors Tab")
            
            if not self.sim_state or not self.sim_state.player_team:
                _dbg(f"[FTB WIDGET {self.widget_id}] ❌ Cannot refresh sponsors - no state or player team")
                return
            if not self.current_sponsors_container or not self.current_sponsors_container.winfo_exists():
                _dbg(f"[FTB WIDGET {self.widget_id}] ❌ Cannot refresh sponsors - container doesn't exist")
                return
            if not self.pending_offers_container or not self.pending_offers_container.winfo_exists():
                _dbg(f"[FTB WIDGET {self.widget_id}] ❌ Cannot refresh sponsors - offers container doesn't exist")
                return
            
            _dbg(f"[FTB WIDGET {self.widget_id}] 🔄 Refreshing sponsors data from state...")
            team = self.sim_state.player_team
            
            # === Current Sponsors ==
            for widget in self.current_sponsors_container.winfo_children():
                widget.destroy()
            
            active_sponsors = self.sim_state.sponsorships.get(team.name, [])
            
            if not active_sponsors:
                empty_label = ctk.CTkLabel(
                    self.current_sponsors_container,
                    text="No active sponsors\nSeek sponsorship offers to fund your team",
                    font=("Arial", 12),
                    text_color=FTBTheme.TEXT_MUTED,
                    justify="center"
                )
                empty_label.pack(pady=30)
            else:
                for idx, sponsor in enumerate(active_sponsors):
                    card = ctk.CTkFrame(self.current_sponsors_container, fg_color=FTBTheme.CARD, corner_radius=6)
                    card.pack(fill=tk.X, pady=(0, 8))
                    
                    # Sponsor header
                    header_frame = ctk.CTkFrame(card, fg_color="transparent")
                    header_frame.pack(fill=tk.X, padx=10, pady=(10, 5))
                    
                    name_label = ctk.CTkLabel(
                        header_frame,
                        text=sponsor.sponsor_name,
                        font=("Arial", 13, "bold"),
                        text_color=FTBTheme.TEXT
                    )
                    name_label.pack(side=tk.LEFT)
                    
                    tier_badge = ctk.CTkLabel(
                        header_frame,
                        text=f" {sponsor.tier.upper()} ",
                        font=("Arial", 9, "bold"),
                        fg_color=FTBTheme.ACCENT,
                        corner_radius=4,
                        text_color="white"
                    )
                    tier_badge.pack(side=tk.LEFT, padx=5)
                    
                    # Payment info
                    payment_label = ctk.CTkLabel(
                        card,
                        text=f"${sponsor.base_payment_per_season:,}/season",
                        font=("Arial", 12),
                        text_color=FTBTheme.SUCCESS
                    )
                    payment_label.pack(padx=10, anchor="w")
                    
                    # Contract duration
                    seasons_left = sponsor.duration_seasons - sponsor.seasons_active
                    duration_label = ctk.CTkLabel(
                        card,
                        text=f"Contract: {seasons_left} season{'s' if seasons_left != 1 else ''} remaining",
                        font=("Arial", 10),
                        text_color=FTBTheme.TEXT_MUTED
                    )
                    duration_label.pack(padx=10, anchor="w")
                    
                    # Industry/sub-industry
                    if sponsor.industry and sponsor.sub_industry:
                        industry_label = ctk.CTkLabel(
                            card,
                            text=f"Industry: {sponsor.industry.replace('_', ' ').title()} / {sponsor.sub_industry.replace('_', ' ').title()}",
                            font=("Arial", 9),
                            text_color=FTBTheme.TEXT_MUTED
                        )
                        industry_label.pack(padx=10, anchor="w")
                    
                    # Confidence bar
                    conf_frame = ctk.CTkFrame(card, fg_color="transparent")
                    conf_frame.pack(fill=tk.X, padx=10, pady=(5, 0))
                    
                    ctk.CTkLabel(
                        conf_frame,
                        text="Confidence:",
                        font=("Arial", 10),
                        text_color=FTBTheme.TEXT_MUTED
                    ).pack(side=tk.LEFT)
                    
                    # Color-coded confidence
                    if sponsor.confidence >= 60:
                        conf_color = FTBTheme.SUCCESS
                    elif sponsor.confidence >= 40:
                        conf_color = "#FFA500"  # Orange
                    else:
                        conf_color = FTBTheme.DANGER
                    
                    conf_bar = ctk.CTkProgressBar(conf_frame, width=150, height=10, progress_color=conf_color)
                    conf_bar.set(sponsor.confidence / 100.0)
                    conf_bar.pack(side=tk.LEFT, padx=5)
                    
                    ctk.CTkLabel(
                        conf_frame,
                        text=f"{sponsor.confidence:.0f}%",
                        font=("Arial", 10, "bold"),
                        text_color=conf_color
                    ).pack(side=tk.LEFT)
                    
                    # Warning indicator
                    if sponsor.warning_issued:
                        warning_label = ctk.CTkLabel(
                            card,
                            text="⚠️ Performance warning issued",
                            font=("Arial", 9),
                            text_color=FTBTheme.DANGER
                        )
                        warning_label.pack(padx=10, pady=(2, 0), anchor="w")
                    
                    # Exclusivity clauses
                    if sponsor.exclusivity_clauses:
                        excl_label = ctk.CTkLabel(
                            card,
                            text=f"Exclusivity: {', '.join([c.replace('_', ' ') for c in sponsor.exclusivity_clauses[:2]])}",
                            font=("Arial", 8),
                            text_color=FTBTheme.TEXT_MUTED
                        )
                        excl_label.pack(padx=10, pady=(2, 10), anchor="w")
                    else:
                        # Add bottom padding if no exclusivity
                        ctk.CTkLabel(card, text="", height=10).pack()

                    # Sponsor needs transparency
                    needs_lines = []
                    if sponsor.infrastructure_demands:
                        infra_parts = [f"{k.replace('_', ' ')} {int(v)}" for k, v in sponsor.infrastructure_demands.items()]
                        needs_lines.append(f"Infrastructure: {', '.join(infra_parts)}")
                    if sponsor.evaluation_cadence:
                        needs_lines.append(f"Evaluation: every {sponsor.evaluation_cadence} days")
                    if sponsor.contract_behavior_json:
                        try:
                            behavior = json.loads(sponsor.contract_behavior_json)
                            loyalty = behavior.get('loyalty')
                            pressure = behavior.get('pressure_threshold')
                            if loyalty is not None:
                                needs_lines.append(f"Loyalty: {int(loyalty * 100)}%")
                            if pressure is not None:
                                needs_lines.append(f"Pressure threshold: {int(pressure * 100)}%")
                        except Exception:
                            pass
                    if needs_lines:
                        ctk.CTkLabel(
                            card,
                            text="Needs: " + " | ".join(needs_lines),
                            font=("Arial", 8),
                            text_color=FTBTheme.TEXT_MUTED
                        ).pack(padx=10, pady=(0, 10), anchor="w")
            
            # === Performance Metrics ===
            for widget in self.sponsor_metrics_container.winfo_children():
                widget.destroy()
            
            if active_sponsors:
                # Calculate average confidence
                avg_confidence = sum(s.confidence for s in active_sponsors) / len(active_sponsors)
                
                # Get championship position
                championship_pos = team.standing_metrics.get('championship_position', 0)
                all_teams = ([self.sim_state.player_team] if self.sim_state.player_team else []) + self.sim_state.ai_teams
                total_teams = len([t for t in all_teams if t.tier == team.tier])
                position_percentile = (1.0 - (championship_pos - 1) / max(1, total_teams - 1)) * 100 if championship_pos > 0 else 50
                
                # Points
                points = team.standing_metrics.get('points', 0)
                
                # Reputation
                reputation = team.standing_metrics.get('reputation', 50)

                # League position (derived from standings)
                league_position = championship_pos
                if team.league_id and team.league_id in self.sim_state.leagues:
                    league = self.sim_state.leagues.get(team.league_id)
                    if league and league.championship_table:
                        sorted_table = sorted(league.championship_table.items(), key=lambda x: x[1], reverse=True)
                        for idx, (team_name, _) in enumerate(sorted_table, 1):
                            if team_name == team.name:
                                league_position = idx
                                break
                
                # Create metrics display
                metrics_grid = ctk.CTkFrame(self.sponsor_metrics_container, fg_color="transparent")
                metrics_grid.pack(fill=tk.BOTH, padx=10, pady=10)
                
                # Grid layout for metrics
                metrics = [
                    ("Overall Sponsor Satisfaction", f"{avg_confidence:.0f}%", avg_confidence >= 60),
                    ("League Position", f"P{league_position if league_position > 0 else '—'}", position_percentile > 50),
                    ("Season Points", f"{points:.0f}", points > 10),
                    ("Team Reputation", f"{reputation:.0f}/100", reputation > 50)
                ]
                
                for i, (label, value, good) in enumerate(metrics):
                    metric_frame = ctk.CTkFrame(metrics_grid, fg_color="transparent")
                    metric_frame.grid(row=i, column=0, sticky="w", pady=2)
                    
                    icon = "✓" if good else "✗"
                    color = FTBTheme.SUCCESS if good else FTBTheme.TEXT_MUTED
                    
                    ctk.CTkLabel(
                        metric_frame,
                        text=f"{icon} {label}:",
                        font=("Arial", 10),
                        text_color=FTBTheme.TEXT_MUTED
                    ).pack(side=tk.LEFT)
                    
                    ctk.CTkLabel(
                        metric_frame,
                        text=value,
                        font=("Arial", 10, "bold"),
                        text_color=color
                    ).pack(side=tk.LEFT, padx=5)
            else:
                no_metrics_label = ctk.CTkLabel(
                    self.sponsor_metrics_container,
                    text="No sponsors to evaluate",
                    font=("Arial", 10),
                    text_color=FTBTheme.TEXT_MUTED
                )
                no_metrics_label.pack(padx=10, pady=10)
            
            # === Pending Offers ===
            for widget in self.pending_offers_container.winfo_children():
                widget.destroy()
            
            pending_offers = self.sim_state.pending_sponsor_offers.get(team.name, [])
            
            if not pending_offers:
                empty_label = ctk.CTkLabel(
                    self.pending_offers_container,
                    text="No pending offers\nOffers arrive monthly",
                    font=("Arial", 11),
                    text_color=FTBTheme.TEXT_MUTED,
                    justify="center"
                )
                empty_label.pack(pady=20)
            else:
                for idx, offer in enumerate(pending_offers):
                    card = ctk.CTkFrame(self.pending_offers_container, fg_color=FTBTheme.CARD, corner_radius=6)
                    card.pack(fill=tk.X, pady=(0, 8))
                    
                    # Offer header
                    header_frame = ctk.CTkFrame(card, fg_color="transparent")
                    header_frame.pack(fill=tk.X, padx=10, pady=(10, 5))
                    
                    name_label = ctk.CTkLabel(
                        header_frame,
                        text=offer.sponsor_name,
                        font=("Arial", 12, "bold"),
                        text_color=FTBTheme.TEXT
                    )
                    name_label.pack(side=tk.LEFT)
                    
                    tier_badge = ctk.CTkLabel(
                        header_frame,
                        text=f" {offer.financial_tier or offer.tier} ",
                        font=("Arial", 8, "bold"),
                        fg_color=FTBTheme.ACCENT,
                        corner_radius=3,
                        text_color="white"
                    )
                    tier_badge.pack(side=tk.LEFT, padx=5)
                    
                    # Offer details
                    payment_label = ctk.CTkLabel(
                        card,
                        text=f"💵 ${offer.base_payment_per_season:,}/season × {offer.duration_seasons} season{'s' if offer.duration_seasons != 1 else ''}",
                        font=("Arial", 11),
                        text_color=FTBTheme.SUCCESS
                    )
                    payment_label.pack(padx=10, anchor="w")
                    
                    # Contract type
                    type_label = ctk.CTkLabel(
                        card,
                        text=f"Type: {offer.contract_type.replace('_', ' ').title()}",
                        font=("Arial", 9),
                        text_color=FTBTheme.TEXT_MUTED
                    )
                    type_label.pack(padx=10, anchor="w")
                    
                    # Demands
                    if offer.activation_style_json:
                        try:
                            activation = json.loads(offer.activation_style_json)
                            demands = []
                            if activation.get('requires_podiums'):
                                demands.append("Podiums required")
                            if activation.get('requires_media_mentions'):
                                demands.append("Media exposure")
                            if activation.get('requires_driver_profile'):
                                demands.append("Driver profile")
                            
                            if demands:
                                demands_label = ctk.CTkLabel(
                                    card,
                                    text=f"Demands: {', '.join(demands)}",
                                    font=("Arial", 8),
                                    text_color="#FFA500"
                                )
                                demands_label.pack(padx=10, pady=(2, 0), anchor="w")
                        except:
                            pass

                    # Needs transparency (offers)
                    offer_needs = []
                    if offer.infrastructure_demands:
                        infra_parts = [f"{k.replace('_', ' ')} {int(v)}" for k, v in offer.infrastructure_demands.items()]
                        offer_needs.append(f"Infrastructure: {', '.join(infra_parts)}")
                    if offer.evaluation_cadence:
                        offer_needs.append(f"Evaluation: every {offer.evaluation_cadence} days")
                    if offer.contract_behavior_json:
                        try:
                            behavior = json.loads(offer.contract_behavior_json)
                            loyalty = behavior.get('loyalty')
                            pressure = behavior.get('pressure_threshold')
                            if loyalty is not None:
                                offer_needs.append(f"Loyalty: {int(loyalty * 100)}%")
                            if pressure is not None:
                                offer_needs.append(f"Pressure threshold: {int(pressure * 100)}%")
                        except Exception:
                            pass
                    if offer_needs:
                        ctk.CTkLabel(
                            card,
                            text="Needs: " + " | ".join(offer_needs),
                            font=("Arial", 8),
                            text_color=FTBTheme.TEXT_MUTED
                        ).pack(padx=10, pady=(2, 0), anchor="w")
                    
                    # Exclusivity warnings
                    if offer.exclusivity_clauses:
                        excl_label = ctk.CTkLabel(
                            card,
                            text=f"⚠️ Exclusivity: {', '.join([c.replace('_', ' ') for c in offer.exclusivity_clauses[:2]])}",
                            font=("Arial", 8),
                            text_color=FTBTheme.DANGER
                        )
                        excl_label.pack(padx=10, pady=(2, 0), anchor="w")
                    
                    # Action buttons
                    btn_frame = ctk.CTkFrame(card, fg_color="transparent")
                    btn_frame.pack(fill=tk.X, padx=10, pady=(5, 10))
                    
                    accept_btn = ctk.CTkButton(
                        btn_frame,
                        text="Accept",
                        width=80,
                        height=28,
                        fg_color=FTBTheme.SUCCESS,
                        hover_color="#2E7D32",
                        command=lambda i=idx: self._on_accept_sponsor(i)
                    )
                    accept_btn.pack(side=tk.LEFT, padx=(0, 5))
                    
                    reject_btn = ctk.CTkButton(
                        btn_frame,
                        text="Decline",
                        width=80,
                        height=28,
                        fg_color=FTBTheme.CARD,
                        hover_color=FTBTheme.TEXT_MUTED,
                        command=lambda i=idx: self._on_reject_sponsor(i)
                    )
                    reject_btn.pack(side=tk.LEFT)
            
            _dbg(f"[FTB WIDGET {self.widget_id}] ✅ Sponsors refresh complete - {len(active_sponsors)} active, {len(pending_offers)} pending")
        
        def _on_accept_sponsor(self, offer_index):
            """Handle sponsor offer acceptance"""
            if not self.sim_state or not self.sim_state.player_team:
                return
            
            team = self.sim_state.player_team
            action = Action("accept_sponsor", cost=0, target=offer_index)
            action.target = offer_index
            
            # Apply action
            events = FTBSimulation.apply_action(action, team, self.sim_state)
            self.sim_state.event_history.extend(events)
            
            # Refresh UI
            self._refresh_sponsors()
            self._update_sidebar()
            
            # Show feedback
            if events:
                success_event = [e for e in events if e.category == "sponsor_signed"]
                if success_event:
                    messagebox.showinfo("Sponsor Signed", f"Successfully signed {success_event[0].data.get('sponsor_name', 'sponsor')}!")
        
        def _on_reject_sponsor(self, offer_index):
            """Handle sponsor offer rejection"""
            if not self.sim_state or not self.sim_state.player_team:
                return
            
            team = self.sim_state.player_team
            action = Action("reject_sponsor", cost=0, target=offer_index)
            action.target = offer_index
            
            # Apply action
            events = FTBSimulation.apply_action(action, team, self.sim_state)
            self.sim_state.event_history.extend(events)
            
            # Refresh UI
            self._refresh_sponsors()
        
        def _refresh_penalties(self):
            """Refresh penalties display"""
            if not self.sim_state:
                return
            
            # Clear existing
            for widget in self.penalties_list_container.winfo_children():
                widget.destroy()
            
            if not self.sim_state.penalties:
                empty_label = ctk.CTkLabel(
                    self.penalties_list_container,
                    text="No penalties on record",
                    font=("Arial", 13),
                    text_color=FTBTheme.TEXT_MUTED
                )
                empty_label.pack(pady=50)
                return
            
            # Sort penalties by date descending (most recent first)
            penalties_sorted = sorted(
                self.sim_state.penalties,
                key=lambda x: x.race_day,
                reverse=True
            )
            
            for penalty in penalties_sorted[:50]:  # Show last 50 penalties
                # Find entity
                entity = None
                if penalty.entity_id:
                    entity = self.sim_state._find_entity_by_id(penalty.entity_id)
                
                # Penalty card
                card = ctk.CTkFrame(self.penalties_list_container, fg_color=FTBTheme.CARD, corner_radius=6)
                card.pack(fill=tk.X, pady=5)
                
                info_frame = ctk.CTkFrame(card, fg_color="transparent")
                info_frame.pack(fill=tk.X, padx=15, pady=10)
                
                # Entity name and team
                entity_name = entity.display_name if entity and hasattr(entity, 'display_name') else "Unknown"
                name_label = ctk.CTkLabel(
                    info_frame,
                    text=f"{entity_name} ({penalty.team_name})",
                    font=("Arial", 12, "bold"),
                    text_color=FTBTheme.TEXT,
                    anchor="w"
                )
                name_label.pack(side=tk.LEFT, fill=tk.X, expand=True)
                
                # Severity badge
                severity_colors = {
                    'minor': FTBTheme.TEXT_MUTED,
                    'medium': FTBTheme.WARNING,
                    'major': FTBTheme.DANGER
                }
                severity_color = severity_colors.get(penalty.severity, FTBTheme.TEXT_MUTED)
                
                severity_label = ctk.CTkLabel(
                    info_frame,
                    text=penalty.severity.upper(),
                    font=("Arial", 10, "bold"),
                    text_color=severity_color,
                    width=80
                )
                severity_label.pack(side=tk.RIGHT, padx=5)
                
                # Description and type
                details_frame = ctk.CTkFrame(card, fg_color="transparent")
                details_frame.pack(fill=tk.X, padx=15, pady=(0, 10))
                
                ctk.CTkLabel(
                    details_frame,
                    text=f"{penalty.description}  |  Type: {penalty.penalty_type}",
                    font=("Arial", 10),
                    text_color=FTBTheme.TEXT_MUTED,
                    anchor="w"
                ).pack(side=tk.LEFT)
        
        def _filter_decisions(self, filter_value):
            """Filter decision history by category"""
            self.history_decision_filter.set(filter_value)
            self._refresh_history_decisions()
        
        def _filter_race_results(self, season_filter):
            """Filter race results by season"""
            self._refresh_history_results()
        
        def _filter_transactions(self, *args):
            """Filter transactions by type and category"""
            self._refresh_history_transactions()
        
        def _refresh_history_decisions(self):
            """Refresh decision history display"""
            if not self.sim_state or not self.sim_state.state_db_path:
                return
            
            try:
                from plugins import ftb_state_db
                
                # Clear existing
                for widget in self.decisions_list_container.winfo_children():
                    widget.destroy()
                
                # Get filter value
                filter_val = self.history_decision_filter.get()
                categories = None if filter_val == "all" else [filter_val]
                
                # Query decisions
                decisions = ftb_state_db.query_decision_history(
                    self.sim_state.state_db_path,
                    limit=100,
                    categories=categories
                )
                
                if not decisions:
                    empty_label = ctk.CTkLabel(
                        self.decisions_list_container,
                        text="No decisions recorded yet",
                        font=("Arial", 13),
                        text_color=FTBTheme.TEXT_MUTED
                    )
                    empty_label.pack(pady=50)
                    return
                
                for decision in decisions:
                    card = ctk.CTkFrame(self.decisions_list_container, fg_color=FTBTheme.CARD, corner_radius=6)
                    card.pack(fill=tk.X, pady=5)
                    
                    info_frame = ctk.CTkFrame(card, fg_color="transparent")
                    info_frame.pack(fill=tk.X, padx=15, pady=10)
                    
                    # Date and category
                    date_label = ctk.CTkLabel(
                        info_frame,
                        text=f"Season {decision['season']}, Day {decision['game_day']}",
                        font=("Arial", 10),
                        text_color=FTBTheme.TEXT_MUTED
                    )
                    date_label.pack(anchor="w")
                    
                    # Decision text
                    decision_label = ctk.CTkLabel(
                        info_frame,
                        text=decision['decision_text'][:100],
                        font=("Arial", 12),
                        text_color=FTBTheme.TEXT,
                        anchor="w",
                        wraplength=600
                    )
                    decision_label.pack(anchor="w", pady=5)
                    
                    # Chosen option
                    choice_frame = ctk.CTkFrame(card, fg_color=FTBTheme.PANEL)
                    choice_frame.pack(fill=tk.X, padx=15, pady=(0, 10))
                    
                    ctk.CTkLabel(
                        choice_frame,
                        text=f"✓ {decision['chosen_option_label']}",
                        font=("Arial", 11, "bold"),
                        text_color=FTBTheme.SUCCESS
                    ).pack(side=tk.LEFT, padx=10, pady=5)
                    
                    if decision['immediate_cost'] > 0:
                        ctk.CTkLabel(
                            choice_frame,
                            text=f"Cost: ${decision['immediate_cost']:,.0f}",
                            font=("Arial", 10),
                            text_color=FTBTheme.DANGER
                        ).pack(side=tk.RIGHT, padx=10, pady=5)
                    
                    # Resolved by indicator
                    resolver_icon = "👤" if decision['resolved_by'] == 'player' else "🤖"
                    ctk.CTkLabel(
                        choice_frame,
                        text=f"{resolver_icon} {decision['resolved_by']}",
                        font=("Arial", 9),
                        text_color=FTBTheme.TEXT_MUTED
                    ).pack(side=tk.RIGHT, padx=10, pady=5)
            
            except Exception as e:
                _dbg(f"[FTB] Error refreshing decision history: {e}")
        
        def _refresh_history_results(self):
            """Refresh race results history display"""
            if not self.sim_state or not self.sim_state.state_db_path:
                return
            
            try:
                from plugins import ftb_state_db
                
                # Clear existing
                for widget in self.results_list_container.winfo_children():
                    widget.destroy()
                
                # Get season filter
                season_filter = self.history_results_season_filter.get()
                seasons = None if season_filter == "All Seasons" else [self.sim_state.season_number]
                
                # Query race results
                results = ftb_state_db.query_race_results(
                    self.sim_state.state_db_path,
                    seasons=seasons,
                    limit=100
                )
                
                if not results:
                    empty_label = ctk.CTkLabel(
                        self.results_list_container,
                        text="No race results recorded yet",
                        font=("Arial", 13),
                        text_color=FTBTheme.TEXT_MUTED
                    )
                    empty_label.pack(pady=50)
                    return
                
                # Update summary stats
                wins = sum(1 for r in results if any(p['position'] == 1 and p['team'] == self.sim_state.player_team.name for p in r['finish_positions']))
                podiums = sum(1 for r in results if any(p['position'] <= 3 and p['team'] == self.sim_state.player_team.name for p in r['finish_positions']))
                best_finish = min((p['position'] for r in results for p in r['finish_positions'] if p['team'] == self.sim_state.player_team.name), default=None)
                
                self.results_wins_label.configure(text=f"Wins: {wins}")
                self.results_podiums_label.configure(text=f"Podiums: {podiums}")
                self.results_best_finish_label.configure(text=f"Best Finish: P{best_finish}" if best_finish else "Best Finish: —")
                
                # Display results
                header_row = ctk.CTkFrame(self.results_list_container, fg_color=FTBTheme.PANEL, corner_radius=6)
                header_row.pack(fill=tk.X, pady=(0, 6), padx=4)

                headers = [
                    ("SEASON", 70),
                    ("ROUND", 60),
                    ("TRACK", 180),
                    ("QUALI", 70),
                    ("FINISH", 70),
                    ("DELTA", 45),
                    ("POINTS", 70),
                    ("LEAGUE POS", 90),
                    ("PRIZE", 90)
                ]

                for header, width in headers:
                    ctk.CTkLabel(
                        header_row,
                        text=header,
                        font=("Arial", 10, "bold"),
                        text_color=FTBTheme.TEXT_MUTED,
                        width=width,
                        anchor="w"
                    ).pack(side=tk.LEFT, padx=6, pady=6)

                for idx, result in enumerate(results):
                    row_color = FTBTheme.CARD if idx % 2 == 0 else FTBTheme.SURFACE
                    row = ctk.CTkFrame(self.results_list_container, fg_color=row_color, corner_radius=6)
                    row.pack(fill=tk.X, pady=2, padx=4)

                    player_finish = next((p for p in result['finish_positions'] if p['team'] == self.sim_state.player_team.name), None)
                    finish_pos = player_finish['position'] if player_finish else None
                    grid_pos = result.get('grid_position')

                    delta = "--"
                    if isinstance(grid_pos, int) and isinstance(finish_pos, int):
                        diff = grid_pos - finish_pos
                        delta = f"+{diff}" if diff > 0 else f"{diff}"

                    league = self.sim_state.leagues.get(result.get('league_id')) if self.sim_state and hasattr(self.sim_state, 'leagues') else None
                    points_table = []
                    if league:
                        tier_name = TIER_DISPLAY_NAMES.get(league.tier)
                        if tier_name:
                            points_table = WorldBuilder.TIER_CONFIG.get(tier_name, {}).get('points_table', [])
                    points_earned = "--"
                    if isinstance(finish_pos, int) and finish_pos > 0 and finish_pos <= len(points_table):
                        points_earned = f"{points_table[finish_pos - 1]:.0f}"

                    league_pos = result.get('championship_position_after')
                    league_pos_text = f"P{league_pos}" if league_pos else "--"
                    prize = result.get('prize_money', 0)
                    prize_text = f"${prize:,.0f}" if prize else "--"

                    values = [
                        (str(result['season']), 70),
                        (str(result['round_number']), 60),
                        (result['track_name'], 180),
                        (f"P{grid_pos}" if grid_pos else "--", 70),
                        (f"P{finish_pos}" if finish_pos else "--", 70),
                        (delta, 45),
                        (points_earned, 70),
                        (league_pos_text, 90),
                        (prize_text, 90)
                    ]

                    for value, width in values:
                        ctk.CTkLabel(
                            row,
                            text=value,
                            font=("Arial", 10),
                            text_color=FTBTheme.TEXT,
                            width=width,
                            anchor="w"
                        ).pack(side=tk.LEFT, padx=6, pady=6)
            
            except Exception as e:
                _dbg(f"[FTB] Error refreshing race results history: {e}")
        
        def _refresh_history_transactions(self):
            """Refresh financial transactions history display"""
            if not self.sim_state or not self.sim_state.state_db_path:
                return
            
            try:
                from plugins import ftb_state_db
                
                # Clear existing
                for widget in self.transactions_list_container.winfo_children():
                    widget.destroy()
                
                # Get filters
                type_filter = self.history_txn_type_filter.get()
                category_filter = self.history_txn_category_var.get()
                
                # Map UI values to database values
                type_val = None if type_filter == "All" else type_filter.lower()
                category_map = {
                    "Salaries": "salary",
                    "Prizes": "prize_money",
                    "Sponsors": "sponsor_payment",
                    "Penalties": "penalty",
                    "Signing Bonuses": "signing_bonus"
                }
                categories = None if category_filter == "All" else [category_map.get(category_filter, category_filter.lower())]
                
                # Query transactions
                transactions = ftb_state_db.query_financial_transactions(
                    self.sim_state.state_db_path,
                    type=type_val,
                    categories=categories,
                    seasons=[self.sim_state.season_number],
                    limit=200
                )
                
                if not transactions:
                    empty_label = ctk.CTkLabel(
                        self.transactions_list_container,
                        text="No transactions recorded yet",
                        font=("Arial", 13),
                        text_color=FTBTheme.TEXT_MUTED
                    )
                    empty_label.pack(pady=50)
                    return
                
                # Calculate summaries
                total_income = sum(t['amount'] for t in transactions if t['type'] == 'income')
                total_expenses = sum(t['amount'] for t in transactions if t['type'] == 'expense')
                net_cashflow = total_income - total_expenses
                
                self.txn_income_label.configure(text=f"Total Income: ${total_income:,.0f}")
                self.txn_expenses_label.configure(text=f"Total Expenses: ${total_expenses:,.0f}")
                self.txn_net_label.configure(
                    text=f"Net Cashflow: ${net_cashflow:,.0f}",
                    text_color=FTBTheme.SUCCESS if net_cashflow >= 0 else FTBTheme.DANGER
                )
                
                # Display transactions
                for txn in transactions:
                    card = ctk.CTkFrame(self.transactions_list_container, fg_color=FTBTheme.CARD, corner_radius=4)
                    card.pack(fill=tk.X, pady=2)
                    
                    info_frame = ctk.CTkFrame(card, fg_color="transparent")
                    info_frame.pack(fill=tk.X, padx=10, pady=5)
                    
                    # Date
                    date_label = ctk.CTkLabel(
                        info_frame,
                        text=f"Day {txn['game_day']}",
                        font=("Arial", 9),
                        text_color=FTBTheme.TEXT_MUTED,
                        width=60
                    )
                    date_label.pack(side=tk.LEFT)
                    
                    # Description
                    desc_label = ctk.CTkLabel(
                        info_frame,
                        text=txn['description'][:60],
                        font=("Arial", 10),
                        text_color=FTBTheme.TEXT,
                        anchor="w"
                    )
                    desc_label.pack(side=tk.LEFT, fill=tk.X, expand=True, padx=10)
                    
                    # Amount
                    amount_color = FTBTheme.SUCCESS if txn['type'] == 'income' else FTBTheme.DANGER
                    amount_prefix = "+" if txn['type'] == 'income' else "-"
                    amount_label = ctk.CTkLabel(
                        info_frame,
                        text=f"{amount_prefix}${txn['amount']:,.0f}",
                        font=("Arial", 11, "bold"),
                        text_color=amount_color,
                        width=120,
                        anchor="e"
                    )
                    amount_label.pack(side=tk.RIGHT)
                    
                    # Balance after
                    balance_label = ctk.CTkLabel(
                        info_frame,
                        text=f"Bal: ${txn['balance_after']:,.0f}",
                        font=("Arial", 9),
                        text_color=FTBTheme.TEXT_MUTED,
                        width=100,
                        anchor="e"
                    )
                    balance_label.pack(side=tk.RIGHT, padx=10)
            
            except Exception as e:
                _dbg(f"[FTB] Error refreshing transaction history: {e}")
        
        def new_game(self):
            """Return to wizard for new game"""
            self.runtime["ftb_cmd_q"].put({"cmd": "ftb_reset"})
            self.show_wizard(skip_welcome=True)
        
        def save_game(self):
            """Prompt for save name and save"""
            try:
                name = simpledialog.askstring("Save Game", "Enter save name:")
                if name:
                    _dbg(f"[WIDGET] User entered save name: {name}")
                    # Construct path in saves directory
                    import os
                    workspace_root = self.runtime.get("RADIO_OS_ROOT", ".")
                    saves_dir = os.path.join(workspace_root, "saves")
                    if not os.path.exists(saves_dir):
                        os.makedirs(saves_dir)
                    
                    # Sanitize filename
                    safe_name = "".join(c for c in name if c.isalnum() or c in (' ', '-', '_')).strip()
                    if not safe_name:
                        safe_name = "save"
                    
                    path = os.path.join(saves_dir, f"{safe_name}.json")
                    _dbg(f"[WIDGET] Sending save command with path: {path}")
                    
                    # Get command queue
                    cmd_q = self.runtime.get("ftb_cmd_q")
                    if cmd_q is None:
                        _dbg("[WIDGET] ❌ ERROR: ftb_cmd_q not found in runtime!")
                        from tkinter import messagebox
                        messagebox.showerror("Save Error", "Command queue not initialized")
                        return
                    
                    cmd_q.put({"cmd": "ftb_save", "path": path})
                    _dbg(f"[WIDGET] ✓ Command queued (queue size: {cmd_q.qsize()})")
                else:
                    _dbg("[WIDGET] Save cancelled - no name entered")
            except Exception as e:
                import traceback
                error_msg = traceback.format_exc()
                _dbg(f"[WIDGET] ❌ Save dialog error: {e}\n{error_msg}")
                from tkinter import messagebox
                messagebox.showerror("Save Error", f"Failed to initiate save: {str(e)}")
        
        def load_game(self):
            """Open save browser dialog"""
            # TODO: Implement full save browser with metadata
            # For now, simple file dialog
            import os
            from tkinter import filedialog
            workspace_root = self.runtime.get("RADIO_OS_ROOT", ".")
            filename = filedialog.askopenfilename(
                initialdir=os.path.join(workspace_root, "saves"),
                title="Select save file",
                filetypes=(("JSON files", "*.json"), ("All files", "*.*"))
            )
            if filename:
                self.runtime["ftb_cmd_q"].put({"cmd": "ftb_load_save", "path": filename})
        
        def load_from_db(self):
            """Load race results from database into event history"""
            from tkinter import messagebox
            
            # Ask if user wants to clear existing race results
            result = messagebox.askyesnocancel(
                "Load from Database",
                "Load race results from database into event history?\n\n"
                "Yes = Replace existing race results\n"
                "No = Add to existing race results\n"
                "Cancel = Abort"
            )
            
            if result is None:  # Cancel
                return
            
            clear_existing = result  # True for Yes, False for No
            self.runtime["ftb_cmd_q"].put({
                "cmd": "ftb_load_from_db",
                "clear_existing": clear_existing
            })
            
            # Show confirmation
            action = "Replacing" if clear_existing else "Adding"
            messagebox.showinfo(
                "Loading...",
                f"{action} race results from database.\nCheck console for progress."
            )
        
        def exit_to_menu(self):
            """Exit to menu without destroying save"""
            self.runtime["ftb_cmd_q"].put({"cmd": "ftb_reset"})
            # Always show start menu (will adapt based on whether autosave exists)
            autosave_path = self._get_autosave_path() if self._has_autosave() else None
            self.show_start_menu(autosave_path)
        
        def send_tick(self, n):
            # Debounce rapid clicks - ignore if within 200ms of last click
            current_time = time.time()
            if current_time - self._last_tick_click_time < 0.2:
                return  # Ignore rapid click
            self._last_tick_click_time = current_time
            self.runtime["ftb_cmd_q"].put({"cmd": "ftb_tick_step", "n": n})
        
        def send_tick_batch(self, n):
            """Send batch tick command which generates summary"""
            self.runtime["ftb_cmd_q"].put({"cmd": "ftb_tick_batch", "n": n})

        def stop_tick(self):
            """Stop any in-progress batch tick operations"""
            self.runtime["ftb_cmd_q"].put({"cmd": "ftb_stop_tick"})
            self.log("ftb", "🛑 Stop tick button pressed")

        def _start_race_day(self):
            """Trigger a paused race day (qualifying + race)"""
            cmd_q = self.runtime.get("ftb_cmd_q")
            if cmd_q:
                cmd_q.put({"cmd": "ftb_start_race_day"})
        
        def update_from_state(self, state: SimState):
            """Called by poll when state exists"""
            _dbg(f"[FTB WIDGET {self.widget_id}] 🔄 update_from_state ENTRY: state={'None' if state is None else f'tick={state.tick}'}")
            if state is None:
                _dbg(f"[FTB WIDGET {self.widget_id}] ❌ State is None, checking for autosave...")
                # Show start menu (will adapt based on whether autosave exists)
                autosave_path = self._get_autosave_path() if self._has_autosave() else None
                if autosave_path:
                    _dbg(f"[FTB WIDGET {self.widget_id}] 💾 Autosave found, showing start menu with continue option")
                else:
                    _dbg(f"[FTB WIDGET {self.widget_id}] 📋 No autosave, showing start menu")
                self.show_start_menu(autosave_path)
                return
            
            # Track if we just switched to game view
            was_game_view = self.current_view == "game"
            self.show_game_interface()
            just_switched_to_game = not was_game_view and self.current_view == "game"
            
            # Check if this is the very first update (never loaded any state before)
            is_first_load = self.sim_state is None
            
            # Check if data has changed to avoid unnecessary updates
            tick_changed = (
                self._last_tick is None or
                state.tick != self._last_tick
            )
            
            # Check if state is marked dirty (commands processed within same tick)
            state_dirty = state.is_dirty() if hasattr(state, 'is_dirty') else False
            
            # If this is first load, ensure all dirty flags are set to force complete refresh
            if is_first_load and hasattr(state, 'mark_dirty'):
                _dbg(f"[FTB WIDGET {self.widget_id}] 🆕 First load detected - marking all domains dirty")
                state.mark_dirty('all')
                state_dirty = True
            
            # Update if tick changed OR if we just switched to game view OR if tab changed OR if state is dirty OR if first load
            current_tab = self.tabview.get() if hasattr(self, 'tabview') else None
            tab_changed = hasattr(self, '_last_tab') and self._last_tab != current_tab
            
            # Force periodic updates - Update at least every 5 poll cycles to ensure UI stays fresh
            force_periodic = not hasattr(self, '_update_counter') or self._update_counter >= 5
            if force_periodic:
                self._update_counter = 0
                _dbg(f"[FTB WIDGET {self.widget_id}] 🔄 Force periodic refresh triggered (counter reset)")
            else:
                self._update_counter = getattr(self, '_update_counter', 0) + 1
                _dbg(f"[FTB WIDGET {self.widget_id}] 🔄 Update counter incremented to {self._update_counter}/5")
            
            should_update = is_first_load or tick_changed or just_switched_to_game or tab_changed or state_dirty or force_periodic
            
            _dbg(f"[FTB WIDGET {self.widget_id}] 🔍 Update decision: should_update={should_update} (first_load={is_first_load}, tick_changed={tick_changed}, view_switch={just_switched_to_game}, tab_changed={tab_changed}, state_dirty={state_dirty}, force_periodic={force_periodic})")
            
            # Skip update if nothing changed
            if not should_update:
                _dbg(f"[FTB WIDGET {self.widget_id}] ⏭️ Skipping update - no changes detected")
                return
            
            self.sim_state = state
            self._last_tick = state.tick
            if hasattr(self, 'tabview'):
                self._last_tab = self.tabview.get()
            
            reason = []
            if is_first_load: reason.append('first_load')
            if tick_changed: reason.append('tick')
            if just_switched_to_game: reason.append('view_switch')
            if tab_changed: reason.append('tab_change')
            if state_dirty: reason.append('state_dirty')
            if force_periodic: reason.append('periodic_refresh')
            _dbg(f"[FTB WIDGET {self.widget_id}] Updating UI, tick={state.tick}, reason={'+'.join(reason)}")

            # Populate league dropdown once state is available
            if hasattr(self, '_stats_league_var'):
                current_value = self._stats_league_var.get()
                if current_value in ["Loading leagues...", "No game loaded", "No leagues available"]:
                    self._on_tier_changed()
            
            # Use safe access as state might be snapshot or object
            date_str = getattr(state, "current_date_str", lambda: "Unknown")()
            if isinstance(date_str, str): 
                self.cal_label.configure(text=date_str)
            
            # Update next event indicator
            if hasattr(self, 'next_event_label'):
                try:
                    calendar = state.get_calendar_projection(days_ahead=60)
                    if calendar and len(calendar) > 0:
                        next_event = calendar[0]
                        
                        # Safe access to entry_day - handle if it's malformed
                        entry_day = next_event.get('entry_day')
                        if isinstance(entry_day, (list, tuple)):
                            # Malformed data - use first element if it's a sequence
                            entry_day = entry_day[0] if entry_day else 0
                            _dbg(f"[FTB] WARNING: entry_day was a {type(entry_day).__name__}, using {entry_day}")
                        elif not isinstance(entry_day, int):
                            _dbg(f"[FTB] WARNING: entry_day is {type(entry_day).__name__}: {entry_day}")
                            entry_day = 0
                        
                        # Safe access to sim_day_of_year - handle if it's malformed
                        sim_day = state.sim_day_of_year
                        if isinstance(sim_day, (list, tuple)):
                            sim_day = sim_day[0] if sim_day else 0
                            _dbg(f"[FTB] WARNING: sim_day_of_year was a {type(state.sim_day_of_year).__name__}, using {sim_day}")
                        elif not isinstance(sim_day, int):
                            _dbg(f"[FTB] WARNING: sim_day_of_year is {type(sim_day).__name__}: {sim_day}")
                            sim_day = 0
                        
                        days_until = entry_day - sim_day
                        event_title = next_event['title'][:30]  # Truncate if too long
                        
                        # Color code by urgency
                        if days_until <= 3:
                            event_color = FTBTheme.DANGER
                        elif days_until <= 7:
                            event_color = FTBTheme.WARNING
                        else:
                            event_color = FTBTheme.TEXT
                        
                        self.next_event_label.configure(
                            text=f"⏰ Next: {event_title} in {days_until}d",
                            text_color=event_color
                        )
                    else:
                        self.next_event_label.configure(
                            text="⏰ Next: No upcoming events",
                            text_color=FTBTheme.TEXT_MUTED
                        )
                except Exception as e:
                    _dbg(f"[FTB] Error updating next event: {e}")
                    self.next_event_label.configure(text="⏰ Next: Error", text_color=FTBTheme.TEXT_MUTED)
            
            # Access attributes safely
            _dbg(f"[FTB WIDGET {self.widget_id}] 🏢 Updating team UI components...")
            p_team = state.player_team
            _dbg(f"[FTB WIDGET {self.widget_id}] 🏢 Player team: {p_team.name if p_team else 'None'}")
            if p_team and hasattr(self, 'team_name_label'):
                _dbg(f"[FTB WIDGET {self.widget_id}] 💰 Budget BEFORE update: current_label_text='{self.team_budget_label.cget('text')}'")
                _dbg(f"[FTB WIDGET {self.widget_id}] 💰 Budget from state: ${p_team.budget.cash:,.0f}")
                _dbg(f"[FTB WIDGET {self.widget_id}] 😊 Morale BEFORE update: current_label_text='{self.team_morale_label.cget('text')}'")
                _dbg(f"[FTB WIDGET {self.widget_id}] 😊 Morale from state: {p_team.standing_metrics.get('morale', 50.0):.0f}%")
                _dbg(f"[FTB WIDGET {self.widget_id}] Team details: tier={p_team.tier}, drivers={len([d for d in p_team.drivers if d is not None])}, ownership={p_team.ownership_type}")
                
                # Tier info
                tier_names = {1: "Grassroots", 2: "Formula V", 3: "Formula X", 4: "Formula Y", 5: "Formula Z"}
                tier_str = tier_names.get(p_team.tier, f"Tier {p_team.tier}")
                
                self.team_name_label.configure(text=f"{p_team.name} [{tier_str}]")
                
                # Budget with color coding
                budget_color = FTBTheme.SUCCESS if p_team.budget.cash > 0 else FTBTheme.DANGER
                new_budget_text = f"💰 {format_currency(p_team.budget.cash)}"
                self.team_budget_label.configure(
                    text=new_budget_text,
                    text_color=budget_color
                )
                _dbg(f"[FTB WIDGET {self.widget_id}] 💰 Budget AFTER update: new_label_text='{new_budget_text}'")
                
                # Morale bar and label
                if hasattr(self, 'team_morale_bar'):
                    morale = p_team.standing_metrics.get('morale', 50.0)
                    morale_pct = morale / 100.0
                    self.team_morale_bar.set(morale_pct)
                    new_morale_text = f"{morale:.0f}%"
                    self.team_morale_label.configure(text=new_morale_text)
                    _dbg(f"[FTB WIDGET {self.widget_id}] 😊 Morale AFTER update: new_label_text='{new_morale_text}', bar={morale_pct:.2f}")
                    # Color code the bar
                    if morale >= 70:
                        self.team_morale_bar.configure(progress_color=FTBTheme.SUCCESS)
                    elif morale >= 40:
                        self.team_morale_bar.configure(progress_color=FTBTheme.WARNING)
                    else:
                        self.team_morale_bar.configure(progress_color=FTBTheme.DANGER)
                
                # Reputation bar and label
                if hasattr(self, 'team_reputation_bar'):
                    reputation = p_team.standing_metrics.get('reputation', 0.0)
                    rep_pct = max(0, min(1.0, reputation / 100.0))
                    self.team_reputation_bar.set(rep_pct)
                    self.team_reputation_label.configure(text=f"{reputation:.0f}%")
                    # Color code the bar
                    if reputation >= 70:
                        self.team_reputation_bar.configure(progress_color=FTBTheme.SUCCESS)
                    elif reputation >= 40:
                        self.team_reputation_bar.configure(progress_color=FTBTheme.WARNING)
                    else:
                        self.team_reputation_bar.configure(progress_color=FTBTheme.DANGER)
                
                # Car performance
                if hasattr(self, 'team_car_label'):
                    car_rating = p_team.car.overall_rating if hasattr(p_team, 'car') and p_team.car else 50.0
                    car_emoji = "🚀" if car_rating >= 80 else "🏎️" if car_rating >= 60 else "🚗" if car_rating >= 40 else "🛞"
                    car_color = FTBTheme.SUCCESS if car_rating >= 70 else FTBTheme.WARNING if car_rating >= 50 else FTBTheme.DANGER
                    self.team_car_label.configure(
                        text=f"{car_emoji} Car Performance: {car_rating:.0f}/100",
                        text_color=car_color
                    )
                
                # Staff summary
                if hasattr(self, 'team_staff_label'):
                    num_engineers = len([e for e in p_team.engineers if e is not None])
                    num_mechanics = len([m for m in p_team.mechanics if m is not None])
                    strategist_str = "✓ Strategist" if p_team.strategist else "✗ No Strategist"
                    self.team_staff_label.configure(
                        text=f"👥 Staff: {num_engineers} Engineers, {num_mechanics} Mechanics, {strategist_str}"
                    )
                
                # Update league info - search through leagues to find which one contains player team
                if hasattr(self, 'team_league_label'):
                    player_league = None
                    for league in state.leagues.values():
                        if p_team in league.teams:
                            player_league = league
                            break
                    
                    if player_league:
                        league_text = f"League: {player_league.name} (Tier {player_league.tier})"
                        self.team_league_label.configure(text=league_text)
                    else:
                        self.team_league_label.configure(text="League: Unknown")
                
                # Update championship position and points from league standings
                if hasattr(self, 'team_position_label') or hasattr(self, 'team_points_label'):
                    # Find which league contains the player's team
                    player_league = None
                    for league in state.leagues.values():
                        if p_team in league.teams:
                            player_league = league
                            break
                    
                    if player_league and player_league.championship_table:
                        # Get points from championship table
                        player_points = player_league.championship_table.get(p_team.name, 0.0)
                        
                        # Calculate position from sorted standings
                        sorted_standings = sorted(
                            player_league.championship_table.items(), 
                            key=lambda x: x[1], 
                            reverse=True
                        )
                        player_position = None
                        for idx, (team_name, points) in enumerate(sorted_standings):
                            if team_name == p_team.name:
                                player_position = idx + 1
                                break
                        
                        # Update position label
                        if hasattr(self, 'team_position_label') and player_position:
                            pos_suffix = "st" if player_position == 1 else "nd" if player_position == 2 else "rd" if player_position == 3 else "th"
                            pos_emoji = "🥇" if player_position == 1 else "🥈" if player_position == 2 else "🥉" if player_position == 3 else "📊"
                            pos_color = FTBTheme.SUCCESS if player_position <= 3 else FTBTheme.WARNING if player_position <= 8 else FTBTheme.TEXT
                            self.team_position_label.configure(
                                text=f"{pos_emoji} P{player_position} of {len(sorted_standings)}",
                                text_color=pos_color
                            )
                        elif hasattr(self, 'team_position_label'):
                            self.team_position_label.configure(text="📊 Position: Unranked", text_color=FTBTheme.TEXT_MUTED)
                        
                        # Update points label
                        if hasattr(self, 'team_points_label'):
                            self.team_points_label.configure(text=f"⭐ {player_points:.0f} pts")
                    else:
                        # No league or no standings yet
                        if hasattr(self, 'team_position_label'):
                            self.team_position_label.configure(text="📊 Position: Unranked", text_color=FTBTheme.TEXT_MUTED)
                        if hasattr(self, 'team_points_label'):
                            self.team_points_label.configure(text=f"⭐ 0 pts")

                # Update driver status
                if hasattr(self, 'team_driver_status_label'):
                    tier_features = TIER_FEATURES.get(p_team.tier, TIER_FEATURES[1])
                    required_drivers = tier_features.get('max_drivers', 2)
                    current_drivers = len([d for d in p_team.drivers if d is not None])
                    if current_drivers < required_drivers:
                        self.team_driver_status_label.configure(
                            text=f"🏁 Drivers: {current_drivers}/{required_drivers} ⚠️ Below minimum!",
                            text_color=FTBTheme.DANGER
                        )
                    else:
                        driver_names = ", ".join([d.name for d in p_team.drivers if d is not None])
                        self.team_driver_status_label.configure(
                            text=f"🏁 Drivers: {driver_names}",
                            text_color=FTBTheme.TEXT
                        )
                
                _dbg(f"[FTB WIDGET {self.widget_id}] ✅ Team name and budget labels updated")
            elif p_team:
                _dbg(f"[FTB WIDGET {self.widget_id}] ⚠️ Player team exists but team_name_label not found")
            else:
                _dbg(f"[FTB WIDGET {self.widget_id}] ⚠️ No player team available")
                
                # Form indicator - calculate from recent race results
                if hasattr(self, 'team_form_label'):
                    race_events = [e for e in state.event_history[-50:] if e.category == "race_result" and e.data.get('team') == p_team.name]
                    if race_events:
                        recent_5 = race_events[-5:]
                        wins = sum(1 for e in recent_5 if e.data.get('position', 99) == 1)
                        podiums = sum(1 for e in recent_5 if e.data.get('position', 99) <= 3)
                        
                        if wins >= 3:
                            form_text = f"🔥 ON FIRE! {wins} wins in last 5 races"
                            form_color = FTBTheme.SUCCESS
                        elif podiums >= 3:
                            form_text = f"📈 Strong form: {podiums} podiums in last 5"
                            form_color = FTBTheme.SUCCESS
                        elif podiums >= 1:
                            form_text = f"📊 Decent form: {podiums} podium(s) recently"
                            form_color = FTBTheme.TEXT
                        else:
                            form_text = "📉 Struggling - No recent podiums"
                            form_color = FTBTheme.WARNING
                        
                        self.team_form_label.configure(text=form_text, text_color=form_color)
                    else:
                        self.team_form_label.configure(
                            text="📈 Form: No recent races",
                            text_color=FTBTheme.TEXT_MUTED
                        )
                
                # Update pressure indicators (moved to separate method for cleaner code)
                self._update_pressure_indicators(state)
                
                # Contract Expiration Alerts
                if hasattr(self, 'contract_alerts_label'):
                    current_day = state.sim_day_of_year
                    expiring_soon = []
                    for entity_id, contract in state.contracts.items():
                        if contract.team_name == p_team.name:
                            days_remaining = contract.days_remaining(current_day)
                            if 0 < days_remaining <= 30:
                                # Find entity name
                                entity_name = "Unknown"
                                for driver in p_team.drivers:
                                    if driver and driver.entity_id == entity_id:
                                        entity_name = driver.name
                                        break
                                if entity_name == "Unknown":
                                    for eng in p_team.engineers:
                                        if eng and eng.entity_id == entity_id:
                                            entity_name = eng.name
                                            break
                                expiring_soon.append((entity_name, days_remaining, contract.role))
                    
                    if expiring_soon:
                        expiring_soon.sort(key=lambda x: x[1])
                        alert_text = f"⚠️ {len(expiring_soon)} contract(s) expiring soon:\n"
                        for name, days, role in expiring_soon[:5]:  # Show up to 5
                            alert_text += f"  • {name} ({role}): {days}d\n"
                        self.contract_alerts_label.configure(
                            text=alert_text.strip(),
                            text_color=FTBTheme.WARNING
                        )
                    else:
                        self.contract_alerts_label.configure(
                            text="✓ No contracts expiring in next 30 days",
                            text_color=FTBTheme.TEXT_MUTED
                        )
                
                # Recent Race Results for Player Team Drivers
                if hasattr(self, 'race_results_label') and hasattr(self, 'race_results_container'):
                    # Clear existing results
                    for widget in self.race_results_container.winfo_children():
                        widget.destroy()
                    
                    # Get player team drivers
                    driver_names = [d.name for d in p_team.drivers if d is not None]
                    
                    # Get race result events from event history
                    race_result_events = [e for e in state.event_history if e.category == "race_result"]
                    
                    if driver_names and race_result_events:
                        # Get last 5 race results for each driver
                        driver_results_map = {}
                        for driver_name in driver_names:
                            driver_results = []
                            for event in reversed(race_result_events[-10:]):  # Check last 10 races
                                if event.data.get('driver') == driver_name:
                                    driver_results.append(event)
                                if len(driver_results) >= 5:
                                    break
                            if driver_results:
                                driver_results_map[driver_name] = list(reversed(driver_results))
                        
                        if driver_results_map:
                            # Display results for each driver
                            for driver_name in driver_names:
                                driver = next((d for d in p_team.drivers if d and d.name == driver_name), None)
                                if not driver:
                                    continue
                                    
                                results = driver_results_map.get(driver_name, [])
                                if not results:
                                    continue
                                
                                # Create driver result row
                                driver_frame = ctk.CTkFrame(self.race_results_container, fg_color="transparent")
                                driver_frame.pack(fill=tk.X, pady=3)
                                
                                ctk.CTkLabel(
                                    driver_frame,
                                    text=f"{driver.name}:",
                                    font=("Arial", 11, "bold"),
                                    text_color=FTBTheme.TEXT,
                                    width=120,
                                    anchor="w"
                                ).pack(side=tk.LEFT, padx=(0, 10))
                                
                                # Display position badges
                                positions_text = " → ".join([
                                    f"P{r.data.get('position', '?')}" for r in results
                                ])
                                
                                # Color code based on recent performance
                                avg_position = sum(r.data.get('position', 99) for r in results) / len(results)
                                if avg_position <= 3:
                                    pos_color = FTBTheme.SUCCESS
                                elif avg_position <= 8:
                                    pos_color = FTBTheme.WARNING
                                else:
                                    pos_color = FTBTheme.TEXT
                                
                                ctk.CTkLabel(
                                    driver_frame,
                                    text=positions_text,
                                    font=("Arial", 11),
                                    text_color=pos_color
                                ).pack(side=tk.LEFT)
                        else:
                            ctk.CTkLabel(
                                self.race_results_container,
                                text="No recent race data",
                                text_color=FTBTheme.TEXT_MUTED,
                                font=("Arial", 11),
                                anchor="w"
                            ).pack(anchor="w")
                    else:
                        ctk.CTkLabel(
                            self.race_results_container,
                            text="No drivers or no races completed",
                            text_color=FTBTheme.TEXT_MUTED,
                            font=("Arial", 11),
                            anchor="w"
                        ).pack(anchor="w")
                
            tm = getattr(state, "time_mode", "paused")
            if hasattr(self, 'team_status_label'):
                self.team_status_label.configure(text=f"Status: {tm.title()}")
            
            # Check if tab has changed
            if hasattr(self, 'tabview'):
                current_tab = self.tabview.get()
                tab_changed = (not hasattr(self, '_last_tab') or self._last_tab != current_tab)
                if tab_changed:
                    _dbg(f"[FTB WIDGET] Tab switched: {getattr(self, '_last_tab', 'None')} → {current_tab}")
                self._last_tab = current_tab
                
                # Write tab change to state DB for narrator awareness
                if tab_changed and hasattr(self, 'controller') and self.controller.state_db_path and ftb_state_db:
                    try:
                        ftb_state_db.write_ui_context(
                            self.controller.state_db_path,
                            current_tab,
                            self.controller.state.tick if self.controller.state else 0
                        )
                    except Exception as e:
                        pass  # Ignore tab write errors
                
                # Refresh based on dirty flags and tab changes
                # Each tab only refreshes if its data is dirty or if we just switched to it
                if current_tab == "Dashboard":
                    # Dashboard is always updated (event log, metrics)
                    self.update_event_log(state)
                    
                # Force refresh of all core tabs ONLY on first load (not periodic refresh)
                if is_first_load:
                    _dbg(f"[FTB WIDGET {self.widget_id}] 🔄 Full refresh triggered (first_load={is_first_load})")
                    # Refresh Team tab components
                    try:
                        if hasattr(self, 'financial_overview_container'):
                            self._refresh_financial_overview()
                        if hasattr(self, 'roster_container'):
                            self._refresh_roster()
                        if hasattr(self, 'job_board_container'):
                            self._refresh_job_board()
                        _dbg(f"[FTB WIDGET {self.widget_id}] ✅ Team tab refreshed")
                    except Exception as e:
                        _dbg(f"[FTB WIDGET {self.widget_id}] ❌ Team tab refresh error: {e}")
                    
                    # Refresh Car tab components
                    try:
                        if hasattr(self, 'car_overview_container'):
                            self._refresh_car_overview()
                            self._refresh_car_parts_visual()
                            self._refresh_parts_inventory()
                        _dbg(f"[FTB WIDGET {self.widget_id}] ✅ Car tab refreshed")
                    except Exception as e:
                        _dbg(f"[FTB WIDGET {self.widget_id}] ❌ Car tab refresh error: {e}")
                    
                    # Refresh Development tab components
                    try:
                        if hasattr(self, 'projects_container'):
                            self._refresh_development_projects()
                        if hasattr(self, 'infrastructure_container'):
                            self._refresh_infrastructure()
                        if hasattr(self, 'parts_marketplace_container'):
                            self._refresh_parts_marketplace()
                        _dbg(f"[FTB WIDGET {self.widget_id}] ✅ Development tab refreshed")
                    except Exception as e:
                        _dbg(f"[FTB WIDGET {self.widget_id}] ❌ Development tab refresh error: {e}")
                        
                    # Refresh Finance tab
                    try:
                        if hasattr(self, 'cash_metric'):
                            self._refresh_finance()
                        _dbg(f"[FTB WIDGET {self.widget_id}] ✅ Finance tab refreshed")
                    except Exception as e:
                        _dbg(f"[FTB WIDGET {self.widget_id}] ❌ Finance tab refresh error: {e}")
                        
                    # Refresh Racing Stats tab
                    try:
                        if hasattr(self, 'teams_standings_container'):
                            # Clear cache before refreshing on full state load
                            self._stats_cache = {
                                'last_tier': None,
                                'last_league': None,
                                'last_tick': None,
                                'archive_results': None,
                                'archive_timestamp': 0
                            }
                            _dbg(f"[FTB WIDGET {self.widget_id}] 🗑️ Cleared racing stats cache for full refresh")
                            self._refresh_racing_stats()
                        _dbg(f"[FTB WIDGET {self.widget_id}] ✅ Racing Stats tab refreshed")
                    except Exception as e:
                        _dbg(f"[FTB WIDGET {self.widget_id}] ❌ Racing Stats tab refresh error: {e}")
                        
                    # Refresh Sponsors tab
                    try:
                        if hasattr(self, 'current_sponsors_container'):
                            self._refresh_sponsors()
                        _dbg(f"[FTB WIDGET {self.widget_id}] ✅ Sponsors tab refreshed")
                    except Exception as e:
                        _dbg(f"[FTB WIDGET {self.widget_id}] ❌ Sponsors tab refresh error: {e}")
                        
                    # Clear all dirty flags after full refresh
                    if hasattr(state, 'clear_dirty_flags'):
                        state.clear_dirty_flags()
                        
                    _dbg(f"[FTB WIDGET {self.widget_id}] 🎊 Full UI refresh complete!")
                    
                # Normal tab-specific updates (only when viewing that tab)
                elif current_tab == "Dashboard":
                    # Dashboard pressure indicators and contract alerts need regular updates
                    self._update_pressure_indicators(state)
                    self._update_contract_alerts()
                elif current_tab == "AI Assistant" and should_update:
                    # Update AI decision history from state events
                    if hasattr(state, 'event_history'):
                        ai_decisions = [e for e in state.event_history if e.category == "ai_decision"]
                        # Convert to decision history format
                        for event in ai_decisions:
                            decision_dict = {
                                'action': event.data.get('action', 'Unknown'),
                                'cost': event.data.get('cost', 0),
                                'reasoning': event.data.get('reasoning', ''),
                                'tick': event.data.get('tick', event.ts),
                                'focus': event.data.get('focus', '')
                            }
                            # Only add if not already in history
                            if decision_dict not in self.decision_history:
                                self.decision_history.append(decision_dict)
                    
                    # Update AI mode label based on state
                    if hasattr(self, 'ai_mode_label') and hasattr(state, 'control_mode'):
                        if state.control_mode == "delegated":
                            self.ai_mode_label.configure(
                                text="DELEGATED - AI ACTIVE",
                                text_color=FTBTheme.SUCCESS
                            )
                            if hasattr(self, 'enable_delegation_btn'):
                                self.enable_delegation_btn.configure(state="disabled")
                            if hasattr(self, 'disable_delegation_btn'):
                                self.disable_delegation_btn.configure(state="normal")
                        else:
                            self.ai_mode_label.configure(
                                text="MANUAL",
                                text_color=FTBTheme.WARNING
                            )
                            if hasattr(self, 'enable_delegation_btn'):
                                self.enable_delegation_btn.configure(state="normal")
                            if hasattr(self, 'disable_delegation_btn'):
                                self.disable_delegation_btn.configure(state="disabled")
                    
                    # Refresh decision log
                    self._refresh_ai_decision_log()
                elif current_tab == "Team" and (tab_changed or state._team_dirty):
                    try:
                        if hasattr(self, 'financial_overview_container'):
                            self._refresh_financial_overview()
                        if hasattr(self, 'roster_container'):
                            self._refresh_roster()
                            state._team_dirty = False
                        if hasattr(self, 'job_board_container'):
                            self._refresh_job_board()
                        if hasattr(self, 'team_browser_container'):
                            self._refresh_team_browser()
                    except Exception as e:
                        _dbg(f"[FTB WIDGET] Team tab refresh error: {e}")
                elif current_tab == "Manager Career" and (tab_changed or getattr(state, '_team_dirty', False) or getattr(state, '_manager_career_dirty', False)):
                    _dbg(f"[FTB WIDGET] Refreshing Manager Career tab: tab_changed={tab_changed}, team_dirty={getattr(state, '_team_dirty', False)}, career_dirty={getattr(state, '_manager_career_dirty', False)}")
                    try:
                        if hasattr(self, 'manager_career_container'):
                            self._refresh_manager_career()
                            state._manager_career_dirty = False
                    except Exception as e:
                        _dbg(f"[FTB WIDGET] Manager Career tab refresh error: {e}")
                elif current_tab == "Car" and (tab_changed or getattr(state, '_car_dirty', False)):
                    _dbg(f"[FTB WIDGET] Refreshing Car tab: tab_changed={tab_changed}, dirty={getattr(state, '_car_dirty', False)}")
                    try:
                        if hasattr(self, 'car_overview_container'):
                            self._refresh_car_overview()
                        if hasattr(self, 'car_parts_visual_container'):
                            self._refresh_car_parts_visual()
                        if hasattr(self, 'parts_inventory_container'):
                            self._refresh_parts_inventory()
                        if hasattr(self, 'parts_marketplace_container'):
                            _dbg(f"[FTB WIDGET] Refreshing parts marketplace...")
                            self._refresh_parts_marketplace()
                            _dbg(f"[FTB WIDGET] Parts marketplace refresh complete")
                        state._car_dirty = False
                    except Exception as e:
                        _dbg(f"[FTB WIDGET] Car tab refresh error: {e}")
                        import traceback
                        traceback.print_exc()
                elif current_tab == "Development" and (tab_changed or getattr(state, '_development_dirty', False)):
                    _dbg(f"[FTB WIDGET] Refreshing Development tab: tab_changed={tab_changed}, dirty={getattr(state, '_development_dirty', False)}")
                    try:
                        if hasattr(self, 'projects_container'):
                            self._refresh_development_projects()
                            state._development_dirty = False
                        if hasattr(self, 'infrastructure_container'):
                            self._refresh_infrastructure()
                    except Exception as e:
                        _dbg(f"[FTB WIDGET] Development tab refresh error: {e}")
                        import traceback
                        traceback.print_exc()
                elif current_tab == "Finance" and (tab_changed or state._finance_dirty):
                    if hasattr(self, 'cash_metric'):
                        self._refresh_finance()
                        state._finance_dirty = False
                elif current_tab == "Race Operations" and should_update:
                    if hasattr(self, 'race_phase_label'):
                        self._refresh_race_ops()
                elif current_tab == "Racing Stats" and (tab_changed or state._stats_dirty):
                    if hasattr(self, 'teams_standings_container'):
                        self._refresh_racing_stats()
                        state._stats_dirty = False
                        self._stats_last_refreshed = True
                elif current_tab == "Analytics" and should_update:
                    if hasattr(self, 'comparison_table_container'):
                        self._refresh_analytics()
                elif current_tab == "Sponsors" and (tab_changed or state._sponsors_dirty):
                    if hasattr(self, 'current_sponsors_container'):
                        self._refresh_sponsors()
                        state._sponsors_dirty = False
                elif current_tab == "Penalties" and should_update:
                    if hasattr(self, 'penalties_list_container'):
                        self._refresh_penalties()
        
        def _update_pressure_indicators(self, state: SimState):
            """Update dashboard pressure indicators"""
            try:
                p_team = state.player_team
                if not p_team:
                    return
                
                # Update pressure indicators
                runway = FTBSimulation.calculate_cash_runway(p_team)
                cash = p_team.budget.cash
                
                if runway == float('inf'):
                    runway_text = f"${cash:,.0f} / ∞"
                    runway_sublabel = "No burn (Payroll+Infra+Ops)"
                    runway_color = FTBTheme.SUCCESS
                elif runway < 10:
                    runway_text = f"${cash:,.0f} / {runway:.1f}w"
                    runway_sublabel = "⚠️ CRITICAL (Payroll+Infra+Ops)"
                    runway_color = FTBTheme.DANGER
                elif runway < 30:
                    runway_text = f"${cash:,.0f} / {runway:.1f}w"
                    runway_sublabel = "⚠️ Low (Payroll+Infra+Ops)"
                    runway_color = FTBTheme.WARNING
                else:
                    runway_text = f"${cash:,.0f} / {runway:.1f}w"
                    runway_sublabel = "✓ Healthy (Payroll+Infra+Ops)"
                    runway_color = FTBTheme.SUCCESS
                
                if hasattr(self, 'runway_metric'):
                    self.runway_metric.update(runway_text, runway_color, runway_sublabel)
                
                # Reputation metric
                rep_value = p_team.standing_metrics.get('reputation', 50)
                rep_display = f"{rep_value:.0f}"
                rep_history = p_team.standing_metrics.get('reputation_history', [])
                if len(rep_history) >= 2:
                    recent_change = rep_history[-1] - rep_history[-5] if len(rep_history) >= 5 else rep_history[-1] - rep_history[0]
                    if recent_change > 2:
                        rep_display += f" ↑ +{recent_change:.0f}"
                        rep_color = FTBTheme.POSITIVE
                    elif recent_change < -2:
                        rep_display += f" ↓ {recent_change:.0f}"
                        rep_color = FTBTheme.NEGATIVE
                    else:
                        rep_color = FTBTheme.NEUTRAL
                else:
                    rep_color = FTBTheme.NEUTRAL
                
                if hasattr(self, 'rep_metric'):
                    self.rep_metric.update(rep_display, rep_color, "recent trend")
                
                # Morale metric
                morale_value = p_team.standing_metrics.get('morale', 50)
                if morale_value >= 70:
                    morale_state = "High"
                    morale_color = FTBTheme.SUCCESS
                elif morale_value <= 30:
                    morale_state = "Low"
                    morale_color = FTBTheme.DANGER
                else:
                    morale_state = "Stable"
                    morale_color = FTBTheme.NEUTRAL
                    
                morale_display = f"{morale_state} ({morale_value:.0f})"
                morale_factors = p_team.standing_metrics.get('morale_factors', {})
                morale_sublabel = ""
                if morale_factors:
                    sorted_factors = sorted(morale_factors.items(), key=lambda x: abs(x[1]), reverse=True)
                    if sorted_factors:
                        top_factor, top_value = sorted_factors[0]
                        if abs(top_value) > 5:
                            prefix = "Boosted by" if top_value > 0 else "Hurt by"
                            morale_sublabel = f"{prefix}: {top_factor}"
                
                if hasattr(self, 'morale_metric'):
                    self.morale_metric.update(morale_display, morale_color, morale_sublabel)
                
                # Owner pressure metric
                owner_confidence = p_team.standing_metrics.get('ownership_confidence', 50)
                if owner_confidence >= 70:
                    owner_color = FTBTheme.SUCCESS
                    owner_sublabel = "Strong support"
                elif owner_confidence >= 40:
                    owner_color = FTBTheme.WARNING
                    owner_sublabel = "At risk"
                else:
                    owner_color = FTBTheme.DANGER
                    owner_sublabel = "⚠️ Firing risk"
                    
                if hasattr(self, 'owner_pressure_metric'):
                    self.owner_pressure_metric.update(f"{owner_confidence:.0f}%", owner_color, owner_sublabel)
                
                # Burn rate metric
                burn_rate = p_team.budget.burn_rate
                income = sum(source.amount for source in p_team.budget.income_streams) if p_team.budget.income_streams else 0
                net_burn = burn_rate - income
                if net_burn <= 0:
                    burn_color = FTBTheme.SUCCESS
                    burn_sublabel = "✓ Sustainable"
                elif net_burn < 50000:
                    burn_color = FTBTheme.WARNING
                    burn_sublabel = "⚠️ Slow burn"
                else:
                    burn_color = FTBTheme.DANGER
                    burn_sublabel = "⚠️ High burn"
                    
                if hasattr(self, 'burn_rate_metric'):
                    self.burn_rate_metric.update(f"${abs(burn_rate):,.0f}/day", burn_color, burn_sublabel)
                
                # Sponsor health metric
                sponsorships = state.sponsorships.get(p_team.name, [])
                if sponsorships:
                    avg_confidence = sum(s.confidence for s in sponsorships) / len(sponsorships)
                    warning_count = sum(1 for s in sponsorships if s.warning_issued)
                    min_confidence = min(s.confidence for s in sponsorships)
                    
                    if min_confidence < 50 or warning_count > 0:
                        sponsor_color = FTBTheme.DANGER
                        sponsor_sublabel = f"⚠️ {warning_count} at risk"
                    elif avg_confidence < 70:
                        sponsor_color = FTBTheme.WARNING
                        sponsor_sublabel = "Needs improvement"
                    else:
                        sponsor_color = FTBTheme.SUCCESS
                        sponsor_sublabel = "✓ Satisfied"
                    
                    if hasattr(self, 'sponsor_metric'):
                        self.sponsor_metric.update(f"{avg_confidence:.0f}%", sponsor_color, sponsor_sublabel)
                else:
                    if hasattr(self, 'sponsor_metric'):
                        self.sponsor_metric.update("No sponsors", FTBTheme.TEXT_MUTED, "Seek sponsorships")
                
                _dbg(f"[FTB WIDGET {self.widget_id}] ✅ Pressure indicators updated")
                
            except Exception as e:
                _dbg(f"[FTB WIDGET {self.widget_id}] ❌ Error updating pressure indicators: {e}")
                import traceback
                traceback.print_exc()
        
        def _update_contract_alerts(self):
            """Update contract expiry alerts on dashboard"""
            if not self.sim_state or not self.sim_state.player_team:
                if hasattr(self, 'contract_alerts_label'):
                    self.contract_alerts_label.configure(text="No contract data", text_color=FTBTheme.TEXT_MUTED)
                return
            
            try:
                team = self.sim_state.player_team
                current_day = self.sim_state.sim_day_of_year
                
                expiring_soon = []
                
                # Check all active contracts
                all_entities = []
                if hasattr(team, 'drivers'):
                    all_entities.extend([d for d in team.drivers if d])
                if hasattr(team, 'engineers'):
                    all_entities.extend([e for e in team.engineers if e])
                if hasattr(team, 'mechanics'):
                    all_entities.extend([m for m in team.mechanics if m])
                if hasattr(team, 'strategist') and team.strategist:
                    all_entities.append(team.strategist)
                
                for entity in all_entities:
                    if not hasattr(entity, 'contract') or not entity.contract:
                        continue
                    
                    contract = entity.contract
                    days_remaining = contract.days_remaining(current_day)
                    
                    if days_remaining <= 0:
                        continue  # Already expired
                    
                    # Categorize by urgency
                    if days_remaining <= 7:
                        urgency = "🔴 CRITICAL"
                        color = FTBTheme.ERROR
                    elif days_remaining <= 14:
                        urgency = "🟡 URGENT"
                        color = FTBTheme.WARNING
                    elif days_remaining <= 30:
                        urgency = "🟢 Soon"
                        color = FTBTheme.ACCENT
                    else:
                        continue  # Not soon enough to alert
                    
                    expiring_soon.append({
                        'name': entity.name,
                        'role': contract.role,
                        'days': days_remaining,
                        'urgency': urgency,
                        'color': color
                    })
                
                # Sort by urgency (days remaining, ascending)
                expiring_soon.sort(key=lambda x: x['days'])
                
                # Build alert text
                if not expiring_soon:
                    self.contract_alerts_label.configure(
                        text="✓ No contracts expiring soon",
                        text_color=FTBTheme.TEXT_MUTED
                    )
                else:
                    alert_lines = []
                    for item in expiring_soon[:5]:  # Show max 5
                        alert_lines.append(
                            f"{item['urgency']} {item['name']} ({item['role']}) - {item['days']}d"
                        )
                    
                    if len(expiring_soon) > 5:
                        alert_lines.append(f"... and {len(expiring_soon) - 5} more")
                    
                    # Use the most urgent color
                    primary_color = expiring_soon[0]['color']
                    
                    self.contract_alerts_label.configure(
                        text="\n".join(alert_lines),
                        text_color=primary_color
                    )
                
            except Exception as e:
                _dbg(f"[FTB WIDGET] Error updating contract alerts: {e}")
                import traceback
                traceback.print_exc()

        def _is_personal_event(self, event: SimEvent, state: SimState) -> bool:
            """Determine if an event is personal (related to player's team) vs world event"""
            if not state.player_team:
                return False
            
            player_team_name = state.player_team.name
            
            # Check if event involves player's team
            if event.data.get('team') == player_team_name:
                return True
            
            # Check if event involves player's drivers
            if 'driver' in event.data:
                driver_name = event.data['driver']
                player_driver_names = [d.name for d in state.player_team.drivers if d]
                if driver_name in player_driver_names:
                    return True
            
            # Check if event involves player's engineers
            if 'engineer' in event.data:
                engineer_name = event.data['engineer']
                player_engineer_names = [e.name for e in state.player_team.engineers if e]
                if engineer_name in player_engineer_names:
                    return True
            
            return False
        
        def update_event_log(self, state: SimState):
            """Update event log with recent events split into Personal and World tabs"""
            if not hasattr(self, 'personal_events_text') or not hasattr(self, 'world_events_text'):
                return
            
            # Get last 200 events to allow 100 per tab
            recent_events = state.event_history[-200:] if state.event_history else []
            
            # Split events into personal and world
            personal_events = []
            world_events = []
            
            for event in recent_events:
                if self._is_personal_event(event, state):
                    personal_events.append(event)
                else:
                    world_events.append(event)
            
            # Take last 100 from each category
            personal_events = personal_events[-100:]
            world_events = world_events[-100:]
            
            # Build causality map for each set
            def format_events(events_list):
                event_map = {e.event_id: e for e in events_list}
                log_lines = []
                
                for event in events_list:
                    # Check if this is a child event
                    indent = ""
                    if event.caused_by and event.caused_by in event_map:
                        indent = "  └─ "
                    
                    # Severity icon
                    severity_icon = {
                        "info": "ℹ️",
                        "success": "✓",
                        "warning": "⚠️",
                        "danger": "❌",
                        "error": "❌",
                        "major": "⭐"
                    }.get(event.severity.lower(), "•")
                    
                    # Format event text
                    timestamp = f"T{event.ts:04d}"
                    category = event.category.replace('_', ' ').title()
                    text = f"{indent}{severity_icon} {timestamp} - {category}"
                    
                    # Add key data
                    if 'team' in event.data:
                        text += f" | {event.data['team']}"
                    if 'driver' in event.data:
                        text += f" - {event.data['driver']}"
                    if 'position' in event.data:
                        text += f" P{event.data['position']}"
                    if 'points' in event.data:
                        text += f" (+{event.data['points']}pts)"
                    if 'change' in event.data:
                        text += f" ({event.data['change']:+.1f})"
                    if 'message' in event.data:
                        text += f": {event.data['message']}"
                    
                    log_lines.append(text)
                
                return "\n".join(log_lines)
            
            # Update personal events tab
            self.personal_events_text.configure(state="normal")
            self.personal_events_text.delete('1.0', tk.END)
            if personal_events:
                self.personal_events_text.insert('1.0', format_events(personal_events))
            else:
                self.personal_events_text.insert('1.0', "No personal events yet...")
            self.personal_events_text.configure(state="disabled")
            
            # Update world events tab
            self.world_events_text.configure(state="normal")
            self.world_events_text.delete('1.0', tk.END)
            if world_events:
                self.world_events_text.insert('1.0', format_events(world_events))
            else:
                self.world_events_text.insert('1.0', "No world events yet...")
            self.world_events_text.configure(state="disabled")
            
            # Auto-scroll to bottom for both tabs
            try:
                self.personal_events_text.see(tk.END)
                self.world_events_text.see(tk.END)
            except:
                pass
            
            # Clear dirty flags after UI update
            if hasattr(state, 'clear_dirty_flags'):
                state.clear_dirty_flags()
        
        # --- Notification System Methods ---
        
        def _poll_notifications(self):
            """Check for new notifications and display toasts"""
            try:
                # Import notification module
                import plugins.ftb_notifications as ftb_notif
                
                # Check notification queue for new notifications
                while not ftb_notif.notification_queue.empty():
                    try:
                        notif = ftb_notif.notification_queue.get_nowait()
                        _dbg(f"[FTB] 🔔 Polling notification: {notif.title}")
                        self._show_toast(notif)
                    except Exception as e:
                        _dbg(f"[FTB] ❌ Error processing notification from queue: {e}")
                        import traceback
                        traceback.print_exc()
                        break
                
                # Update bell badge with unread count
                self._update_notification_badge()
                
            except Exception as e:
                # Silent fail if notifications not available
                _dbg(f"[FTB] ❌ Error in _poll_notifications: {e}")
                import traceback
                traceback.print_exc()
        
        def _show_toast(self, notification):
            """Display a toast notification or modal for race results"""
            try:
                import plugins.ftb_notifications as ftb_notif
                
                _dbg(f"[FTB] 🍞 Showing notification for: {notification.title} (category: {notification.category})")
                
                # Race results get a special modal dialog that demands attention
                if notification.category == 'race_result':
                    _dbg(f"[FTB] 🏁 Showing RACE RESULT MODAL")
                    modal = ftb_notif.RaceResultModal(self.container, notification)
                    _dbg(f"[FTB] ✅ Race result modal displayed successfully")
                    return
                
                # All other notifications get a toast
                # Check if toast_container exists
                if not hasattr(self, 'toast_container'):
                    _dbg(f"[FTB] ❌ toast_container not found, cannot show toast")
                    return
                
                # Create toast
                toast = ftb_notif.NotificationToast(
                    self.toast_container,
                    notification,
                    on_dismiss=lambda n: self._dismiss_toast(toast)
                )
                toast.pack(fill="x", pady=5)
                _dbg(f"[FTB] ✅ Toast displayed successfully")
                
            except Exception as e:
                _dbg(f"[FTB] ❌ Failed to show notification: {e}")
                import traceback
                traceback.print_exc()
        
        def _dismiss_toast(self, toast_widget):
            """Dismiss a toast notification"""
            try:
                toast_widget.destroy()
            except:
                pass
        
        def _update_notification_badge(self):
            """Update notification bell badge with unread count"""
            try:
                import plugins.ftb_notifications as ftb_notif
                
                controller = self.runtime.get("ftb_controller")
                if not controller or not controller.state_db_path:
                    return
                
                # Initialize notifications table if needed
                try:
                    ftb_notif.init_notifications_table(controller.state_db_path)
                except:
                    pass
                
                # Query unread count
                unread_notifs = ftb_notif.query_notifications(
                    controller.state_db_path,
                    unread_only=True,
                    limit=100
                )
                unread_count = len(unread_notifs)
                
                # Update button text
                if unread_count > 0:
                    if unread_count > 99:
                        badge_text = "🔔 99+"
                    else:
                        badge_text = f"🔔 {unread_count}"
                    self.notif_btn.configure(text=badge_text, text_color_disabled=ftb_notif.NotifTheme.WARNING)
                else:
                    self.notif_btn.configure(text="🔔")
                    
            except Exception as e:
                # Silent fail
                pass
        
        def show_notification_center(self):
            """Open notification center window"""
            try:
                import plugins.ftb_notifications as ftb_notif
                
                controller = self.runtime.get("ftb_controller")
                if not controller or not controller.state_db_path:
                    messagebox.showwarning("Notification Center", "No game state available")
                    return
                
                # Initialize notifications table if needed
                try:
                    ftb_notif.init_notifications_table(controller.state_db_path)
                except:
                    pass
                
                # Open notification center
                center = ftb_notif.NotificationCenter(self, controller.state_db_path)
                
            except Exception as e:
                messagebox.showerror("Notification Center", f"Failed to open notification center: {e}")
        
        def _check_ui_queue(self):
            """Check ftb_ui_q for special UI actions (dialogs, prompts, etc.)"""
            ui_q = self.runtime.get("ftb_ui_q")
            if not ui_q:
                return
            
            # Process all pending UI messages
            while not ui_q.empty():
                try:
                    msg = ui_q.get_nowait()
                    action, data = msg if isinstance(msg, tuple) else (msg, {})
                    
                    _dbg(f"[FTB WIDGET] 📨 UI queue message: {action}")
                    
                    if action == "show_pre_race_prompt":
                        self._show_pre_race_prompt(data)
                    elif action == "quali_complete":
                        self._show_quali_complete_notification(data)
                    elif action == "batch_summary":
                        # Already handled elsewhere
                        pass
                    
                except queue.Empty:
                    break
                except Exception as e:
                    _dbg(f"[FTB WIDGET] ⚠️ Error processing UI queue message: {e}")
                    import traceback
                    traceback.print_exc()
        
        def _show_pre_race_prompt(self, data: Dict[str, Any]):
            """Show stylized pre-race prompt dialog"""
            league_name = data.get("league_name", "Unknown League")
            track_name = data.get("track_name", "Unknown Track")
            tier = data.get("tier", 1)
            
            _dbg(f"[FTB RACE DAY] 🏁 Showing pre-race prompt: {league_name} at {track_name}")
            
            # Create custom dialog
            dialog = ctk.CTkToplevel(self)
            dialog.title("Race Day Tomorrow")
            dialog.geometry("550x350")
            
            # Styling based on tier
            if tier >= 4:
                bg_color = "#1a1a2e"
                accent = "#FFD700"
                tier_emoji = "🏆"
            elif tier >= 3:
                bg_color = "#1e1e2e"
                accent = "#4169E1"
                tier_emoji = "🏁"
            else:
                bg_color = "#2a2a2a"
                accent = "#4CAF50"
                tier_emoji = "🏎️"
            
            dialog.configure(fg_color=bg_color)
            
            # Main container
            main_frame = ctk.CTkFrame(dialog, fg_color=bg_color)
            main_frame.pack(fill="both", expand=True, padx=20, pady=20)
            
            # Title with emoji
            title = ctk.CTkLabel(
                main_frame,
                text=f"{tier_emoji} Race Day Tomorrow",
                font=("Segoe UI", 24, "bold"),
                text_color=accent
            )
            title.pack(pady=(0, 10))
            
            # League info
            league_label = ctk.CTkLabel(
                main_frame,
                text=league_name,
                font=("Segoe UI", 18, "bold"),
                text_color="#ffffff"
            )
            league_label.pack(pady=5)
            
            # Track info
            track_label = ctk.CTkLabel(
                main_frame,
                text=f"📍 {track_name}",
                font=("Segoe UI", 14),
                text_color="#cccccc"
            )
            track_label.pack(pady=5)
            
            # Separator
            separator = ctk.CTkFrame(main_frame, height=2, fg_color="#444444")
            separator.pack(fill="x", pady=15)
            
            # Message
            msg = ctk.CTkLabel(
                main_frame,
                text="Watch qualifying and live race coverage?\n\nLive mode: See qualifying results, then control race playback\nInstant mode: Race simulates immediately with full results",
                font=("Segoe UI", 13),
                text_color="#aaaaaa",
                justify="center"
            )
            msg.pack(pady=10)
            
            # Button container
            btn_frame = ctk.CTkFrame(main_frame, fg_color="transparent")
            btn_frame.pack(pady=20)
            
            def on_response(watch_live: bool):
                """Handle user response"""
                _dbg(f"[FTB RACE DAY] 📋 User response: watch_live={watch_live}")
                
                ftb_cmd_q = self.runtime.get("ftb_cmd_q")
                if ftb_cmd_q:
                    ftb_cmd_q.put({
                        "cmd": "ftb_pre_race_response",
                        "watch_live": watch_live
                    })
                    _dbg(f"[FTB RACE DAY] ✅ Sent response to controller")
                
                dialog.destroy()
            
            # Yes button (watch live)
            yes_btn = ctk.CTkButton(
                btn_frame,
                text="▶️  Watch Live",
                command=lambda: on_response(True),
                fg_color=accent,
                hover_color=self._adjust_color_brightness(accent, 0.8),
                width=180,
                height=50,
                font=("Segoe UI", 14, "bold"),
                corner_radius=8
            )
            yes_btn.pack(side="left", padx=10)
            
            # No button (instant)
            no_btn = ctk.CTkButton(
                btn_frame,
                text="⚡ Instant Results",
                command=lambda: on_response(False),
                fg_color="#555555",
                hover_color="#666666",
                width=180,
                height=50,
                font=("Segoe UI", 14),
                corner_radius=8
            )
            no_btn.pack(side="left", padx=10)
            
            # Center dialog on parent
            dialog.transient(self)
            dialog.grab_set()
            
            # Center on screen
            dialog.update_idletasks()
            x = (dialog.winfo_screenwidth() // 2) - (dialog.winfo_width() // 2)
            y = (dialog.winfo_screenheight() // 2) - (dialog.winfo_height() // 2)
            dialog.geometry(f"+{x}+{y}")
        
        def _show_quali_complete_notification(self, data: Dict[str, Any]):
            """Show notification that qualifying is complete"""
            message = data.get("message", "Qualifying complete!")
            pole_driver = data.get("pole_driver", "Unknown")
            pole_team = data.get("pole_team", "Unknown")
            
            _dbg(f"[FTB RACE DAY] 🏁 Showing quali complete notification")
            
            # Show as a messagebox for now (could be a nicer toast notification)
            messagebox.showinfo(
                "Qualifying Complete",
                f"{message}\n\n🏆 Pole: {pole_driver} ({pole_team})\n\nGo to the Play-by-Play tab to start the race!"
            )
        
        def _adjust_color_brightness(self, hex_color: str, factor: float) -> str:
            """Adjust brightness of a hex color (factor < 1 = darker, > 1 = lighter)"""
            # Remove # if present
            hex_color = hex_color.lstrip('#')
            
            # Convert to RGB
            r, g, b = tuple(int(hex_color[i:i+2], 16) for i in (0, 2, 4))
            
            # Adjust brightness
            r = int(min(255, max(0, r * factor)))
            g = int(min(255, max(0, g * factor)))
            b = int(min(255, max(0, b * factor)))
            
            # Convert back to hex
            return f"#{r:02x}{g:02x}{b:02x}"

        def start_poll(self):
            """Begin UI refresh loop"""
            self.after(500, self._poll)
        
        def _poll(self):
            """Poll controller for state updates"""
            _dbg(f"[FTB WIDGET POLL {self.widget_id}] 🔄 Starting poll cycle")
            try:
                if not self.winfo_exists():
                    _dbg(f"[FTB WIDGET POLL {self.widget_id}] ❌ Widget no longer exists")
                    return
            except Exception as e:
                _dbg(f"[FTB WIDGET POLL {self.widget_id}] ❌ Widget existence check failed: {e}")
                return

            # Check UI queue for special actions (dialogs, prompts)
            self._check_ui_queue()

            _dbg(f"[FTB WIDGET POLL {self.widget_id}] 🔍 Looking for controller in runtime...")
            controller = self.runtime.get("ftb_controller")
            if not controller:
                _dbg(f"[FTB WIDGET POLL {self.widget_id}] ⚠️ No controller found, runtime keys: {list(self.runtime.keys())}")
                self.after(500, self._poll)
                return
            _dbg(f"[FTB WIDGET POLL {self.widget_id}] ✅ Controller found: {type(controller).__name__}")

            # If no state, stay in start_menu or wizard (don't force switch)
            if not controller.state:
                _dbg(f"[FTB WIDGET POLL {self.widget_id}] ⚠️ Controller has no state, current_view={self.current_view}")
                _dbg(f"[FTB WIDGET POLL {self.widget_id}] 🔍 Controller details: thread_alive={controller.thread.is_alive() if controller.thread else False}, stop_event_set={controller.stop_event.is_set()}")
                # Only switch to start_menu if we're not already in start_menu, wizard, welcome, or loading
                if self.current_view not in ["start_menu", "wizard", "welcome", "loading"]:
                    # Check if save exists
                    autosave_path = self._get_autosave_path() if self._has_autosave() else None
                    _dbg(f"[FTB WIDGET POLL {self.widget_id}] 💾 Autosave check: path={autosave_path}, exists={autosave_path is not None}")
                    _dbg(f"[FTB WIDGET POLL {self.widget_id}] 📋 Switching to start menu")
                    self.show_start_menu(autosave_path)
            else:
                # Switch to game view if necessary
                _dbg(f"[FTB WIDGET POLL {self.widget_id}] ✓ Controller has state: tick={controller.state.tick}, current_view={self.current_view}")
                _dbg(f"[FTB WIDGET POLL {self.widget_id}] 📋 State summary: player_team={controller.state.player_team.name if controller.state.player_team else 'None'}, leagues={len(controller.state.leagues)}, time_mode={controller.state.time_mode}")
                if self.current_view != "game":
                    _dbg(f"[FTB WIDGET POLL {self.widget_id}] 🎮 Switching to game interface...")
                    self.show_game_interface()
                else:
                    _dbg(f"[FTB WIDGET POLL {self.widget_id}] 🎮 Already in game interface")
                
                try:
                    # Try to acquire lock - if simulation is running, skip this update
                    _dbg(f"[FTB WIDGET POLL {self.widget_id}] 🔒 Trying to acquire state lock for UI update...")
                    lock_acquired = controller.state_lock.acquire(blocking=False)
                    if lock_acquired:
                        try:
                            _dbg(f"[FTB WIDGET POLL {self.widget_id}] 🔒 State lock acquired")
                            # Just call update with live state for now
                            _dbg(f"[FTB WIDGET POLL {self.widget_id}] Calling update_from_state with tick={controller.state.tick}")
                            _dbg(f"[FTB WIDGET POLL {self.widget_id}] State details: day={controller.state.sim_day_of_year}, mode={controller.state.time_mode}, control={controller.state.control_mode}")
                            self.update_from_state(controller.state)
                            _dbg(f"[FTB WIDGET POLL {self.widget_id}] ✅ update_from_state completed successfully")
                        finally:
                            controller.state_lock.release()
                    else:
                        _dbg(f"[FTB WIDGET POLL {self.widget_id}] ⏸️ State lock busy (simulation running), skipping update")
                except Exception as e:
                    import traceback
                    _dbg(f"[FTB WIDGET] ❌ UI update error: {e}")
                    traceback.print_exc()
                
                # Poll for notifications (regardless of current view)
                self._poll_notifications()
            
            self.after(500, self._poll)

except ImportError:
    # Fallback if tkinter not available
    class FTBWidget:
        def __init__(self, parent, runtime_stub):
            pass


# ============================================================
# SECTION 6.4: Narration Helper Methods (for narrative_engine)
# ============================================================

class FTBNarrationHelpers:
    """Helper methods to extract narrative facts from simulation state"""
    
    @staticmethod
    def get_player_team_name(state: SimState) -> str:
        """Get player team identifier"""
        if state.player_team:
            return state.player_team.name
        return ""
    
    @staticmethod
    def get_team_league(state: SimState, team_name: str) -> Tuple[str, int]:
        """
        Find which league/tier a team belongs to.
        
        Returns:
            (league_name, tier_number)
        """
        for league_name, league in state.leagues.items():
            for team in league.teams:
                if team.name == team_name:
                    return (league.name, league.tier)
        return ("Unknown", 0)
    
    @staticmethod
    def get_narration_facts(state: SimState, events: List[SimEvent]) -> Dict[str, Any]:
        """
        Build minimal context bundle for narrator LLM.
        This avoids dumping full state into prompts.
        
        Returns:
            Compact dict with only narrative-relevant facts
        """
        facts = {
            "day": state.tick,
            "phase": state.phase,
            "date_str": state.current_date_str()
        }
        
        # Player team facts
        if state.player_team:
            team = state.player_team
            league_name, tier = FTBNarrationHelpers.get_team_league(state, team.name)
            
            facts["team"] = {
                "name": team.name,
                "cash": team.budget.cash,
                "burn_rate": team.budget.burn_rate,
                "league": league_name,
                "tier": tier
            }
            
            # Driver info (assume single driver for now)
            driver = next((d for d in team.drivers if d), None)
            if driver:
                facts["team"]["driver"] = driver.name
        
        # Season context
        facts["season"] = {
            "number": state.season_number,
            "races_completed": state.races_completed_this_season,
            "in_offseason": state.in_offseason
        }
        
        # Recent trend (derive from event history)
        recent_trend = FTBNarrationHelpers._calculate_recent_trend(state)
        facts["recent_trend"] = recent_trend
        
        # Formula Z standings (tier 1)
        formula_z_data = FTBNarrationHelpers._get_formula_z_standings(state)
        if formula_z_data:
            facts["formula_z_top3"] = formula_z_data["top3"]
            facts["formula_z_leader_gap"] = formula_z_data["leader_gap"]
        
        return facts
    
    @staticmethod
    def _calculate_recent_trend(state: SimState) -> str:
        """Derive trajectory from recent race results"""
        # Look at last 3 race results for player team
        race_results = [
            e for e in state.event_history[-20:]
            if e.category == "race_result" and 
               e.data.get("team") == (state.player_team.name if state.player_team else "")
        ][-3:]
        
        if len(race_results) < 2:
            return "unknown"
        
        # Check if positions are improving
        positions = [e.data.get("position", 20) for e in race_results]
        
        # Simple trend detection
        if positions[-1] < positions[0] - 2:
            return "improving"
        elif positions[-1] > positions[0] + 2:
            return "declining"
        else:
            return "flat"
    
    @staticmethod
    def _get_formula_z_standings(state: SimState) -> Optional[Dict[str, Any]]:
        """Get Formula Z (tier 1) championship standings"""
        # Find tier 1 league
        formula_z_league = None
        for league in state.leagues.values():
            if league.tier == 1:
                formula_z_league = league
                break
        
        if not formula_z_league:
            return None
        
        # Get top 3
        standings = sorted(
            formula_z_league.championship_table.items(),
            key=lambda x: x[1],
            reverse=True
        )[:3]
        
        if not standings:
            return None
        
        leader_points = standings[0][1]
        second_points = standings[1][1] if len(standings) > 1 else 0
        
        return {
            "top3": [team for team, _ in standings],
            "leader_gap": leader_points - second_points
        }
        
        def _save_audio_settings_to_manifest(self):
            """Save audio settings to the station manifest file"""
            try:
                import os
                import yaml
                from pathlib import Path
                
                if not self.sim_state or not hasattr(self.sim_state, 'audio_settings'):
                    return
                
                # Get manifest path from runtime
                manifest_path = None
                if hasattr(self.runtime, 'get') and 'STATION_DIR' in self.runtime:
                    station_dir = self.runtime.get('STATION_DIR', '')
                    if station_dir:
                        manifest_path = os.path.join(station_dir, 'manifest.yaml')
                
                if not manifest_path or not os.path.exists(manifest_path):
                    _dbg(f"[AUDIO] ⚠️ Cannot find manifest at {manifest_path}")
                    return
                
                # Read current manifest
                with open(manifest_path, 'r', encoding='utf-8') as f:
                    manifest = yaml.safe_load(f) or {}
                
                # Update audio settings
                if 'audio' not in manifest:
                    manifest['audio'] = {}
                
                if 'channel_volumes' not in manifest['audio']:
                    manifest['audio']['channel_volumes'] = {}
                
                # Map our settings to manifest structure
                settings_map = {
                    'master_volume': ('audio', 'master_volume'),
                    'music_volume': ('audio', 'channel_volumes', 'music'),
                    'voice_volume': ('audio', 'channel_volumes', 'voice'),
                    'narrator_volume': ('audio', 'channel_volumes', 'narrator'),
                    'world_volume': ('audio', 'channel_volumes', 'world'),
                    'ui_volume': ('audio', 'channel_volumes', 'ui')
                }
                
                for key, value in self.sim_state.audio_settings.items():
                    if key in settings_map:
                        path = settings_map[key]
                        if len(path) == 2:
                            manifest[path[0]][path[1]] = value
                        elif len(path) == 3:
                            manifest[path[0]][path[1]][path[2]] = value
                
                # Write back to manifest
                with open(manifest_path, 'w', encoding='utf-8') as f:
                    yaml.dump(manifest, f, default_flow_style=False, sort_keys=False)
                
                _dbg(f"[AUDIO] ✅ Audio settings saved to manifest: {manifest_path}")
                
                # Emit audio settings update event to runtime
                if hasattr(self.runtime, 'get') and 'event_q' in self.runtime:
                    event_q = self.runtime.get('event_q')
                    if event_q:
                        import your_runtime
                        event_q.put(your_runtime.StationEvent(
                            event_type="audio_settings_update",
                            content={
                                'audio_settings': dict(self.sim_state.audio_settings)
                            }
                        ))
                
            except Exception as e:
                _dbg(f"[AUDIO] ❌ Error saving audio settings: {e}")


# ============================================================
# SECTION 6.5: FTB Controller (Runtime Boundary)
# ============================================================

class FTBController:
    """
    Boundary object between FTB simulation engine and Radio OS runtime.
    
    Responsibilities:
    - Run tick loop thread
    - Process UI commands (delegate, save, load, tick control)
    - Convert SimEvent → StationEvent
    - Periodic widget refresh
    - Save/load with expanded serialization
    """
    
    def __init__(self, runtime: Dict[str, Any], mem: Dict[str, Any]):
        self.runtime = runtime
        self.mem = mem
        self.log = self.runtime.get('log', print)
        self.state: Optional[SimState] = None
        self.tick_rate = 2.0  # seconds per tick
        self.stop_event = threading.Event()
        self.thread: Optional[threading.Thread] = None
        self.state_lock = threading.Lock()
        self.state_db_path = None
        self.autosave_interval = 10  # ticks
        self.delegate_tick_interval = 60.0  # seconds per tick when delegated
        self.delegate_start_delay = 60.0  # seconds after enabling delegation
        self.delegate_next_tick_ts: Optional[float] = None  # timestamp for next auto-tick in delegated mode
        self.event_pool = self.runtime.get('ftb_event_pool')
        self._active_meta_plugin_cache = None  # populated lazily via property
        self.narrator = None
        self.current_save_path: Optional[str] = None
        self.race_day_thread: Optional[threading.Thread] = None
        self.race_day_stop_event = threading.Event()
        self.stop_tick_flag = False  # Flag to stop runaway batch ticks
        self._init_state_db()

    @property
    def active_meta_plugin(self):
        """Always do a fresh lookup – ACTIVE_META_PLUGIN is registered after
        plugins are loaded, so a value cached in __init__ would be None."""
        meta = self.runtime.get('ACTIVE_META_PLUGIN')
        if meta is not None:
            self._active_meta_plugin_cache = meta
        return self._active_meta_plugin_cache

    @active_meta_plugin.setter
    def active_meta_plugin(self, value):
        """Allow direct assignment (e.g. narrator teardown sets it to None)."""
        self._active_meta_plugin_cache = value

    def _init_state_db(self) -> None:
        if self.state_db_path or not ftb_state_db:
            return

        self._ensure_state_db(self._get_autosave_path(), reset=False)

    def _get_autosave_path(self) -> str:
        station_dir = self.runtime.get("STATION_DIR", ".")
        return os.path.join(station_dir, "ftb_autosave.json")

    def _resolve_state_db_path(self, save_path: Optional[str]) -> str:
        target_save = save_path or self._get_autosave_path()
        base, _ = os.path.splitext(target_save)
        return f"{base}.db"

    def _ensure_state_db(self, save_path: Optional[str], reset: bool = False) -> bool:
        if not ftb_state_db:
            return False

        db_path = self._resolve_state_db_path(save_path)
        existed = os.path.exists(db_path)

        if reset and existed:
            try:
                ftb_state_db.close_connection_cache(db_path)
                os.remove(db_path)
                existed = False
            except Exception as e:
                self.log('ftb', f'Failed to reset state DB: {e}')

        if db_path != self.state_db_path:
            # Close old database connection before switching
            if self.state_db_path:
                try:
                    ftb_state_db.close_connection_cache(self.state_db_path)
                    self.log('ftb', f'Closed old DB connection: {self.state_db_path}')
                except Exception as e:
                    self.log('ftb', f'Failed to close old DB connection: {e}')
            
            self.state_db_path = db_path
            self.runtime["FTB_STATE_DB_PATH"] = db_path
            if self.state:
                self.state.state_db_path = db_path
            if self.active_meta_plugin and hasattr(self.active_meta_plugin, "db_path"):
                try:
                    if self.active_meta_plugin.db_path != db_path:
                        self.active_meta_plugin.db_path = db_path
                        if getattr(self.active_meta_plugin, "narrator", None):
                            self.active_meta_plugin.narrator.stop()
                            self.active_meta_plugin.narrator = None
                except Exception as e:
                    self.log("ftb", f"Failed to sync narrator DB path: {e}")

        try:
            ftb_state_db.init_db(self.state_db_path)
            ftb_state_db.migrate_seed_column(self.state_db_path)
            ftb_state_db.migrate_game_id_column(self.state_db_path)
            self.log('ftb', f'State DB initialized at {self.state_db_path}')
        except Exception as e:
            self.log('ftb', f'Failed to initialize state DB: {e}')
            self.state_db_path = None
            return False

        return reset or not existed

    def _init_narrator_for_state(self) -> None:
        if not self.active_meta_plugin or not self.state or not self.state.player_team:
            return
        if not hasattr(self.active_meta_plugin, 'supports_streaming') or not self.active_meta_plugin.supports_streaming():
            return

        try:
            self.active_meta_plugin.process_input({
                'input_type': 'init_narrator',
                'player_team': self.state.player_team.name,
                'db_path': self.state_db_path,
                'game_id': getattr(self.state, 'game_id', '')
            })
        except Exception as e:
            self.log("ftb", f"Failed to initialize narrator via meta plugin: {e}")

    def _sync_state_db_for_save(self, save_path: str) -> None:
        if not self.state_db_path or not ftb_state_db:
            return

        target_db = self._resolve_state_db_path(save_path)
        if os.path.abspath(target_db) == os.path.abspath(self.state_db_path):
            return

        try:
            ftb_state_db.backup_db(self.state_db_path, target_db)
            self.log("ftb", f"State DB copied to {target_db}")
        except Exception as e:
            self.log("ftb", f"Failed to copy state DB for save: {e}")
    
    def _write_race_day_state_to_db(self, rds) -> None:
        """Write race day streaming state to database for narrator/UI access"""
        if not self.state_db_path or not ftb_state_db or not rds:
            return
        
        try:
            import json
            import sqlite3
            
            conn = sqlite3.connect(self.state_db_path)
            cursor = conn.cursor()
            
            game_id = getattr(self.state, 'game_id', '')
            
            # Write race day phase
            ftb_state_db.upsert_game_state(
                cursor, game_id, 'race_day_phase', str(rds.phase)
            )
            
            # Write current lap and total laps
            ftb_state_db.upsert_game_state(
                cursor, game_id, 'race_day_current_lap', str(rds.current_lap)
            )
            ftb_state_db.upsert_game_state(
                cursor, game_id, 'race_day_total_laps', str(rds.total_laps)
            )
            
            # Write league tier (for audio params)
            if self.state and self.state.player_team:
                player_league = None
                for league in self.state.leagues.values():
                    if self.state.player_team in league.teams:
                        player_league = league
                        break
                
                if player_league:
                    ftb_state_db.upsert_game_state(
                        cursor, game_id, 'player_league_tier', str(player_league.tier)
                    )
            
            # Write live standings (full field for narrator + UI)
            if rds.live_standings:
                # Write individual position keys (backwards-compatible for narrator)
                for i, standing in enumerate(rds.live_standings, 1):
                    key = f'race_day_standings_p{i}'
                    value = json.dumps(standing)
                    ftb_state_db.upsert_game_state(cursor, game_id, key, value)
                # Also write full standings as single JSON array
                ftb_state_db.upsert_game_state(
                    cursor, game_id, 'race_day_standings_full',
                    json.dumps(rds.live_standings)
                )
                ftb_state_db.upsert_game_state(
                    cursor, game_id, 'race_day_standings_count',
                    str(len(rds.live_standings))
                )
            
            conn.commit()
            conn.close()
            
        except Exception as e:
            self.log("ftb", f"Error writing race day state to DB: {e}")

    def _build_pbp_sim_events(self, race_result: 'RaceResult', league: 'League', track: Optional['Track']) -> List['SimEvent']:
        driver_team_map = {driver_name: team_name for driver_name, team_name, _ in race_result.final_positions}
        pbp_events: List[SimEvent] = []

        start_event = RaceEventRecord(
            lap_number=0,
            event_type="start",
            involved_drivers=[],
            description=f"Lights out at {race_result.track_name}"
        )
        race_events = [start_event] + list(race_result.race_events)

        finish_event = RaceEventRecord(
            lap_number=max((e.lap_number for e in race_events), default=0) + 1,
            event_type="finish",
            involved_drivers=[race_result.final_positions[0][0]] if race_result.final_positions else [],
            description=f"Checkered flag - {race_result.final_positions[0][0]} wins" if race_result.final_positions else "Checkered flag"
        )
        race_events.append(finish_event)

        for event in race_events:
            involved = event.involved_drivers or []
            lead_driver = involved[0] if involved else None
            team_name = driver_team_map.get(lead_driver, "") if lead_driver else ""

            if event.event_type in ["crash", "mechanical_dnf"]:
                priority = 85.0
                severity = "major"
            elif event.event_type == "penalty":
                priority = 75.0
                severity = "warning"
            elif event.event_type == "overtake":
                priority = 65.0
                severity = "info"
            else:
                priority = 55.0
                severity = "info"

            pbp_events.append(SimEvent(
                event_type="outcome",
                category="race_pbp",
                ts=self.state.tick if self.state else 0,
                priority=priority,
                severity=severity,
                event_id=FTBSimulation._generate_event_id(self.state),
                data={
                    "_ftb": True,
                    "pbp": True,
                    "lap": event.lap_number,
                    "event_type": event.event_type,
                    "description": event.description,
                    "drivers": involved,
                    "team": team_name,
                    "league_id": league.league_id,
                    "league_name": league.name,
                    "track_id": track.track_id if track else None,
                    "track_name": track.name if track else race_result.track_name
                }
            ))

        return pbp_events

    def _start_race_day_mode(self) -> None:
        if not self.state or not self.state.pending_race_day or self.state.race_day_active:
            return

        if self.race_day_thread and self.race_day_thread.is_alive():
            return

        info = self.state.pending_race_info or {}
        league = self.state.leagues.get(info.get('league_id')) if info.get('league_id') else None
        track = self.state.tracks.get(info.get('track_id')) if info.get('track_id') else None

        if not league and self.state.pending_race_tick:
            race_at_tick = self._find_player_race_at_tick(self.state.pending_race_tick)
            if race_at_tick:
                _, league, track_id = race_at_tick
                track = self.state.tracks.get(track_id) if track_id else None

        if not league:
            self.log("ftb", "Race day mode could not resolve league")
            return

        if not track:
            WorldBuilder._ensure_schedule_tracks(self.state, league)
            track = self.state.tracks.get(info.get('track_id')) if info.get('track_id') else None
            if not track:
                track = next((t for t in self.state.tracks.values()
                              if t.min_tier <= league.tier <= t.max_tier), None)

        self.state.race_day_active = True
        self.state.race_day_started_ts = time.time()
        self.race_day_stop_event.clear()

        self.race_day_thread = threading.Thread(
            target=self._race_day_worker,
            args=(league, track),
            daemon=True,
            name="FTB-Race-Day"
        )
        self.race_day_thread.start()

    def _race_day_worker(self, league: 'League', track: Optional['Track']) -> None:
        if not self.state:
            return

        try:
            self.log("ftb", f"Race day mode started for {league.name}")
            with self.state_lock:
                pending_tick = self.state.pending_race_tick
                original_tick = self.state.tick
                original_phase = self.state.phase
                target_tick = pending_tick if pending_tick is not None else original_tick

                self.state.pending_race_day = False
                self.state.pending_race_info = None
                self.state.pending_race_tick = None
                self.state.completed_race_ticks.add((league.league_id, target_tick))

                self.state._live_pbp_mode = True
                self.state._live_pbp_interval = None
                self.state.race_day_active = True

                self.state.tick = target_tick
                self.state.phase = "race_weekend"

                events = []
                events.append(SimEvent(
                    event_type="time",
                    category="enter_race_weekend",
                    ts=self.state.tick,
                    priority=70.0,
                    data={
                        'league_id': league.league_id,
                        'league_name': league.name,
                        'tier': league.tier,
                        'round_number': league.races_this_season + 1,
                        'calendar_date': self.state.current_date_str(),
                        'track_id': track.track_id if track else None,
                        'track_name': track.name if track else 'Unknown Circuit'
                    },
                    event_id=FTBSimulation._generate_event_id(self.state)
                ))

                league_tier_map = {1: 'formulaz', 2: 'formulaz', 3: 'midformula', 4: 'midformula', 5: 'grassroots'}
                league_tier_audio = league_tier_map.get(league.tier, 'midformula')
                events.append(SimEvent(
                    event_type="audio",
                    category="race_start",
                    ts=self.state.tick,
                    priority=50.0,
                    data={
                        'audio_type': 'world',
                        'action': 'engine_start',
                        'league_tier': league_tier_audio
                    },
                    event_id=FTBSimulation._generate_event_id(self.state)
                ))

                race_events = FTBSimulation.simulate_race_weekend(self.state, league, track)
                events.extend(race_events)

                self.state.phase = "development"

                events.append(SimEvent(
                    event_type="audio",
                    category="race_end",
                    ts=self.state.tick,
                    priority=50.0,
                    data={
                        'audio_type': 'world',
                        'action': 'engine_stop'
                    },
                    event_id=FTBSimulation._generate_event_id(self.state)
                ))

                self.state.tick = original_tick
                self.state.phase = original_phase

            race_result = self.state._last_race_results.get(league.league_id) or getattr(self.state, "_last_race_result", None)
            if not race_result:
                self.log("ftb", "Race day mode failed: no race result")
                return

            duration = max(60, int(getattr(self.state, "race_day_duration_sec", 300)))
            pbp_events = self._build_pbp_sim_events(race_result, league, track)
            interval = max(0.5, duration / max(1, len(pbp_events)))

            try:
                import ftb_pbp
                ftb_pbp.start_live_feed(race_result, self.state, interval_sec=interval)
            except Exception:
                pass

            result_categories = {"race_result", "fastest_lap_bonus", "race_end"}
            early_events = [e for e in events if e.category not in result_categories]
            final_events = [e for e in events if e.category in result_categories]

            if early_events:
                self._emit_events(early_events)
                if self.state_db_path and ftb_state_db:
                    ftb_state_db.write_event_batch(self.state_db_path, early_events)

            if self.state_db_path and ftb_state_db:
                start_ts = time.time()
                for idx, event in enumerate(pbp_events):
                    if self.race_day_stop_event.is_set():
                        break
                    target_ts = start_ts + (interval * idx)
                    sleep_for = target_ts - time.time()
                    if sleep_for > 0:
                        time.sleep(sleep_for)
                    ftb_state_db.write_event_batch(self.state_db_path, [event])

            if final_events:
                self._emit_events(final_events)
                if self.state_db_path and ftb_state_db:
                    ftb_state_db.write_event_batch(self.state_db_path, final_events)

            if self.state_db_path and ftb_state_db:
                ftb_state_db.write_game_snapshot(self.state_db_path, self.state)
                ftb_state_db.write_free_agents(self.state_db_path, self.state.free_agents)
                if self.state.tick % 10 == 0:
                    projection = self.state.get_calendar_projection(days_ahead=60)
                    ftb_state_db.write_calendar_projection(self.state_db_path, projection)

            context = self.state._last_race_contexts.get(league.league_id) or getattr(self.state, "_last_race_context", None)
            if context and context.get('qualifying_scores'):
                FTBSimulation._archive_race_result(
                    self.state,
                    league,
                    track,
                    race_result,
                    context['qualifying_scores']
                )

            if self.state.player_team:
                player_result = next(
                    (e for e in final_events if e.category == "race_result" and e.data.get('team') == self.state.player_team.name),
                    None
                )
                if player_result:
                    try:
                        import plugins.ftb_notifications as ftb_notif
                        pos = player_result.data.get('position', 0)
                        points = player_result.data.get('points', 0)
                        track_name = player_result.data.get('track_name', 'Unknown')
                        if pos <= 3:
                            priority = 80
                            title = f"🏆 P{pos} Finish at {track_name}!"
                        else:
                            priority = 60
                            title = f"🏁 P{pos} Finish at {track_name}"
                        message = f"{self.state.player_team.name} finished P{pos} and earned {points} points"
                        if player_result.data.get('prize_money', 0) > 0:
                            from plugins.ftb_game import format_currency
                            prize = format_currency(player_result.data['prize_money'])
                            message += f" and {prize} prize money"

                        ftb_notif.create_notification(
                            category='race_result',
                            title=title,
                            message=message,
                            priority=priority,
                            metadata={'position': pos, 'points': points, 'track': track_name},
                            db_path=getattr(self.state, 'state_db_path', None)
                        )
                    except Exception as e:
                        self.log("ftb", f"Failed to create race result notification: {e}")

            self.log("ftb", f"Race day mode complete for {league.name}")

        except Exception as e:
            self.log("ftb", f"Race day mode error: {e}")
            import traceback
            self.log("ftb", traceback.format_exc())
        finally:
            if self.state:
                self.state.race_day_active = False
                self.state.race_day_started_ts = None

    def _get_player_league(self) -> Optional['League']:
        if not self.state or not self.state.player_team:
            return None
        league_id = self.state.player_team.league_id
        if league_id and league_id in self.state.leagues:
            return self.state.leagues.get(league_id)
        for league in self.state.leagues.values():
            if self.state.player_team in league.teams:
                return league
        return None

    @staticmethod
    def _resolve_schedule_entry(entry: Any) -> Tuple[int, Optional[str]]:
        if isinstance(entry, (tuple, list)) and len(entry) == 2:
            return int(entry[0]), entry[1]
        return int(entry), None

    def _find_player_race_at_tick(self, target_tick: int) -> Optional[Tuple[int, 'League', Optional[str]]]:
        league = self._get_player_league()
        if not league or not league.schedule:
            return None
        for entry in league.schedule:
            race_tick, track_id = self._resolve_schedule_entry(entry)
            if race_tick == target_tick:
                return race_tick, league, track_id
        return None

    def _find_next_player_race_within(self, start_tick: int, end_tick: int) -> Optional[Tuple[int, 'League', Optional[str]]]:
        league = self._get_player_league()
        if not league or not league.schedule:
            return None
        next_race = None
        for entry in league.schedule:
            race_tick, track_id = self._resolve_schedule_entry(entry)
            if start_tick <= race_tick <= end_tick:
                if next_race is None or race_tick < next_race[0]:
                    next_race = (race_tick, league, track_id)
        return next_race

    def _arm_race_day(self, race_tick: int, league: 'League', track_id: Optional[str]) -> None:
        if not self.state:
            return
        track = self.state.tracks.get(track_id) if track_id else None
        track_name = track.name if track else "Unknown Circuit"
        self.state.pending_race_day = True
        self.state.pending_race_tick = race_tick
        self.state.pending_race_info = {
            'league_id': league.league_id,
            'league_name': league.name,
            'tier': league.tier,
            'track_id': track_id,
            'track_name': track_name
        }
    
    # ==================================================================
    # PBP Broadcast Commentary (driven from controller, not narrator)
    # ==================================================================
    
    def _get_broadcast_generator(self, league_tier: int):
        """Get or create a BroadcastCommentaryGenerator for the current tier."""
        if not ftb_broadcast_commentary:
            return None
        if not hasattr(self, '_broadcast_gen') or self._broadcast_gen_tier != league_tier:
            player_name = self.state.player_team.name if self.state and self.state.player_team else ''
            self._broadcast_gen = ftb_broadcast_commentary.BroadcastCommentaryGenerator(
                league_tier=league_tier,
                player_team_name=player_name
            )
            self._broadcast_gen_tier = league_tier
        return self._broadcast_gen
    
    def _enqueue_pbp_segment(self, text: str, voice_key: str = "play_by_play", priority: float = 90.0):
        """
        Enqueue a broadcast commentary segment into the TTS pipeline.
        Uses source='broadcast' so it is NOT blocked by PBP_ACTIVE filter
        (that filter only blocks source='narrator').
        
        Voice mapping strategy:
          - play_by_play  →  manifest "play_by_play" key, fallback to "host"
          - color_commentator → manifest "color_commentator" key, fallback to "narrator"
        This ensures the two voices are AUDIBLY DIFFERENT even if the station
        doesn't define dedicated PBP/color voices.
        """
        db_conn_fn = self.runtime.get('db_connect')
        db_enqueue_fn = self.runtime.get('db_enqueue_segment')
        if not db_conn_fn or not db_enqueue_fn or not text:
            missing = []
            if not db_conn_fn: missing.append('db_connect')
            if not db_enqueue_fn: missing.append('db_enqueue_segment')
            if not text: missing.append('text')
            _dbg(f"[FTB PBP] ⚠️  _enqueue_pbp_segment SKIPPED – missing: {', '.join(missing)}")
            return
        
        import hashlib
        seg_id = hashlib.sha1(f"pbp|{time.time()}|{text[:40]}".encode()).hexdigest()
        
        # Resolve voice path from manifest with smart fallbacks
        cfg = self.runtime.get('config', {})
        voices_a = cfg.get("voices", {}) or {}
        voices_b = (cfg.get("audio", {}) or {}).get("voices", {}) or {}
        
        # Try the exact key first, then intelligent fallback
        voice_path = voices_a.get(voice_key) or voices_b.get(voice_key)
        voice_name = voice_key
        
        if not voice_path:
            # Smart fallback: color → narrator voice, pbp → host voice
            if voice_key == "color_commentator":
                fallback_key = "narrator"
            else:
                fallback_key = "host"
            voice_path = voices_a.get(fallback_key) or voices_b.get(fallback_key)
            voice_name = fallback_key
            if voice_path:
                _dbg(f"[FTB PBP] 🔄 Voice '{voice_key}' not in manifest, using '{fallback_key}' instead")
        
        segment = {
            "id": seg_id,
            "post_id": seg_id,
            "source": "broadcast",          # NOT 'narrator' – must not be blocked
            "event_type": "broadcast_pbp",
            "title": "",
            "body": text,
            "comments": [],
            "angle": "",
            "why": "",
            "key_points": [],
            "priority": priority,
            "host_hint": "announce",
            "lead_voice": voice_name,
            "_voice": voice_name,
            "_voice_path": voice_path,
            "_literal": True,
            "_sfx_files": [],
            "_metadata": {"type": "broadcast"}
        }
        
        try:
            conn = db_conn_fn()
            db_enqueue_fn(conn, segment)
            conn.close()
            _dbg(f"[FTB PBP] 🎙️ Enqueued ({voice_key}): {text[:70]}...")
        except Exception as e:
            _dbg(f"[FTB PBP] ⚠️  Enqueue error: {e}")
    
    def _enqueue_pbp_commentary_for_race_start(self, rds, player_league, track):
        """Generate and enqueue 'lights out' + opening commentary."""
        tier = player_league.tier if player_league else 3
        gen = self._get_broadcast_generator(tier)
        
        track_name = track.name if track and hasattr(track, 'name') else rds.track_id or 'unknown circuit'
        league_name = player_league.name if player_league else 'the championship'
        
        # Pre-race line
        self._enqueue_pbp_segment(
            f"Welcome to {track_name} for round {rds.race_number if hasattr(rds, 'race_number') else ''} "
            f"of {league_name}! {rds.total_laps} laps ahead of us! Let's GO!",
            voice_key="play_by_play", priority=95.0
        )
        
        # Lights out line
        if gen:
            lights = gen.generate_lights_out_commentary()
            if lights:
                # generate_lights_out_commentary returns a single CommentaryLine or list
                lines = lights if isinstance(lights, list) else [lights]
                for line in lines:
                    vk = "play_by_play" if getattr(line, 'speaker', 'pbp') == 'pbp' else "color_commentator"
                    self._enqueue_pbp_segment(line.text, voice_key=vk, priority=94.0)
        else:
            self._enqueue_pbp_segment(
                "It's LIGHTS OUT AND AWAY WE GO!",
                voice_key="play_by_play", priority=94.0
            )
    
    def _enqueue_pbp_commentary_for_lap(self, rds):
        """Generate commentary for the current lap's events + periodic updates.
        
        AGGRESSIVE QUEUE FLUSH: Before enqueuing new commentary, flush all
        stale queued broadcast segments so we never talk about lap 1 on lap 4.
        Only the CURRENT lap's events matter.
        """
        if not rds or not rds.race_result:
            return
        
        # ── AGGRESSIVE FLUSH: Kill all stale queued broadcast segments ──
        # This prevents the "talking about lap 1 on lap 4" problem.
        # Any broadcast_pbp segment still sitting in 'queued' status is OLD NEWS.
        try:
            db_conn_fn = self.runtime.get('db_connect')
            if db_conn_fn:
                _conn = db_conn_fn()
                _flushed = _conn.execute(
                    "UPDATE segments SET status='done' "
                    "WHERE status='queued' AND source='broadcast'"
                ).rowcount
                _conn.commit()
                _conn.close()
                if _flushed:
                    _dbg(f"[FTB PBP] 🧹 FLUSHED {_flushed} stale broadcast segments — keeping commentary CURRENT!")
        except Exception as _flush_err:
            _dbg(f"[FTB PBP] ⚠️  Could not flush stale segments: {_flush_err}")
        
        # ── Also drain pre-rendered audio queue to kill stale TTS ──
        try:
            _audio_q = self.runtime.get('audio_queue')
            if _audio_q:
                _drained = 0
                while not _audio_q.empty():
                    try:
                        _audio_q.get_nowait()
                        _drained += 1
                    except Exception:
                        break
                if _drained:
                    _dbg(f"[FTB PBP] 🧹 Drained {_drained} stale pre-rendered audio items")
        except Exception:
            pass
        
        tier = getattr(rds, 'league_tier', 3)
        # Try to get tier from state
        if self.state and hasattr(self.state, 'leagues'):
            for lg in self.state.leagues.values():
                if self.state.player_team in lg.teams:
                    tier = lg.tier
                    break
        
        gen = self._get_broadcast_generator(tier)
        lap = rds.current_lap
        total = rds.total_laps
        player_team = self.state.player_team.name if self.state and self.state.player_team else ''
        
        # Update race context for the generator
        if gen:
            gen.race_context.lap_number = lap
            gen.race_context.total_laps = total
        
        # Collect events this lap
        lap_events = [e for e in rds.race_result.race_events if e.lap_number == lap]
        
        # ── Limit events per lap to avoid queue flooding ──
        # Keep at most 3 events per lap (prioritize crashes/DNFs over overtakes)
        if len(lap_events) > 3:
            critical = [e for e in lap_events if any(k in (getattr(e, 'event_type', '') or '').lower() 
                        for k in ('crash', 'dnf', 'retire', 'collision', 'accident'))]
            others = [e for e in lap_events if e not in critical]
            random.shuffle(others)
            lap_events = critical[:3] + others[:max(0, 3 - len(critical))]
        
        for ev in lap_events:
            et = ev.event_type.lower() if hasattr(ev, 'event_type') else ''
            desc = ev.description if hasattr(ev, 'description') else str(ev)
            meta = getattr(ev, 'metadata', {}) or {}
            # RaceEventRecord stores involved_drivers (list) not driver_name/team_name
            drivers = getattr(ev, 'involved_drivers', []) or []
            driver = drivers[0] if drivers else ''
            # Try to find team + position from live standings
            team = ''
            driver_pos = 0
            for s in (rds.live_standings or []):
                if s.get('driver') == driver:
                    team = s.get('team', '')
                    driver_pos = s.get('position', 0)
                    break
            is_player = (team == player_team)
            
            if gen:
                lines = []
                if 'overtake' in et:
                    pos_change = getattr(ev, 'position_change', {}) or {}
                    pos = pos_change.get(driver, 0)
                    passed_driver = meta.get('passed_driver', '')
                    delta = meta.get('delta', 0.0)
                    lines = gen.generate_overtake_commentary(
                        driver, pos, lap, is_player,
                        passed_driver=passed_driver, delta=delta, team=team
                    )
                elif 'crash' in et or 'collision' in et or 'accident' in et:
                    time_loss = meta.get('time_loss', 0.0)
                    lines = gen.generate_crash_commentary(
                        driver, team, lap, is_player,
                        time_loss=time_loss, position=driver_pos
                    )
                elif 'dnf' in et or 'retire' in et:
                    try:
                        lines = gen.generate_dnf_commentary(
                            driver, team, lap, is_player,
                            position=driver_pos
                        )
                    except Exception:
                        lines = []
                
                for line in (lines or []):
                    vk = "play_by_play" if getattr(line, 'speaker', 'pbp') == 'pbp' else "color_commentator"
                    self._enqueue_pbp_segment(line.text, voice_key=vk, priority=getattr(line, 'priority', 88.0))
            else:
                # Fallback: just narrate the description
                if desc:
                    self._enqueue_pbp_segment(desc, voice_key="play_by_play", priority=88.0)
        
        # Periodic lap update (every 5 laps)
        if lap % 5 == 0 and gen and rds.live_standings:
            leader = rds.live_standings[0] if rds.live_standings else {}
            leader_name = leader.get('driver', 'Unknown')
            gap = leader.get('gap', 0.0)
            try:
                result = gen.generate_lap_update(lap, total, leader_name, gap)
                # generate_lap_update returns a single CommentaryLine or None
                if result:
                    vk = "play_by_play" if getattr(result, 'speaker', 'pbp') == 'pbp' else "color_commentator"
                    self._enqueue_pbp_segment(result.text, voice_key=vk, priority=86.0)
            except Exception:
                self._enqueue_pbp_segment(
                    f"Lap {lap} of {total}! {leader_name} leads and the battle rages on!",
                    voice_key="play_by_play", priority=86.0
                )
        
        # Final lap
        if lap == total and gen and rds.live_standings:
            leader = rds.live_standings[0] if rds.live_standings else {}
            leader_name = leader.get('driver', 'Unknown')
            leader_team = leader.get('team', '')
            is_player_leading = (leader_team == player_team)
            try:
                lines = gen.generate_final_lap_commentary(leader_name, leader_team, is_player_leading)
                for line in (lines or []):
                    vk = "play_by_play" if getattr(line, 'speaker', 'pbp') == 'pbp' else "color_commentator"
                    self._enqueue_pbp_segment(line.text, voice_key=vk, priority=95.0)
            except Exception:
                self._enqueue_pbp_segment(
                    f"And the chequered flag waves! {leader_name} takes the VICTORY!",
                    voice_key="play_by_play", priority=95.0
                )

    def _stream_live_race_event(self) -> bool:
        """
        Stream one event from the live race queue.
        Returns True if event was streamed, False if streaming is complete.
        """
        if not self.state or not getattr(self.state, '_live_pbp_mode', False):
            return False
        
        cursor = getattr(self.state, '_live_pbp_cursor', 0)
        events = getattr(self.state, '_live_pbp_events', [])
        interval = getattr(self.state, '_live_pbp_interval', 2.0)
        start_ts = getattr(self.state, '_live_pbp_start_ts', time.time())
        
        if cursor >= len(events):
            # Streaming complete
            return False
        
        # Check if enough time has passed for next event
        elapsed = time.time() - start_ts
        expected_time = cursor * interval
        
        if elapsed < expected_time:
            # Not time yet
            return True
        
        # Stream next event
        event = events[cursor]
        _dbg(f"[FTB LIVE RACE] 📡 Streaming event {cursor+1}/{len(events)}: {event.category}")
        
        # Emit event to narrator/audio system
        self._emit_events([event])
        
        # Write to state DB
        if self.state_db_path and ftb_state_db:
            try:
                ftb_state_db.write_event_batch(self.state_db_path, [event])
            except Exception as e:
                _dbg(f"[FTB] Warning: Could not write live event to DB: {e}")
        
        # Advance cursor
        self.state._live_pbp_cursor = cursor + 1
        
        return True
    
    def _finalize_live_race(self) -> None:
        """
        Finalize the live race after all events have been streamed.
        This completes the tick and returns to normal flow.
        """
        if not self.state:
            return
        
        _dbg(f"[FTB LIVE RACE] 🏁 Finalizing live race mode")
        
        # Clear live mode flags
        self.state._live_pbp_mode = False
        self.state._live_pbp_events = []
        self.state._live_pbp_cursor = 0
        
        # Emit race end event
        events = []
        events.append(SimEvent(
            event_type="audio",
            category="race_end",
            ts=self.state.tick,
            priority=50.0,
            data={
                'audio_type': 'world',
                'action': 'engine_stop'
            }
        ))
        
        # Emit final events and complete tick
        self._emit_events(events)
        
        if self.state_db_path and ftb_state_db:
            try:
                ftb_state_db.write_event_batch(self.state_db_path, events)
                ftb_state_db.write_game_snapshot(self.state_db_path, self.state)
            except Exception as e:
                _dbg(f"[FTB] Warning: Could not write final race events to DB: {e}")
        
        _dbg(f"[FTB LIVE RACE] ✅ Live race finalized, returning to normal flow")
        
        # Trigger UI refresh
        self._refresh_widget()
    
    def _check_for_upcoming_player_race(self, tick: int) -> Optional[Tuple[str, str, int]]:
        """
        Check if player has a race on this tick.
        Returns (league_name, track_name, round_number) if yes, None otherwise.
        """
        if not self.state or not self.state.player_team:
            return None
        
        player_league_id = self.state.player_team.league_id
        if not player_league_id:
            return None
        
        league = self.state.leagues.get(player_league_id)
        if not league or not league.schedule:
            return None
        
        # Check if this tick has a race
        for entry in league.schedule:
            race_tick = None
            track_id = None
            
            if isinstance(entry, (tuple, list)) and len(entry) == 2:
                race_tick, track_id = entry[0], entry[1]
            else:
                race_tick = entry
            
            if race_tick == tick:
                # CRITICAL: Skip if this race was already completed (via live race day)
                if hasattr(self.state, 'completed_race_ticks') and (league.league_id, race_tick) in self.state.completed_race_ticks:
                    _dbg(f"[FTB RACE DAY] ⏭️ _check_for_upcoming_player_race: race at tick {race_tick} already completed, skipping")
                    return None
                # Also skip if already prompted (live race day flow)
                if hasattr(self.state, 'prompted_race_ticks') and (league.league_id, race_tick) in self.state.prompted_race_ticks:
                    _dbg(f"[FTB RACE DAY] ⏭️ _check_for_upcoming_player_race: race at tick {race_tick} already prompted, skipping")
                    return None
                
                # Found a race!
                track = self.state.tracks.get(track_id) if track_id else None
                track_name = track.name if track else "Unknown Circuit"
                round_num = league.races_this_season + 1
                
                return (league.name, track_name, round_num)
        
        return None
    
    def _show_watch_race_dialog(self, race_data: Dict[str, Any]) -> None:
        """
        Show a dialog asking the user if they want to watch the race live.
        Uses tkinter messagebox for immediate response.
        This is a BLOCKING call - it waits for user input.
        """
        _dbg(f"[FTB DIALOG] 🏁 Showing watch race dialog for {race_data.get('track_name', 'Unknown Circuit')}")
        
        try:
            import tkinter.messagebox as messagebox
            
            league_name = race_data.get('league_name', 'Unknown League')
            track_name = race_data.get('track_name', 'Unknown Circuit')
            round_num = race_data.get('round_number', 1)
            
            # Show blocking dialog
            title = f"🏁 Race Day - Round {round_num}"
            message = f"{league_name}\n{track_name}\n\nWould you like to watch the race unfold live in play-by-play?"
            
            # This will block until user responds
            result = messagebox.askyesno(title, message)
            
            _dbg(f"[FTB DIALOG] User responded: {'YES (watch live)' if result else 'NO (instant)'}")
            
            # Set flag directly on state
            if self.state:
                self.state._watch_current_race_live = result
                _dbg(f"[FTB DIALOG] Flag set on state: _watch_current_race_live = {result}")
            else:
                _dbg(f"[FTB DIALOG] ERROR: No state available to set flag!")
                    
        except Exception as e:
            _dbg(f"[FTB DIALOG] Error showing dialog: {e}")
            import traceback
            traceback.print_exc()
            # Default to NO (instant) if dialog fails
            if self.state:
                self.state._watch_current_race_live = False
    
    def start_new_game(self, origin: Optional[str] = None, 
                      identity: Optional[List[str]] = None,
                      save_mode: Optional[str] = None,
                      tier: str = "grassroots",
                      seed: Optional[int] = None,
                      team_name: Optional[str] = None,
                      ownership: str = "hired_manager",
                      manager_age: int = 32,
                      manager_first_name: str = "",
                      manager_last_name: str = "") -> None:
        """Create new save and initialize simulation"""
        _dbg(f"[FTB CONTROLLER] 🆕 start_new_game ENTRY: origin={origin}, tier={tier}, seed={seed}, team_name={team_name}")
        _dbg(f"[FTB CONTROLLER] 🆕 Parameters: ownership={ownership}, manager_age={manager_age}, name={manager_first_name} {manager_last_name}")
        
        # Generate unique game ID for this session
        game_id = str(uuid.uuid4())
        _dbg(f"[FTB CONTROLLER] 🆔 Generated new game_id: {game_id}")
        
        # Force narrator shutdown before any state changes to prevent state pollution
        _dbg(f"[FTB CONTROLLER] 🛑 Forcing narrator shutdown...")
        if self.active_meta_plugin and hasattr(self.active_meta_plugin, 'narrator'):
            try:
                narrator = getattr(self.active_meta_plugin, 'narrator', None)
                if narrator:
                    _dbg(f"[FTB CONTROLLER] 🛑 Stopping narrator thread...")
                    narrator.stop()
                    # Wait a moment for narrator thread to clean up
                    time.sleep(0.5)
                    self.active_meta_plugin.narrator = None
                    _dbg(f"[FTB CONTROLLER] ✅ Narrator stopped and cleared")
            except Exception as e:
                self.log("ftb", f"Failed to stop narrator: {e}")
                _dbg(f"[FTB CONTROLLER] ⚠️ Narrator shutdown failed: {e}")
        
        # Clear controller-level caches for clean slate
        self.last_known_tick = 0
        if hasattr(self, 'weekend_summary_cache'):
            self.weekend_summary_cache = {}
        if hasattr(self, 'pending_notifications'):
            self.pending_notifications = []
        _dbg(f"[FTB CONTROLLER] 🧹 Cleared controller state caches")
        
        self.current_save_path = self._get_autosave_path()
        _dbg(f"[FTB CONTROLLER] 💾 Setting current_save_path to: {self.current_save_path}")
        
        _dbg(f"[FTB CONTROLLER] 🗄️ Ensuring state DB (reset=True)...")
        self._ensure_state_db(self.current_save_path, reset=True)
        _dbg(f"[FTB CONTROLLER] 🗄️ State DB path: {self.state_db_path}")
        
        # ── FLUSH all stale queued audio from previous session ──
        try:
            _db_conn_fn = self.runtime.get('db_connect')
            if _db_conn_fn:
                _conn = _db_conn_fn()
                _flushed = _conn.execute(
                    "UPDATE segments SET status='done' WHERE status='queued'"
                ).rowcount
                _conn.commit()
                _conn.close()
                if _flushed:
                    _dbg(f"[FTB CONTROLLER] 🧹 FLUSHED {_flushed} stale queued audio segments on new game")
        except Exception as _flush_err:
            _dbg(f"[FTB CONTROLLER] ⚠️  Could not flush stale audio on new game: {_flush_err}")
        try:
            _audio_q = self.runtime.get('audio_queue')
            if _audio_q:
                _drained = 0
                while not _audio_q.empty():
                    try:
                        _audio_q.get_nowait()
                        _drained += 1
                    except Exception:
                        break
                if _drained:
                    _dbg(f"[FTB CONTROLLER] 🧹 Drained {_drained} pre-rendered audio items on new game")
        except Exception:
            pass
        try:
            _show_interrupt = self.runtime.get('SHOW_INTERRUPT')
            if _show_interrupt:
                _show_interrupt.set()
                import time as _time
                _time.sleep(0.2)
                _show_interrupt.clear()
                _dbg(f"[FTB CONTROLLER] 🔇 Interrupted stale TTS on new game")
        except Exception:
            pass
        
        self.log("ftb", f"Starting new game: origin={origin}, identity={identity}, save_mode={save_mode}, tier={tier}, seed={seed}, team_name={team_name}, ownership={ownership}, manager_age={manager_age}, manager_name={manager_first_name} {manager_last_name}")
        cfg = self.runtime.get("config", {}).get("ftb", {})
        _dbg(f"[FTB CONTROLLER] ⚙️ Config: {cfg}")
        
        origin = origin or cfg.get("origin_story", "game_show_winner")
        identity = identity or cfg.get("player_identity", [])
        save_mode = save_mode or cfg.get("save_mode", "permanent")
        starting_tier = cfg.get("starting_tier", tier)
        
        if seed is None:
            seed = int(time.time()) if save_mode == "permanent" else 42
        
        _dbg(f"[FTB CONTROLLER] Resolved parameters: origin={origin}, tier={starting_tier}, seed={seed}")
        _dbg(f"[FTB CONTROLLER] Creating new save with FTBSimulation.create_new_save...")
        self.log("ftb", f"Creating new save with resolved params...")
        
        with self.state_lock:
            _dbg(f"[FTB CONTROLLER] 🔒 State lock acquired, calling FTBSimulation.create_new_save...")
            self.state = FTBSimulation.create_new_save(
                origin_story=origin,
                player_identity=identity,
                save_mode=save_mode,
                tier=starting_tier,
                seed=seed,
                team_name=team_name,
                ownership=ownership,
                manager_age=manager_age,
                manager_first_name=manager_first_name,
                manager_last_name=manager_last_name
            )
            _dbg(f"[FTB CONTROLLER] ✅ FTBSimulation.create_new_save returned: {type(self.state).__name__ if self.state else 'None'}")
            # Set state database path for narrator/delegate interface
            if self.state:
                # Assign unique game ID to this new game session
                self.state.game_id = game_id
                _dbg(f"[FTB CONTROLLER] 🆔 Assigned game_id to state: {self.state.game_id}")
                
                self.state.state_db_path = self.state_db_path
                _dbg(f"[FTB CONTROLLER] 🗄️ Set state.state_db_path: {self.state.state_db_path}")
                # Mark all domains as dirty to force UI refresh after new game creation
                self.state.mark_dirty('all')
                _dbg(f"[FTB CONTROLLER] ✓ Marked all domains as dirty for UI refresh")
        
        self.log("ftb", f"New game created successfully! Team: {self.state.player_team.name if self.state and self.state.player_team else 'None'}")
        _dbg(f"[FTB CONTROLLER] ✓ New game created: state={self.state is not None}, player_team={self.state.player_team.name if self.state and self.state.player_team else 'None'}")
        _dbg(f"[FTB CONTROLLER] ✓ Game tick: {self.state.tick if self.state else 'NO STATE'}")
        
        # Initialize state-aware narrator
        if self.event_pool and self.state and self.state.player_team:
            try:
                from plugins_disabled.perhapsuse import StateAwareNarrator, StateSnapshot
                manifest = self.runtime.get('station_manifest', {})
                
                # Create runtime stub for narrator
                runtime_stub = {
                    'log': self.log,
                    'config': self.runtime.get('config', {})
                }
                
                # Initialize narrator
                self.narrator = StateAwareNarrator(
                    event_pool=self.event_pool,
                    player_team=self.state.player_team.name,
                    runtime_stub=runtime_stub,
                    manifest_cfg=manifest
                )
                
                # Start narrator thread
                self.narrator.start()
                
                # Generate waiting room narration (pre-tick orientation)
                initial_snapshot = StateSnapshot(
                    tick=0,
                    player_team=self.state.player_team.name,
                    player_role=self.state.player_identity[0] if self.state.player_identity else "Manager",
                    league_tier=self.state.player_team.tier if self.state.player_team else 1,
                    league_name=self.state.player_team.tier_name if self.state.player_team else "Unknown",
                    budget=int(self.state.player_team.budget.cash) if self.state.player_team else 0,
                    budget_status="healthy",
                    driver_names=[d.name for d in self.state.player_team.drivers] if self.state.player_team else [],
                    car_exists=True,
                    current_day=self.state.sim_day_of_year,
                    current_season=self.state.season_number
                )
                
                self.narrator.waiting_room_narration(initial_snapshot)
                self.log("ftb", f"State-aware narrator initialized and waiting room shown for {self.state.player_team.name}")
                
            except Exception as e:
                self.log("ftb", f"Failed to initialize state-aware narrator: {e}")
                import traceback
                traceback.print_exc()
        
        # Initialize continuous narrator via meta plugin (legacy path)
        if self.active_meta_plugin and self.state and self.state.player_team:
            try:
                # Check if meta plugin supports streaming (FTB narrator)
                if hasattr(self.active_meta_plugin, 'supports_streaming') and self.active_meta_plugin.supports_streaming():
                    # Initialize narrator with player team, DB path, and game_id
                    self.active_meta_plugin.process_input({
                        'input_type': 'init_narrator',
                        'player_team': self.state.player_team.name,
                        'db_path': self.state_db_path,
                        'game_id': self.state.game_id
                    })
                    self.log("ftb", f"Narrator initialized via meta plugin for {self.state.player_team.name} (game_id: {self.state.game_id})")
            except Exception as e:
                self.log("ftb", f"Failed to initialize narrator via meta plugin: {e}")
        
        self.log("ftb", f"New game: {origin} | {starting_tier} | {save_mode} | Seed: {seed}")
        
        # Write initial game snapshot and calendar projection to database
        if self.state_db_path and ftb_state_db:
            try:
                # Validate player team and league assignment before calendar write
                if self.state.player_team:
                    player_in_league = False
                    for league in self.state.leagues.values():
                        if self.state.player_team in league.teams:
                            player_in_league = True
                            _dbg(f"[FTB] INIT_VALIDATION: Player team '{self.state.player_team.name}' found in league '{league.name}'")
                            _dbg(f"[FTB] INIT_VALIDATION: League has {len(league.schedule)} races scheduled")
                            break
                    if not player_in_league:
                        _dbg(f"[FTB] INIT_WARNING: Player team '{self.state.player_team.name}' not assigned to any league!")
                        _dbg(f"[FTB] INIT_WARNING: Available leagues: {list(self.state.leagues.keys())}")
                else:
                    _dbg(f"[FTB] INIT_WARNING: No player team set! Calendar will be empty.")
                
                ftb_state_db.write_game_snapshot(self.state_db_path, self.state)
                ftb_state_db.write_free_agents(self.state_db_path, self.state.free_agents)
                projection = self.state.get_calendar_projection(days_ahead=60)
                _dbg(f"[FTB] INITIAL_CALENDAR_WRITE: Writing {len(projection)} calendar entries at game start")
                if projection:
                    sample = projection[0] if projection else None
                    _dbg(f"[FTB] INITIAL_CALENDAR_SAMPLE: {sample}")
                else:
                    _dbg(f"[FTB] INITIAL_CALENDAR_WRITE: WARNING - No calendar entries generated!")
                ftb_state_db.write_calendar_projection(self.state_db_path, projection)
                self.log("ftb", "Initial game state and calendar written to database")
            except Exception as e:
                self.log("ftb", f"Failed to write initial state to database: {e}")
        
        # Clear old notifications from database
        if self.state_db_path:
            try:
                import plugins.ftb_notifications as ftb_notif
                ftb_notif.clear_all_notifications(self.state_db_path)
                self.log("ftb", "Cleared old notifications for new game")
            except Exception as e:
                self.log("ftb", f"Failed to clear notifications: {e}")
        
        # Perform initial save
        self.save_game()
        self.log("ftb", "[INITIAL_SAVE] Game state saved immediately after creation")
    
    def load_save(self, path: str) -> None:
        """Load save from JSON"""
        _dbg(f"[FTB CONTROLLER] 📁 load_save ENTRY: path={path}")
        try:
            _dbg(f"[FTB CONTROLLER] 📁 Setting current_save_path to {path}")
            self.current_save_path = path
            _dbg(f"[FTB CONTROLLER] 📁 Ensuring state DB for save...")
            db_new_or_reset = self._ensure_state_db(path, reset=False)
            _dbg(f"[FTB CONTROLLER] 📁 State DB result: new_or_reset={db_new_or_reset}, path={self.state_db_path}")
            
            _dbg(f"[FTB CONTROLLER] 🔒 Acquiring state lock for load...")
            with self.state_lock:
                _dbg(f"[FTB CONTROLLER] 📂 Loading SimState from JSON...")
                self.state = SimState.load_from_json(path)
                _dbg(f"[FTB CONTROLLER] ✅ SimState loaded: tick={self.state.tick if self.state else 'None'}")
                if self.state:
                    _dbg(f"[FTB CONTROLLER] State details: player_team={self.state.player_team.name if self.state.player_team else 'None'}, leagues={len(self.state.leagues)}, day={self.state.sim_day_of_year}")
                    # Mark all domains as dirty to force UI refresh after loading
                    self.state.mark_dirty('all')
                    _dbg(f"[FTB CONTROLLER] ✓ Marked all domains as dirty for UI refresh")
                    
                    # CRITICAL: Reset race_day_state to IDLE after loading to avoid stale race data
                    if ftb_race_day and hasattr(self.state, 'race_day_state') and self.state.race_day_state:
                        from plugins.ftb_race_day import RaceDayPhase
                        self.state.race_day_state.phase = RaceDayPhase.IDLE
                        self.state.race_day_state.race_tick = None
                        self.state.race_day_state.league_id = None
                        self.state.race_day_state.track_id = None
                        self.state.race_day_state.player_wants_live_race = False
                        _dbg(f"[FTB CONTROLLER] 🔄 Reset race_day_state to IDLE after load")
                    
                # Set state database path for narrator/delegate interface
                self.state.state_db_path = self.state_db_path
                _dbg(f"[FTB CONTROLLER] 🗄️ Set state DB path: {self.state.state_db_path}")

            # ── FLUSH all stale queued audio on load ──
            # Kills leftover broadcast/narrator segments from a previous session
            # so the PBP guy doesn't read old race commentary on launch.
            try:
                _db_conn_fn = self.runtime.get('db_connect')
                if _db_conn_fn:
                    _conn = _db_conn_fn()
                    _flushed = _conn.execute(
                        "UPDATE segments SET status='done' WHERE status='queued'"
                    ).rowcount
                    _conn.commit()
                    _conn.close()
                    if _flushed:
                        _dbg(f"[FTB CONTROLLER] 🧹 FLUSHED {_flushed} stale queued audio segments on save load")
                    else:
                        _dbg(f"[FTB CONTROLLER] ✅ Audio queue clean — no stale segments")
            except Exception as _flush_err:
                _dbg(f"[FTB CONTROLLER] ⚠️  Could not flush stale audio on load: {_flush_err}")
            
            # ── Also drain pre-rendered audio queue ──
            try:
                _audio_q = self.runtime.get('audio_queue')
                if _audio_q:
                    _drained = 0
                    while not _audio_q.empty():
                        try:
                            _audio_q.get_nowait()
                            _drained += 1
                        except Exception:
                            break
                    if _drained:
                        _dbg(f"[FTB CONTROLLER] 🧹 Drained {_drained} pre-rendered audio items on save load")
            except Exception:
                pass
            
            # ── Interrupt any currently-playing TTS ──
            try:
                _show_interrupt = self.runtime.get('SHOW_INTERRUPT')
                if _show_interrupt:
                    _show_interrupt.set()
                    import time as _time
                    _time.sleep(0.2)
                    _show_interrupt.clear()
                    _dbg(f"[FTB CONTROLLER] 🔇 Interrupted stale TTS on save load")
            except Exception:
                pass

            if self.state_db_path and ftb_state_db:
                try:
                    _dbg(f"[FTB CONTROLLER] 💾 Writing initial state to DB...")
                    ftb_state_db.write_game_snapshot(self.state_db_path, self.state)
                    ftb_state_db.write_free_agents(self.state_db_path, self.state.free_agents)
                    _dbg(f"[FTB CONTROLLER] 📅 Getting calendar projection...")
                    projection = self.state.get_calendar_projection(days_ahead=60)
                    _dbg(f"[FTB CONTROLLER] 📅 Writing {len(projection)} calendar entries to DB...")
                    ftb_state_db.write_calendar_projection(self.state_db_path, projection)
                    if db_new_or_reset:
                        _dbg("[FTB CONTROLLER] ✅ Loaded save wrote initial state to new DB")
                        self.log("ftb", "Loaded save wrote initial state to new DB")
                except Exception as e:
                    _dbg(f"[FTB CONTROLLER] ❌ Failed to write loaded state to database: {e}")
                    self.log("ftb", f"Failed to write loaded state to database: {e}")
            
            # Clear old notifications from database
            if self.state_db_path:
                try:
                    _dbg(f"[FTB CONTROLLER] 🧹 Clearing old notifications...")
                    import plugins.ftb_notifications as ftb_notif
                    ftb_notif.clear_all_notifications(self.state_db_path)
                    _dbg(f"[FTB CONTROLLER] ✅ Cleared old notifications for loaded save")
                    self.log("ftb", "Cleared old notifications for loaded save")
                except Exception as e:
                    _dbg(f"[FTB CONTROLLER] ❌ Failed to clear notifications: {e}")
                    self.log("ftb", f"Failed to clear notifications: {e}")
            
            # Write race results from event_history to database
            if self.state_db_path and self.state:
                try:
                    _dbg(f"[FTB CONTROLLER] 🏁 Writing race results from event_history to DB...")
                    race_events = [e for e in self.state.event_history if e.category == "race_result"]
                    _dbg(f"[FTB CONTROLLER] Found {len(race_events)} race results in event_history")
                    
                    # Bulk write race results to database
                    races_written = 0
                    for event in race_events:
                        try:
                            # Build race record from event data
                            data = event.data
                            race_id = data.get('race_id', f"race_{event.ts}")
                            
                            # Find league info
                            league_id = data.get('league_id', '')
                            league = self.state.leagues.get(league_id) if league_id else None
                            
                            # Get finish positions from event data
                            finish_positions = data.get('finish_positions', [])
                            
                            # Create race record
                            race_record = {
                                'race_id': race_id,
                                'season': data.get('season', 0),
                                'round_number': data.get('round_number', 0),
                                'league_id': league_id,
                                'track_name': data.get('track_name', 'Unknown'),
                                'tick': event.ts,
                                'player_team_name': data.get('player_team_name', ''),
                                'player_drivers_json': json.dumps(data.get('player_drivers', [])),
                                'finish_positions_json': json.dumps(finish_positions),
                                'grid_position': data.get('grid_position'),
                                'prize_money': data.get('prize_money', 0.0),
                                'fastest_lap_holder': data.get('fastest_lap', [''])[0] if data.get('fastest_lap') else None,
                                'incidents_json': json.dumps(data.get('incidents', [])),
                                'championship_position_after': data.get('championship_position'),
                                'points_after': data.get('points_after')
                            }
                            
                            ftb_state_db.write_race_result_archive(self.state_db_path, race_record)
                            races_written += 1
                        except Exception as e:
                            _dbg(f"[FTB CONTROLLER] ⚠️ Failed to write race result: {e}")
                    
                    _dbg(f"[FTB CONTROLLER] ✅ Wrote {races_written} race results to database")
                    self.log("ftb", f"Wrote {races_written} race results to database")
                except Exception as e:
                    _dbg(f"[FTB CONTROLLER] ❌ Failed to bulk write race results: {e}")
                    import traceback
                    traceback.print_exc()
                    self.log("ftb", f"Failed to bulk write race results: {e}")
            
            _dbg(f"[FTB CONTROLLER] ✅ Load save completed successfully: {path}")
            self.log("ftb", f"Loaded save: {path}")
            _dbg(f"[FTB CONTROLLER] 🎙️ Initializing narrator for state...")
            self._init_narrator_for_state()
            _dbg(f"[FTB CONTROLLER] ✅ load_save method completed")
        except Exception as e:
            _dbg(f"[FTB CONTROLLER] ❌ Failed to load save: {e}")
            import traceback
            _dbg(f"[FTB CONTROLLER] ❌ Load save traceback: {traceback.format_exc()}")
            self.log("ftb", f"Failed to load save: {e}")
    
    def load_from_db(self, clear_existing: bool = False) -> int:
        """Load race results from database into event_history.
        
        Args:
            clear_existing: If True, clears existing race_result events before loading
            
        Returns:
            Number of race results loaded
        """
        _dbg(f"[FTB CONTROLLER] 🗄️ load_from_db ENTRY (clear_existing={clear_existing})")
        
        if not self.state:
            _dbg(f"[FTB CONTROLLER] ❌ No state available for load_from_db")
            return 0
            
        if not self.state_db_path:
            _dbg(f"[FTB CONTROLLER] ❌ No database path available")
            return 0
        
        try:
            with self.state_lock:
                # Clear existing race results if requested
                if clear_existing:
                    original_count = len(self.state.event_history)
                    self.state.event_history = [
                        e for e in self.state.event_history 
                        if e.category != "race_result"
                    ]
                    removed = original_count - len(self.state.event_history)
                    _dbg(f"[FTB CONTROLLER] 🗑️ Cleared {removed} existing race results from event_history")
                
                # Load race results from database
                results = ftb_state_db.query_race_results(self.state_db_path)
                _dbg(f"[FTB CONTROLLER] 📊 Found {len(results)} race results in database")
                
                # Convert DB records to SimEvent objects and add to event_history
                loaded = 0
                for result in results:
                    try:
                        # Parse JSON fields
                        finish_positions = json.loads(result.get('finish_positions_json', '[]'))
                        player_drivers = json.loads(result.get('player_drivers_json', '[]'))
                        incidents = json.loads(result.get('incidents_json', '[]'))
                        
                        # Create SimEvent from DB record
                        event = SimEvent(
                            event_type="outcome",
                            category="race_result",
                            ts=result.get('tick', 0),
                            priority=80.0,
                            severity="info",
                            description=f"Race at {result.get('track_name', 'Unknown')}",
                            data={
                                'race_id': result.get('race_id'),
                                'season': result.get('season'),
                                'round_number': result.get('round_number'),
                                'league_id': result.get('league_id'),
                                'track_name': result.get('track_name'),
                                'finish_positions': finish_positions,
                                'player_team_name': result.get('player_team_name'),
                                'player_drivers': player_drivers,
                                'grid_position': result.get('grid_position'),
                                'prize_money': result.get('prize_money', 0.0),
                                'fastest_lap': [result.get('fastest_lap_holder')] if result.get('fastest_lap_holder') else [],
                                'incidents': incidents,
                                'championship_position': result.get('championship_position_after'),
                                'points_after': result.get('points_after')
                            },
                            event_id=0  # Will be assigned when added
                        )
                        
                        # Check if this event already exists (by race_id or tick)
                        race_id = result.get('race_id')
                        tick = result.get('tick', 0)
                        exists = any(
                            e.category == "race_result" and 
                            (e.data.get('race_id') == race_id or 
                             (e.ts == tick and e.data.get('track_name') == result.get('track_name')))
                            for e in self.state.event_history
                        )
                        
                        if not exists:
                            self.state.event_history.append(event)
                            loaded += 1
                        
                    except Exception as e:
                        _dbg(f"[FTB CONTROLLER] ⚠️ Failed to convert DB result to event: {e}")
                        continue
                
                # Sort event_history by timestamp
                self.state.event_history.sort(key=lambda e: e.ts)
                
                _dbg(f"[FTB CONTROLLER] ✅ Loaded {loaded} race results from DB into event_history")
                self.log("ftb", f"Loaded {loaded} race results from database")
                
                # Mark stats as dirty to trigger UI refresh
                if loaded > 0:
                    self.state.mark_dirty('stats')
                    _dbg(f"[FTB CONTROLLER] 🔄 Marked stats as dirty for UI refresh")
                
                return loaded
                
        except Exception as e:
            _dbg(f"[FTB CONTROLLER] ❌ Failed to load from database: {e}")
            import traceback
            traceback.print_exc()
            self.log("ftb", f"Failed to load from database: {e}")
            return 0
    
    def save_game(self, path: Optional[str] = None) -> None:
        """Save current state to JSON in background thread (non-blocking)"""
        if not self.state:
            _dbg("[SAVE] ❌ Cannot save - no state loaded")
            return
        
        if path is None:
            path = self._get_autosave_path()
        
        _dbg(f"[SAVE] 💾 Initiating save to: {path}")
        
        # Start background save
        self.log("ftb", f"[AUTOSAVE] Starting background save to {path}")
        save_thread = threading.Thread(
            target=self._save_game_worker,
            args=(path,),
            daemon=True
        )
        save_thread.start()
    
    def _save_game_worker(self, path: str) -> None:
        """Background worker for saving game state"""
        try:
            # Acquire lock briefly to perform save
            with self.state_lock:
                self.state.save_to_json(path)
            self.log("ftb", f"[AUTOSAVE] Background save complete: {path}")
            _dbg(f"[SAVE] ✅ Save complete: {path}")
            self._sync_state_db_for_save(path)
            
            # Create success notification
            try:
                import plugins.ftb_notifications as ftb_notif
                import os
                filename = os.path.basename(path)
                ftb_notif.create_notification(
                    category='system',
                    title='💾 Save Complete',
                    message=f'Game saved to {filename}',
                    priority=40,
                    metadata={'path': path},
                    db_path=None  # Don't persist these to database
                )
            except Exception as notif_error:
                self.log("ftb", f"Failed to create save notification: {notif_error}")
                
        except Exception as e:
            import traceback
            error_details = traceback.format_exc()
            self.log("ftb", f"[AUTOSAVE] Background save failed: {e}\n{error_details}")
            _dbg(f"[SAVE] ❌ Save failed: {e}\n{error_details}")
            
            # Create error notification
            try:
                import plugins.ftb_notifications as ftb_notif
                ftb_notif.create_notification(
                    category='system',
                    title='⚠️ Save Failed',
                    message=f'Failed to save game: {str(e)}',
                    priority=90,
                    metadata={'error': str(e)},
                    db_path=None
                )
            except Exception as notif_error:
                self.log("ftb", f"Failed to create error notification: {notif_error}")
    
    def start(self) -> None:
        """Start tick loop thread"""
        if self.thread and self.thread.is_alive():
            return
        
        self.stop_event.clear()
        self.thread = threading.Thread(target=self._run, daemon=True)
        self.thread.start()
        self.log("ftb", "Controller started")
    
    def stop(self) -> None:
        """Stop tick loop thread"""
        self.stop_event.set()
        self.race_day_stop_event.set()
        if self.thread:
            self.thread.join(timeout=2.0)
        self.log("ftb", "Controller stopped")
        
        # Meta plugin shutdown is handled by bookmark.py runtime
    
    def _run(self) -> None:
        """Main tick loop"""
        self.log("ftb", "Controller thread started, entering main loop...")
        _dbg(f"[FTB CONTROLLER] 🚀 Main thread started, runtime_id={id(self.runtime)}")
        tick_count = 0
        
        while not self.stop_event.is_set():
            try:
                tick_count += 1
                if tick_count % 5 == 0:  # More frequent heartbeat for debugging
                    cmd_q = self.runtime.get("ftb_cmd_q")
                    q_size = cmd_q.qsize() if cmd_q else -1
                    state_info = f"tick={self.state.tick}, mode={self.state.time_mode}, control={self.state.control_mode}" if self.state else "None"
                    _dbg(f"[FTB CONTROLLER] 💓 Heartbeat #{tick_count}: q_size={q_size}, state={state_info}")
                    self.log("ftb", f"Thread heartbeat: tick={tick_count}, q_size={q_size}, state={'exists' if self.state else 'None'}")
                
                _dbg(f"[FTB CONTROLLER] 📬 Checking for UI commands...")
                # Handle UI commands
                self._handle_ui_cmds()
                
                # Check if we're in live race streaming mode
                if self.state and getattr(self.state, '_live_pbp_mode', False):
                    # Stream race events one at a time
                    if self._stream_live_race_event():
                        # Event was streamed, continue streaming
                        pass
                    else:
                        # Streaming complete, finalize race
                        _dbg(f"[FTB CONTROLLER] 🏁 Live race stream complete, finalizing...")
                        self._finalize_live_race()
                
                # Advance simulation (only if auto mode)
                should_tick = False
                _dbg(f"[FTB CONTROLLER] ⏰ Checking if should auto-tick: state={'exists' if self.state else 'None'}")
                
                # CRITICAL: Block ALL tick advances while race day is active (not IDLE)
                # The prompt pauses the sim; ticks must not happen until the player responds
                if self.state and ftb_race_day and hasattr(self.state, 'race_day_state') and self.state.race_day_state:
                    from plugins.ftb_race_day import RaceDayPhase
                    rd_phase = self.state.race_day_state.phase
                    if rd_phase != RaceDayPhase.IDLE:
                        _dbg(f"[FTB CONTROLLER] ⏸️  TICK BLOCKED - race day active (phase={rd_phase.value})")
                        
                        # SAFETY CHECK: Detect stuck races and auto-reset
                        # If race has been "running" but no actual race data exists, it's stuck
                        if rd_phase == RaceDayPhase.RACE_RUNNING:
                            # Check if race data actually exists
                            has_race_data = hasattr(self.state, '_live_race_result') and self.state._live_race_result is not None
                            is_pbp_active = self.runtime.get('PBP_ACTIVE', None)
                            
                            if not has_race_data and (is_pbp_active is None or not is_pbp_active):
                                _dbg(f"[FTB CONTROLLER] ⚠️  STUCK RACE DETECTED!")
                                _dbg(f"[FTB CONTROLLER] ⚠️  Race phase=RACE_RUNNING but no race data exists")
                                _dbg(f"[FTB CONTROLLER] ⚠️  Auto-resetting race_day_state to IDLE to unblock simulation")
                                
                                # Reset to IDLE
                                self.state.race_day_state.phase = RaceDayPhase.IDLE
                                self.state.race_day_state.race_tick = None
                                self.state.race_day_state.league_id = None
                                self.state.race_day_state.track_id = None
                                self.state.race_day_active = False
                                self.state.race_day_started_ts = None
                                
                                # Clear any stale race data
                                if hasattr(self.state, '_live_race_result'):
                                    self.state._live_race_result = None
                                if hasattr(self.state, '_live_pbp_mode'):
                                    self.state._live_pbp_mode = False
                                
                                _dbg(f"[FTB CONTROLLER] ✅ Race state reset complete - simulation unblocked")
                                
                                # Now allow tick to proceed
                                rd_phase = RaceDayPhase.IDLE
                        
                        # Don't tick if still not IDLE - wait for player to respond to race day prompt
                        if rd_phase != RaceDayPhase.IDLE:
                            should_tick = False
                        else:
                            # Now IDLE after reset, can continue to tick check
                            if self.state.time_mode == 'auto':
                                _dbg(f"[FTB CONTROLLER] ⏰ State is in auto mode, control_mode={self.state.control_mode}")
                                if self.state.control_mode == "delegated":
                                    # Delegated mode: only tick when time interval has passed
                                    if self.delegate_next_tick_ts is not None:
                                        now = time.time()
                                        if now >= self.delegate_next_tick_ts:
                                            should_tick = True
                                            self.delegate_next_tick_ts = now + self.delegate_tick_interval
                                            _dbg(f"[FTB CONTROLLER] [DELEGATE] Tick #{self.state.tick} - next tick in {self.delegate_tick_interval}s")
                                            self.log("ftb", f"[DELEGATE] Tick #{self.state.tick} - next tick in {self.delegate_tick_interval}s")
                                        else:
                                            wait_time = self.delegate_next_tick_ts - now
                                            _dbg(f"[FTB CONTROLLER] [DELEGATE] Waiting {wait_time:.1f}s for next tick")
                                else:
                                    # Normal auto mode: tick every loop iteration
                                    should_tick = True
                                    _dbg(f"[FTB CONTROLLER] Auto mode active, will tick")
                            else:
                                _dbg(f"[FTB CONTROLLER] State exists but not in auto mode: {self.state.time_mode}")
                    else:
                        # Phase is IDLE — safety-clear stale race_day_active flag
                        if self.state.race_day_active:
                            self.state.race_day_active = False
                            self.state.race_day_started_ts = None
                            _dbg(f"[FTB CONTROLLER] 🔧 Cleared stale race_day_active flag (phase already IDLE)")
                        if self.state.time_mode == 'auto':
                            _dbg(f"[FTB CONTROLLER] ⏰ State is in auto mode, control_mode={self.state.control_mode}")
                            if self.state.control_mode == "delegated":
                                # Delegated mode: only tick when time interval has passed
                                if self.delegate_next_tick_ts is not None:
                                    now = time.time()
                                    if now >= self.delegate_next_tick_ts:
                                        should_tick = True
                                        self.delegate_next_tick_ts = now + self.delegate_tick_interval
                                        _dbg(f"[FTB CONTROLLER] [DELEGATE] Tick #{self.state.tick} - next tick in {self.delegate_tick_interval}s")
                                        self.log("ftb", f"[DELEGATE] Tick #{self.state.tick} - next tick in {self.delegate_tick_interval}s")
                                    else:
                                        wait_time = self.delegate_next_tick_ts - now
                                        _dbg(f"[FTB CONTROLLER] [DELEGATE] Waiting {wait_time:.1f}s for next tick")
                            else:
                                # Normal auto mode: tick every loop iteration
                                should_tick = True
                                _dbg(f"[FTB CONTROLLER] Auto mode active, will tick")
                        else:
                            _dbg(f"[FTB CONTROLLER] State exists but not in auto mode: {self.state.time_mode}")
                elif self.state and self.state.time_mode == 'auto':
                    _dbg(f"[FTB CONTROLLER] ⏰ State is in auto mode, control_mode={self.state.control_mode}")
                    if self.state.control_mode == "delegated":
                        if self.delegate_next_tick_ts is not None:
                            now = time.time()
                            if now >= self.delegate_next_tick_ts:
                                should_tick = True
                                self.delegate_next_tick_ts = now + self.delegate_tick_interval
                            else:
                                wait_time = self.delegate_next_tick_ts - now
                                _dbg(f"[FTB CONTROLLER] [DELEGATE] Waiting {wait_time:.1f}s for next tick")
                    else:
                        should_tick = True
                        _dbg(f"[FTB CONTROLLER] Auto mode active, will tick")
                elif self.state:
                    _dbg(f"[FTB CONTROLLER] State exists but not in auto mode: {self.state.time_mode}")
                else:
                    _dbg(f"[FTB CONTROLLER] No state available for auto-tick")

                if self.state and should_tick:
                    _dbg(f"[FTB CONTROLLER] Performing simulation tick: current_tick={self.state.tick}")
                    with self.state_lock:
                        _dbg(f"[FTB CONTROLLER] State lock acquired, calling tick_simulation")
                        events = FTBSimulation.tick_simulation(self.state)
                        _dbg(f"[FTB CONTROLLER] tick_simulation returned {len(events)} events")
                    
                    _dbg(f"[FTB CONTROLLER] Converting and emitting {len(events)} events")
                    # Convert and emit events
                    self._emit_events(events)
                    
                    # Check for special UI action events
                    for event in events:
                        if event.event_type == "ui_action" and event.category == "show_pre_race_prompt":
                            # Show pre-race prompt dialog
                            _dbg(f"[FTB RACE DAY] 📢 Detected show_pre_race_prompt event (auto-tick)")
                            ftb_ui_q = self.runtime.get("ftb_ui_q")
                            if ftb_ui_q:
                                ftb_ui_q.put(("show_pre_race_prompt", {
                                    "league_name": event.data.get("league_name"),
                                    "track_name": event.data.get("track_name"),
                                    "tier": event.data.get("tier"),
                                    "league_id": event.data.get("league_id"),
                                    "track_id": event.data.get("track_id")
                                }))
                                _dbg(f"[FTB RACE DAY] ✅ Sent show_pre_race_prompt to ftb_ui_q")
                            else:
                                _dbg(f"[FTB RACE DAY] ❌ ftb_ui_q not found in runtime!")
                        
                        elif event.event_type == "ui_action" and event.category == "quali_complete":
                            # Notify player that quali is complete
                            _dbg(f"[FTB RACE DAY] 🏁 Detected quali_complete event (auto-tick)")
                            ftb_ui_q = self.runtime.get("ftb_ui_q")
                            if ftb_ui_q:
                                ftb_ui_q.put(("quali_complete", {
                                    "message": event.data.get("message"),
                                    "pole_driver": event.data.get("pole_driver"),
                                    "pole_team": event.data.get("pole_team")
                                }))
                                _dbg(f"[FTB RACE DAY] ✅ Sent quali_complete to ftb_ui_q")
                    
                    # Write state snapshot to DB for narrator/delegate
                    if self.state_db_path and ftb_state_db:
                        try:
                            ftb_state_db.write_game_snapshot(self.state_db_path, self.state)
                            ftb_state_db.write_free_agents(self.state_db_path, self.state.free_agents)
                            ftb_state_db.write_event_batch(self.state_db_path, events)
                            
                            # Write calendar projection (every 10 ticks to avoid overhead)
                            if self.state.tick % 10 == 0:
                                projection = self.state.get_calendar_projection(days_ahead=60)
                                _dbg(f"[FTB] CALENDAR_WRITE: Writing {len(projection)} calendar entries at tick {self.state.tick}")
                                if projection:
                                    sample = projection[0] if projection else None
                                    _dbg(f"[FTB] CALENDAR_SAMPLE: {sample}")
                                ftb_state_db.write_calendar_projection(self.state_db_path, projection)
                        except Exception as e:
                            self.log('ftb', f'State DB write error: {e}')
                    
                    # Autosave check (every N ticks) - only after auto-tick
                    if self.state.tick % self.autosave_interval == 0:
                        self.save_game()
                        self.log("ftb", f"[AUTOSAVE] Auto-save triggered at tick {self.state.tick}")
                
                # Refresh widget (always, if state exists)
                if self.state:
                    self._refresh_widget()
                
            except Exception as e:
                import traceback
                self.log("ftb", f"Tick error: {e}")
                self.log("ftb", traceback.format_exc())
            
            time.sleep(self.tick_rate)
    
    def _handle_ui_cmds(self) -> None:
        """Process commands from ftb_cmd_q"""
        ftb_cmd_q = self.runtime.get("ftb_cmd_q")
        if not ftb_cmd_q:
            _dbg(f"[FTB CONTROLLER] ✗ _handle_ui_cmds: no ftb_cmd_q found in runtime dict id={id(self.runtime)}")
            return
        
        if ftb_cmd_q.empty():
            return  # Nothing to process
        
        _dbg(f"[FTB CONTROLLER] ✓ _handle_ui_cmds: queue id={id(ftb_cmd_q)} has {ftb_cmd_q.qsize()} items, runtime dict id={id(self.runtime)}")
        
        while not ftb_cmd_q.empty():
            try:
                msg = ftb_cmd_q.get_nowait()
                cmd = msg.get("cmd", "")
                _dbg(f"[FTB] Processing command: {cmd}, full_msg={msg}")
                self.log("ftb", f"Processing command: {cmd}")
                
                if cmd == "ftb_new_save":
                    _dbg("[FTB] Handling ftb_new_save command")
                    origin = msg.get("origin")
                    identity = msg.get("identity")
                    save_mode = msg.get("save_mode")
                    tier = msg.get("tier", "grassroots")
                    seed = msg.get("seed")
                    team_name = msg.get("team_name")
                    ownership = msg.get("ownership", "hired_manager")
                    manager_age = msg.get("manager_age", 32)
                    manager_first_name = msg.get("manager_first_name", "")
                    manager_last_name = msg.get("manager_last_name", "")
                    _dbg(f"[FTB] Calling start_new_game with: origin={origin}, identity={identity}, save_mode={save_mode}, tier={tier}, seed={seed}, team_name={team_name}, ownership={ownership}, manager_age={manager_age}, manager_name={manager_first_name} {manager_last_name}")
                    self.start_new_game(origin, identity, save_mode, tier, seed, team_name, ownership, manager_age, manager_first_name, manager_last_name)
                    _dbg(f"[FTB] ✓ start_new_game returned, state exists: {self.state is not None}")
                    if self.state:
                        _dbg(f"[FTB] ✓ State initialized: tick={self.state.tick}, team={self.state.player_team.name if self.state.player_team else 'None'}")
                        # Trigger immediate UI refresh
                        self._refresh_widget()
                        _dbg(f"[FTB] ✓ Triggered UI refresh after new game creation")
                    else:
                        _dbg("[FTB] ✗ WARNING: state is None after start_new_game!")
                
                elif cmd == "ftb_load_save":
                    path = msg.get("path")
                    _dbg(f"[FTB CONTROLLER] 💾 Loading save from: {path}")
                    if path:
                        self.load_save(path)
                        _dbg(f"[FTB CONTROLLER] ✅ load_save completed, state exists: {self.state is not None}")
                        if self.state:
                            _dbg(f"[FTB CONTROLLER] ✅ Loaded state: tick={self.state.tick}, team={self.state.player_team.name if self.state.player_team else 'None'}, leagues={len(self.state.leagues)}")
                            # Clear racing stats cache to force refresh with new data
                            _dbg(f"[FTB CONTROLLER] 🔄 Clearing racing stats cache...")
                            # Trigger immediate UI refresh
                            self._refresh_widget(clear_stats_cache=True)
                            _dbg(f"[FTB CONTROLLER] ✓ Triggered UI refresh after save loaded")
                    else:
                        _dbg(f"[FTB CONTROLLER] ❌ No path provided for load_save")
                
                elif cmd == "ftb_load_from_db":
                    clear_existing = msg.get("clear_existing", False)
                    _dbg(f"[FTB CONTROLLER] 🗄️ Loading race results from database (clear_existing={clear_existing})")
                    count = self.load_from_db(clear_existing=clear_existing)
                    _dbg(f"[FTB CONTROLLER] ✅ Loaded {count} race results from DB")
                    if count > 0 and self.state:
                        # Trigger immediate UI refresh with cache clear
                        self._refresh_widget(clear_stats_cache=True)
                        _dbg(f"[FTB CONTROLLER] ✓ Triggered UI refresh after DB load")
                
                elif cmd == "ftb_save":
                    path = msg.get("path")
                    _dbg(f"[FTB CONTROLLER] 💾 Save command received, path: {path}")
                    if path:
                        self.save_game(path)
                    else:
                        _dbg("[FTB CONTROLLER] ❌ No path provided for save command")
                
                elif cmd == "ftb_tick_step":
                    n = int(msg.get("n", 1))
                    _dbg(f"[FTB CONTROLLER] ⏩ Manual tick step requested: {n} ticks")
                    if self.state:
                        # If race day is active, SKIP-COMPLETE it so the tick can proceed
                        if ftb_race_day and hasattr(self.state, 'race_day_state') and self.state.race_day_state:
                            from plugins.ftb_race_day import RaceDayPhase
                            rd_phase = self.state.race_day_state.phase
                            if rd_phase not in (RaceDayPhase.IDLE, None):
                                _dbg(f"[FTB CONTROLLER] ⏩ SKIP-COMPLETING race day (phase={rd_phase.value}) to allow tick advance")
                                # Force-complete: inject ftb_complete_race_day then re-queue this tick step
                                ftb_cmd_q.put({"cmd": "ftb_complete_race_day"})
                                ftb_cmd_q.put({"cmd": "ftb_tick_step", "n": n})
                                continue
                            # Safety-clear stale race_day_active if phase is IDLE
                            if self.state.race_day_active:
                                self.state.race_day_active = False
                                self.state.race_day_started_ts = None
                                _dbg(f"[FTB CONTROLLER] 🔧 Cleared stale race_day_active flag on manual tick (phase IDLE)")
                        
                        _dbg(f"[FTB CONTROLLER] ⏩ Starting tick step from tick {self.state.tick}")
                        
                        # PRE-TICK CHECK: Is there a player race about to happen?
                        if n == 1 and self.state.control_mode != "delegated":  # Only for single manual ticks, not batch
                            race_info = self._check_for_upcoming_player_race(self.state.tick)
                            if race_info:
                                # Show dialog and get response
                                league_name, track_name, round_num = race_info
                                self._show_watch_race_dialog({
                                    'league_name': league_name,
                                    'track_name': track_name,
                                    'round_number': round_num
                                })
                                # Dialog is blocking, so state._watch_current_race_live is now set
                                _dbg(f"[FTB CONTROLLER] 🏁 Dialog shown, user chose: {'WATCH' if getattr(self.state, '_watch_current_race_live', False) else 'SKIP'}")
                        
                        # ACTUAL TICK EXECUTION
                        # Note: Race day logic removed - races now happen naturally when you tick into them
                        # This makes the simulation flow clearer: tick = time advances, period.
                        _dbg(f"[FTB CONTROLLER] 🎯 Executing tick simulation...")
                        if n > 1:
                            # Multi-day advances, batch all events to avoid LLM spam
                            _dbg(f"[FTB CONTROLLER] 📦 Multi-tick batch: {n} ticks")
                            all_events = []
                            start_tick = self.state.tick
                            
                            for i in range(n):
                                # Check stop flag on each iteration
                                if self.stop_tick_flag:
                                    self.log('ftb', f'⛔ Tick step STOPPED by user at {i+1}/{n} ticks')
                                    _dbg(f"[FTB CONTROLLER] ⛔ Tick step STOPPED by user at {i+1}/{n} ticks")
                                    self.stop_tick_flag = False  # Reset flag
                                    break
                                
                                _dbg(f"[FTB CONTROLLER] 🎯 Batch tick {i+1}/{n}: advancing from {self.state.tick}")
                                with self.state_lock:
                                    events = FTBSimulation.tick_simulation(self.state)
                                    all_events.extend(events)
                                    
                                    # In multi-tick mode, if tick_simulation paused for a pre-race prompt,
                                    # auto-clear it so the next iteration advances normally
                                    if (ftb_race_day and self.state.race_day_state and 
                                        self.state.race_day_state.phase == ftb_race_day.RaceDayPhase.PRE_RACE_PROMPT):
                                        self.state.race_day_state.phase = ftb_race_day.RaceDayPhase.IDLE
                                        self.state.race_day_state.player_wants_live_race = False
                                _dbg(f"[FTB CONTROLLER] 🎯 Batch tick {i+1} complete: now at tick {self.state.tick}, generated {len(events)} events")
                                
                                # Write state snapshot to DB
                                if self.state_db_path and ftb_state_db:
                                    try:
                                        ftb_state_db.write_game_snapshot(self.state_db_path, self.state)
                                        ftb_state_db.write_free_agents(self.state_db_path, self.state.free_agents)
                                        ftb_state_db.write_event_batch(self.state_db_path, events)
                                        
                                        # Write calendar projection (every 10 ticks)
                                        if self.state.tick % 10 == 0:
                                            projection = self.state.get_calendar_projection(days_ahead=60)
                                            _dbg(f"[FTB] CALENDAR_WRITE: Writing {len(projection)} calendar entries at tick {self.state.tick}")
                                            if projection:
                                                sample = projection[0] if projection else None
                                                _dbg(f"[FTB] CALENDAR_SAMPLE: {sample}")
                                            ftb_state_db.write_calendar_projection(self.state_db_path, projection)
                                    except Exception as e:
                                        self.log('ftb', f'State DB write error: {e}')
                            
                            # Emit all events as a single batch for narrator
                            end_tick = self.state.tick
                            _dbg(f"[FTB CONTROLLER] 📡 Emitting {len(all_events)} batched events for ticks {start_tick}-{end_tick}")
                            self._emit_events(all_events, batch_mode=True, tick_range=(start_tick, end_tick))
                            self.log('ftb', f'Batch advance complete: {n} ticks, {len(all_events)} events')
                            
                            # Autosave check after multi-tick (only if final tick lands on interval)
                            if self.state.tick % self.autosave_interval == 0:
                                self.save_game()  # Defaults to autosave path
                                self.log('ftb', f'[AUTOSAVE] Auto-save triggered at tick {self.state.tick}')
                            
                            # Trigger UI refresh after multi-tick batch
                            _dbg(f"[FTB CONTROLLER] 🔄 Triggering widget refresh after multi-tick batch...")
                            self._refresh_widget()
                        else:
                            # Single tick - emit immediately
                            _dbg(f"[FTB CONTROLLER] 🎯 Single tick execution from {self.state.tick}")
                            with self.state_lock:
                                events = FTBSimulation.tick_simulation(self.state)
                            _dbg(f"[FTB CONTROLLER] 🎯 Single tick complete: now at tick {self.state.tick}, generated {len(events)} events")
                            self._emit_events(events)
                            
                            # Check for special UI action events (race day prompts, etc.)
                            for event in events:
                                if event.event_type == "ui_action" and event.category == "show_pre_race_prompt":
                                    _dbg(f"[FTB RACE DAY] 📢 Detected show_pre_race_prompt event (manual tick path)")
                                    ftb_ui_q = self.runtime.get("ftb_ui_q")
                                    if ftb_ui_q:
                                        ftb_ui_q.put(("show_pre_race_prompt", {
                                            "league_name": event.data.get("league_name"),
                                            "track_name": event.data.get("track_name"),
                                            "tier": event.data.get("tier"),
                                            "league_id": event.data.get("league_id"),
                                            "track_id": event.data.get("track_id")
                                        }))
                                        _dbg(f"[FTB RACE DAY] ✅ Sent show_pre_race_prompt to ftb_ui_q (manual tick)")
                                    else:
                                        _dbg(f"[FTB RACE DAY] ❌ ftb_ui_q not found in runtime!")
                                elif event.event_type == "ui_action" and event.category == "quali_complete":
                                    _dbg(f"[FTB RACE DAY] 🏁 Detected quali_complete event (manual tick path)")
                                    ftb_ui_q = self.runtime.get("ftb_ui_q")
                                    if ftb_ui_q:
                                        ftb_ui_q.put(("quali_complete", {
                                            "message": event.data.get("message"),
                                            "pole_driver": event.data.get("pole_driver"),
                                            "pole_team": event.data.get("pole_team")
                                        }))
                                        _dbg(f"[FTB RACE DAY] ✅ Sent quali_complete to ftb_ui_q (manual tick)")
                            
                            # Write state snapshot to DB
                            if self.state_db_path and ftb_state_db:
                                try:
                                    ftb_state_db.write_game_snapshot(self.state_db_path, self.state)
                                    ftb_state_db.write_free_agents(self.state_db_path, self.state.free_agents)
                                    ftb_state_db.write_event_batch(self.state_db_path, events)
                                    
                                    # Write calendar projection (every 10 ticks)
                                    if self.state.tick % 10 == 0:
                                        projection = self.state.get_calendar_projection(days_ahead=60)
                                        _dbg(f"[FTB] CALENDAR_WRITE: Writing {len(projection)} calendar entries at tick {self.state.tick}")
                                        if projection:
                                            sample = projection[0] if projection else None
                                            _dbg(f"[FTB] CALENDAR_SAMPLE: {sample}")
                                        ftb_state_db.write_calendar_projection(self.state_db_path, projection)
                                except Exception as e:
                                    self.log('ftb', f'State DB write error: {e}')
                            
                            # Autosave check after single tick
                            if self.state.tick % self.autosave_interval == 0:
                                self.save_game()  # Defaults to autosave path
                                self.log('ftb', f'[AUTOSAVE] Auto-save triggered at tick {self.state.tick}')
                        
                        # Trigger UI refresh after tick completion
                        _dbg(f"[FTB CONTROLLER] 🔄 Triggering widget refresh after tick...")
                        self._refresh_widget()
                        _dbg(f"[FTB CONTROLLER] ✅ Tick step completed successfully!")
                    else:
                        _dbg(f"[FTB CONTROLLER] ❌ Cannot tick - no state available")
                
                elif cmd == "ftb_stop_tick":
                    # Stop any in-progress batch tick operations
                    self.stop_tick_flag = True
                    self.log("ftb", "🛑 Stop tick requested - will halt batch operations")
                    _dbg("[FTB CONTROLLER] 🛑 Stop tick flag set")
                
                elif cmd == "ftb_tick_batch":
                    n = int(msg.get("n", 7))
                    if self.state:
                        # BLOCK batch if race day is active (not IDLE)
                        if ftb_race_day and hasattr(self.state, 'race_day_state') and self.state.race_day_state:
                            from plugins.ftb_race_day import RaceDayPhase
                            rd_phase = self.state.race_day_state.phase
                            if rd_phase not in (RaceDayPhase.IDLE, None):
                                _dbg(f"[FTB CONTROLLER] ⏸️  BATCH TICK BLOCKED - race day active (phase={rd_phase.value})")
                                continue
                        
                        # Execute batch and collect summary
                        start_tick = self.state.tick
                        start_cash = self.state.player_team.budget.cash if self.state.player_team else 0
                        all_events = []
                        
                        # Collect all events without emitting (prevents narrator spam)
                        for i in range(n):
                            # Check stop flag on each iteration
                            if self.stop_tick_flag:
                                self.log('ftb', f'⛔ Batch tick STOPPED by user at {i+1}/{n} ticks')
                                _dbg(f"[FTB CONTROLLER] ⛔ Batch tick STOPPED by user at {i+1}/{n} ticks")
                                self.stop_tick_flag = False  # Reset flag
                                break
                            
                            with self.state_lock:
                                events = FTBSimulation.tick_simulation(self.state)
                                all_events.extend(events)
                                
                                # In batch mode, if tick_simulation paused for a pre-race prompt,
                                # auto-clear it so the next iteration advances normally (no interactive prompt in batch)
                                if (ftb_race_day and self.state.race_day_state and 
                                    self.state.race_day_state.phase == ftb_race_day.RaceDayPhase.PRE_RACE_PROMPT):
                                    self.state.race_day_state.phase = ftb_race_day.RaceDayPhase.IDLE
                                    self.state.race_day_state.player_wants_live_race = False
                            
                            # Write state snapshot to DB
                            if self.state_db_path and ftb_state_db:
                                try:
                                    ftb_state_db.write_game_snapshot(self.state_db_path, self.state)
                                    ftb_state_db.write_event_batch(self.state_db_path, events)
                                except Exception as e:
                                    self.log('ftb', f'State DB write error: {e}')
                        
                        # Emit all events ONCE with batch_mode flag (triggers narrator aggregation)
                        if all_events:
                            self._emit_events(all_events, batch_mode=True, tick_range=(start_tick, self.state.tick))
                        
                        # Generate summary event
                        with self.state_lock:
                            end_cash = self.state.player_team.budget.cash if self.state.player_team else 0
                            races = sum(1 for e in all_events if e.category == "race_result")
                            major_events = sum(1 for e in all_events if e.priority > 70)
                            
                            summary = SimEvent(
                                event_type="time",
                                category="time_batch_summary",
                                ts=self.state.tick,
                                priority=80.0,
                                severity="info",
                                event_id=FTBSimulation._generate_event_id(self.state),
                                data={
                                    'start_tick': start_tick,
                                    'end_tick': self.state.tick,
                                    'ticks': n,
                                    'net_cash_delta': end_cash - start_cash,
                                    'races_completed': races,
                                    'major_events_count': major_events,
                                    'start_cash': start_cash,
                                    'end_cash': end_cash
                                }
                            )
                            self.state.event_history.append(summary)
                            self._emit_events([summary])
                            
                            # Show popup via ui_q
                            ui_q = self.runtime.get("ui_q")
                            if ui_q:
                                ui_q.put(("batch_summary", {
                                    "data": summary.data
                                }))
                        
                        # Autosave check after batch
                        if self.state.tick % self.autosave_interval == 0:
                            self.save_game()  # Defaults to autosave path
                        block = self._find_next_player_race_within(self.state.tick + 1, self.state.tick + n)
                        if block:
                            race_tick, league, track_id = block
                            self._arm_race_day(race_tick, league, track_id)
                            self.log('ftb', f'Race day armed for tick {race_tick} - optional')

                elif cmd == "ftb_start_race_day":
                    if self.state and self.state.pending_race_day:
                        self._start_race_day_mode()
                
                elif cmd == "ftb_watch_race_live":
                    # User responded to "watch race live?" prompt
                    watch_live = msg.get("watch_live", False)
                    if self.state:
                        with self.state_lock:
                            self.state.watch_race_live_response = watch_live
                        self.log("ftb", f"User chose to {'WATCH' if watch_live else 'SKIP'} live race viewing")
                        # Trigger immediate tick to continue race execution
                        _dbg(f"[FTB] ▶️  Resuming tick after user response")
                
                elif cmd == "ftb_pre_race_response":
                    # NEW: Handle pre-race prompt response (watch live vs instant sim)
                    watch_live = msg.get("watch_live", False)
                    if self.state and ftb_race_day and self.state.race_day_state:
                        from plugins.ftb_race_day import RaceDayPhase, simulate_qualifying
                        
                        _dbg(f"[FTB RACE DAY] 📋 Pre-race response: watch_live={watch_live}")
                        
                        if watch_live:
                            # Player wants to watch live - simulate qualifying
                            _dbg(f"[FTB RACE DAY] ✅ Player chose LIVE RACE mode")
                            
                            # Get race info (no lock needed - controller thread is single-threaded)
                            league_id = self.state.race_day_state.league_id
                            track_id = self.state.race_day_state.track_id
                            
                            # Fallback: if league_id is missing (e.g. after reload), resolve from player team
                            if not league_id and self.state.player_team:
                                for lg in self.state.leagues.values():
                                    if self.state.player_team in lg.teams:
                                        league_id = lg.league_id
                                        # Also try to resolve track_id from schedule if missing
                                        if not track_id:
                                            next_tick = self.state.tick
                                            for entry in (lg.schedule or []):
                                                if isinstance(entry, (tuple, list)) and len(entry) == 2:
                                                    rt, tid = entry
                                                else:
                                                    rt, tid = entry, None
                                                if rt >= next_tick:
                                                    track_id = tid
                                                    break
                                        # Update race_day_state so downstream code has the ids
                                        self.state.race_day_state.league_id = league_id
                                        if track_id:
                                            self.state.race_day_state.track_id = track_id
                                        _dbg(f"[FTB RACE DAY] 🔄 Resolved league_id={league_id}, track_id={track_id} from player team fallback")
                                        break
                            
                            _dbg(f"[FTB RACE DAY] 🔍 Looking up league_id={league_id}, track_id={track_id}")
                            
                            league = self.state.leagues.get(league_id) if league_id else None
                            track = self.state.tracks.get(track_id) if track_id else None
                            
                            _dbg(f"[FTB RACE DAY] 🔍 League found: {league.name if league else 'NONE'}, Track found: {track.name if track else 'NONE'}")
                            
                            if league:
                                # Simulate qualifying
                                try:
                                    rng = random.Random(self.state.seed + self.state.tick)
                                    _dbg(f"[FTB RACE DAY] 🏎️ Running simulate_qualifying...")
                                    quali_grid, quali_events = simulate_qualifying(self.state, league, track, rng)
                                    
                                    # Store quali results
                                    self.state.race_day_state.quali_grid = quali_grid
                                    self.state.race_day_state.quali_events = quali_events
                                    self.state.race_day_state.phase = RaceDayPhase.QUALI_COMPLETE
                                    self.state.race_day_state.player_wants_live_race = True
                                    
                                    _dbg(f"[FTB RACE DAY] 🏁 Qualifying complete: {len(quali_grid)} drivers, {len(quali_events)} events")
                                    
                                    # Write quali events to state DB for event log
                                    if self.state_db_path and ftb_state_db:
                                        try:
                                            ftb_state_db.write_event_batch(self.state_db_path, quali_events)
                                            _dbg(f"[FTB RACE DAY] 📝 Wrote {len(quali_events)} quali events to DB")
                                        except Exception as e:
                                            _dbg(f"[FTB RACE DAY] ⚠️  Failed to write quali events: {e}")
                                    
                                    # Emit events to event history
                                    for event in quali_events:
                                        self.state.event_history.append(event)
                                    
                                    # Emit notification
                                    self._emit_events(quali_events)
                                    
                                    # Show notification that player can go to PBP tab
                                    quali_complete_event = SimEvent(
                                        event_type="ui_action",
                                        category="quali_complete",
                                        ts=self.state.tick,
                                        priority=90.0,
                                        severity="info",
                                        data={
                                            '_ftb': True,
                                            'message': 'Qualifying complete! Go to Play-by-Play tab to start the race.',
                                            'pole_driver': quali_grid[0][1].name if quali_grid else "Unknown",
                                            'pole_team': quali_grid[0][0].name if quali_grid else "Unknown"
                                        }
                                    )
                                    self._emit_events([quali_complete_event])
                                    
                                    # Send quali_complete to ftb_ui_q so widget shows notification
                                    ftb_ui_q = self.runtime.get("ftb_ui_q")
                                    if ftb_ui_q:
                                        ftb_ui_q.put(("quali_complete", {
                                            "message": quali_complete_event.data.get("message"),
                                            "pole_driver": quali_complete_event.data.get("pole_driver"),
                                            "pole_team": quali_complete_event.data.get("pole_team")
                                        }))
                                        _dbg(f"[FTB RACE DAY] ✅ Sent quali_complete to ftb_ui_q")
                                    
                                    _dbg(f"[FTB RACE DAY] ⏸️  Waiting for player to click 'Play Live Race' in PBP tab")
                                except Exception as e:
                                    import traceback
                                    _dbg(f"[FTB RACE DAY] ❌ ERROR during qualifying: {e}")
                                    traceback.print_exc()
                                    # Reset to IDLE so player isn't stuck
                                    self.state.race_day_state.phase = RaceDayPhase.IDLE
                                    self.state.race_day_state.player_wants_live_race = False
                                    _dbg(f"[FTB RACE DAY] 🔄 Reset to IDLE after qualifying error")
                            else:
                                _dbg(f"[FTB RACE DAY] ❌ League not found: league_id={league_id}, available leagues: {list(self.state.leagues.keys())}")
                                # Reset to IDLE so player isn't stuck
                                self.state.race_day_state.phase = RaceDayPhase.IDLE
                                self.state.race_day_state.player_wants_live_race = False
                        else:
                            # Player chose instant sim - continue with normal tick
                            _dbg(f"[FTB RACE DAY] ⏩ Player chose INSTANT SIM mode")
                            
                            # Clear race day state
                            self.state.race_day_state.phase = RaceDayPhase.IDLE
                            self.state.race_day_state.player_wants_live_race = False
                            
                            # CRITICAL: Trigger tick to continue (it was paused for the prompt)
                            _dbg(f"[FTB RACE DAY] ▶️  Triggering tick advance to continue to race")
                            ftb_cmd_q = self.runtime.get("ftb_cmd_q")
                            if ftb_cmd_q:
                                ftb_cmd_q.put({"cmd": "ftb_tick_step", "n": 1})
                                _dbg(f"[FTB RACE DAY] ✅ Sent tick_step command")
                            else:
                                _dbg(f"[FTB RACE DAY] ⚠️  ftb_cmd_q not found in runtime")
                
                elif cmd == "ftb_start_live_race":
                    # NEW: Start live race playback from PBP widget
                    if self.state and ftb_race_day and self.state.race_day_state:
                        from plugins.ftb_race_day import RaceDayPhase
                        
                        speed = msg.get("speed", 10.0)  # Seconds per lap
                        
                        _dbg(f"[FTB RACE DAY] ▶️  Starting live race playback (speed={speed}s/lap)")
                        
                        # --- Set global PBP_ACTIVE flag (blocks narrator in TTS/host pipeline) ---
                        try:
                            _pbp_flag = self.runtime.get('PBP_ACTIVE')
                            if _pbp_flag:
                                _pbp_flag.set()
                                _dbg("[FTB RACE DAY] 🔇 PBP_ACTIVE flag SET – narrator blocked in TTS/host pipeline")
                        except Exception as _e:
                            _dbg(f"[FTB RACE DAY] ⚠️  Could not set PBP_ACTIVE flag: {_e}")
                        
                        # --- Suspend narrator during PBP ---
                        try:
                            # active_meta_plugin is a @property that does a fresh
                            # runtime lookup, so it's always up-to-date.
                            meta = self.active_meta_plugin
                            if meta and hasattr(meta, 'narrator') and meta.narrator:
                                meta.narrator.suspended = True
                                _dbg("[FTB RACE DAY] 🔇 Narrator SUSPENDED for PBP mode")
                                # Also flush any queued narrator segments from the audio DB
                                # so already-enqueued narration doesn't play over PBP
                                try:
                                    _db_conn_fn = self.runtime.get('db_connect')
                                    if _db_conn_fn:
                                        _conn = _db_conn_fn()
                                        _flushed = _conn.execute(
                                            "UPDATE segments SET status='done' "
                                            "WHERE status='queued' AND source='narrator'"
                                        ).rowcount
                                        _conn.commit()
                                        _conn.close()
                                        if _flushed:
                                            _dbg(f"[FTB RACE DAY] 🧹 Flushed {_flushed} queued narrator segments from DB")
                                except Exception as _dbe:
                                    _dbg(f"[FTB RACE DAY] ⚠️  Could not flush narrator DB segments: {_dbe}")
                            else:
                                _dbg("[FTB RACE DAY] ⚠️  No narrator found to suspend (meta_plugin or narrator is None)")
                        except Exception as _e:
                            _dbg(f"[FTB RACE DAY] ⚠️  Could not suspend narrator: {_e}")
                        
                        # --- INTERRUPT any currently-playing TTS immediately ---
                        # SHOW_INTERRUPT causes speak() to bail out mid-sentence
                        try:
                            _show_interrupt = self.runtime.get('SHOW_INTERRUPT')
                            if _show_interrupt:
                                _show_interrupt.set()
                                _dbg("[FTB RACE DAY] 🔇 SHOW_INTERRUPT set – cutting current TTS")
                                # Brief pause to let the speak() call exit
                                import time as _time
                                _time.sleep(0.3)
                                _show_interrupt.clear()
                                _dbg("[FTB RACE DAY] 🔇 SHOW_INTERRUPT cleared – ready for PBP")
                        except Exception as _e:
                            _dbg(f"[FTB RACE DAY] ⚠️  Could not set SHOW_INTERRUPT: {_e}")
                        
                        # --- Drain the pre-rendered audio queue ---
                        # Segments already converted to audio sit in audio_queue;
                        # drain them so they don't play after the interrupt clears
                        try:
                            _audio_q = self.runtime.get('audio_queue')
                            if _audio_q:
                                _drained = 0
                                while not _audio_q.empty():
                                    try:
                                        _audio_q.get_nowait()
                                        _drained += 1
                                    except Exception:
                                        break
                                if _drained:
                                    _dbg(f"[FTB RACE DAY] 🧹 Drained {_drained} pre-rendered audio items from queue")
                        except Exception as _e:
                            _dbg(f"[FTB RACE DAY] ⚠️  Could not drain audio_queue: {_e}")
                        
                        # --- Flush ALL queued audio segments (not just narrator) ---
                        # This ensures theme music / any queued audio stops deterministically
                        try:
                            _db_conn_fn = self.runtime.get('db_connect')
                            if _db_conn_fn:
                                _conn = _db_conn_fn()
                                _flushed_all = _conn.execute(
                                    "UPDATE segments SET status='done' "
                                    "WHERE status='queued'"
                                ).rowcount
                                _conn.commit()
                                _conn.close()
                                if _flushed_all:
                                    _dbg(f"[FTB RACE DAY] 🧹 Flushed {_flushed_all} total queued audio segments for clean PBP start")
                        except Exception as _dbe:
                            _dbg(f"[FTB RACE DAY] ⚠️  Could not flush audio DB segments: {_dbe}")
                        
                        # --- Tell audio engine: fade music to 0 ---
                        # Try direct module reference first, then sys.modules fallback
                        _pbp_mode_set = False
                        try:
                            import sys as _sys
                            _ae_mod = _sys.modules.get('ftb_audio_engine')
                            if _ae_mod and hasattr(_ae_mod, 'set_pbp_mode'):
                                _ae_mod.set_pbp_mode(True)
                                _pbp_mode_set = True
                                _dbg("[FTB RACE DAY] 🔇 Called set_pbp_mode(True) – music fading out")
                            elif _ae_mod and hasattr(_ae_mod, '_audio_engine') and _ae_mod._audio_engine:
                                _ae_mod._audio_engine.music_controller.set_pbp_mute(True)
                                _pbp_mode_set = True
                                _dbg("[FTB RACE DAY] 🔇 Direct set_pbp_mute(True) on audio engine – music fading out")
                        except Exception as _e:
                            _dbg(f"[FTB RACE DAY] ⚠️  set_pbp_mode via sys.modules failed: {_e}")
                        
                        # Fallback: try importing directly
                        if not _pbp_mode_set:
                            try:
                                from plugins import ftb_audio_engine as _ae_direct
                                if hasattr(_ae_direct, 'set_pbp_mode'):
                                    _ae_direct.set_pbp_mode(True)
                                    _pbp_mode_set = True
                                    _dbg("[FTB RACE DAY] 🔇 Direct import set_pbp_mode(True) – music fading out")
                            except Exception as _e2:
                                _dbg(f"[FTB RACE DAY] ⚠️  Direct import fallback also failed: {_e2}")
                        
                        # Last resort: send audio event via event_q
                        if not _pbp_mode_set:
                            try:
                                _event_q = self.runtime.get('event_q')
                                if _event_q:
                                    from bookmark import StationEvent
                                    _event_q.put(StationEvent(
                                        type='audio',
                                        source='ftb',
                                        payload={'audio_type': 'pbp_mode', 'active': True}
                                    ))
                                    _dbg("[FTB RACE DAY] 🔇 Sent pbp_mode event via event_q as last resort")
                            except Exception as _e3:
                                _dbg(f"[FTB RACE DAY] ⚠️  All audio fade methods failed: {_e3}")
                        
                        # --- Stop any currently-playing pygame music immediately ---
                        try:
                            import pygame
                            if pygame.mixer.get_init():
                                pygame.mixer.music.fadeout(2000)  # 2-second fadeout
                                _dbg("[FTB RACE DAY] 🔇 pygame.mixer.music.fadeout(2000) called directly")
                        except Exception:
                            pass
                        
                        with self.state_lock:
                            if self.state.race_day_state.phase == RaceDayPhase.QUALI_COMPLETE:
                                rds = self.state.race_day_state
                                
                                # Find player's league and track
                                player_league = None
                                for league in self.state.leagues.values():
                                    if self.state.player_team in league.teams:
                                        player_league = league
                                        break
                                
                                if player_league:
                                    # Get track for this race
                                    track = None
                                    if rds.track_id and rds.track_id in self.state.tracks:
                                        track = self.state.tracks[rds.track_id]
                                    
                                    # Simulate the complete race NOW (we'll stream it progressively)
                                    _dbg(f"[FTB RACE DAY] 🏁 Simulating race for streaming...")
                                    race_result = FTBSimulation._simulate_race_lap_by_lap(
                                        self.state, player_league, track, rds.quali_grid, 
                                        self.state.get_rng("race", context=f"live_race_{rds.race_tick}")
                                    )
                                    
                                    # Initialize live streaming from complete race
                                    ftb_race_day.start_live_race_stream(self.state, race_result)
                                    
                                    rds.phase = RaceDayPhase.RACE_RUNNING
                                    rds.live_race_speed = speed
                                    
                                    _dbg(f"[FTB RACE DAY] ✅ Race simulated and armed for live streaming")
                                    _dbg(f"[FTB RACE DAY]    {rds.total_laps} laps, {len(race_result.race_events)} events")
                                    
                                    # --- Start engine audio loop ---
                                    try:
                                        league_tier = 'midformula'
                                        if player_league:
                                            t = player_league.tier
                                            if t <= 1:
                                                league_tier = 'grassroots'
                                            elif t >= 4:
                                                league_tier = 'formulaz'
                                        
                                        # Direct call bypasses event_q race condition
                                        import sys as _sys
                                        _ae_mod = _sys.modules.get('ftb_audio_engine')
                                        if _ae_mod and hasattr(_ae_mod, 'start_engine_audio'):
                                            _ae_mod.start_engine_audio(league_tier)
                                            _dbg(f"[FTB RACE DAY] 🔊 Engine audio started: {league_tier}")
                                        else:
                                            _dbg(f"[FTB RACE DAY] ⚠️  ftb_audio_engine.start_engine_audio not available")
                                    except Exception as _e:
                                        _dbg(f"[FTB RACE DAY] ⚠️  Engine audio start failed: {_e}")
                                    
                                    # --- Enqueue "lights out" PBP commentary ---
                                    try:
                                        _dbg(f"[FTB PBP] 🏁 Calling _enqueue_pbp_commentary_for_race_start...")
                                        self._enqueue_pbp_commentary_for_race_start(rds, player_league, track)
                                        _dbg(f"[FTB PBP] ✅ Race start commentary call completed")
                                    except Exception as _e:
                                        _dbg(f"[FTB RACE DAY] ⚠️  Race start commentary failed: {_e}")
                                        import traceback; traceback.print_exc()
                                    
                                else:
                                    _dbg(f"[FTB RACE DAY] ⚠️  Could not find player league for race")

                
                elif cmd == "ftb_advance_race_lap":
                    # NEW: Advance race stream by one lap
                    if self.state and ftb_race_day and self.state.race_day_state:
                        with self.state_lock:
                            prev_lap = self.state.race_day_state.current_lap
                            has_more_laps = ftb_race_day.advance_race_stream_lap(self.state)
                            
                            # Write race state to DB for narrator/UI
                            rds = self.state.race_day_state
                            self._write_race_day_state_to_db(rds)
                            
                            # --- Generate PBP commentary for this lap ---
                            _dbg(f"[FTB PBP] 🔍 Lap check: prev_lap={prev_lap}, current_lap={rds.current_lap}, has_more={has_more_laps}")
                            if rds.current_lap > prev_lap:
                                try:
                                    self._enqueue_pbp_commentary_for_lap(rds)
                                except Exception as _e:
                                    _dbg(f"[FTB RACE DAY] ⚠️  Lap commentary failed: {_e}")
                                    import traceback; traceback.print_exc()
                            
                            if not has_more_laps:
                                # Race complete
                                ftb_race_day.complete_race_stream(self.state)
                                _dbg(f"[FTB RACE DAY] 🏁 All laps complete!")
                                
                                # --- Stop engine audio ---
                                try:
                                    import sys as _sys
                                    _ae_mod = _sys.modules.get('ftb_audio_engine')
                                    if _ae_mod and hasattr(_ae_mod, 'stop_engine_audio'):
                                        _ae_mod.stop_engine_audio()
                                        _dbg(f"[FTB RACE DAY] 🔇 Engine audio stopped")
                                    else:
                                        _dbg(f"[FTB RACE DAY] ⚠️  ftb_audio_engine.stop_engine_audio not available")
                                except Exception as _e:
                                    _dbg(f"[FTB RACE DAY] ⚠️  Engine audio stop failed: {_e}")
                
                elif cmd == "ftb_pause_live_race":
                    # NEW: Pause/resume live race
                    if self.state and self.state.race_day_state:
                        paused = msg.get("paused", True)
                        with self.state_lock:
                            # Toggle pause state (implementation depends on race playback system)
                            _dbg(f"[FTB RACE DAY] {'⏸️' if paused else '▶️'} Race {'paused' if paused else 'resumed'}")
                
                elif cmd == "ftb_complete_race_day":
                    # NEW: Complete race day and advance tick
                    # Can be called naturally (PBP widget finished) OR as a skip
                    # (user pressed tick button mid-race to fast-forward).
                    if self.state and ftb_race_day and self.state.race_day_state:
                        from plugins.ftb_race_day import RaceDayPhase
                        
                        _skip_phase = self.state.race_day_state.phase
                        _dbg(f"[FTB RACE DAY] ✅ Race complete / skip - processing results (phase was {_skip_phase.name})")
                        
                        # --- Stop engine audio (may be playing if skipping mid-race) ---
                        try:
                            import sys as _sys
                            _ae_mod = _sys.modules.get('ftb_audio_engine')
                            if _ae_mod and hasattr(_ae_mod, 'stop_engine_audio'):
                                _ae_mod.stop_engine_audio()
                                _dbg("[FTB RACE DAY] 🔇 Engine audio stopped (skip/complete)")
                        except Exception as _e:
                            _dbg(f"[FTB RACE DAY] ⚠️  Engine audio stop failed: {_e}")
                        
                        # --- Clear global PBP_ACTIVE flag ---
                        try:
                            _pbp_flag = self.runtime.get('PBP_ACTIVE')
                            if _pbp_flag:
                                _pbp_flag.clear()
                                _dbg("[FTB RACE DAY] 🔊 PBP_ACTIVE flag CLEARED – narrator unblocked in pipeline")
                        except Exception as _e:
                            _dbg(f"[FTB RACE DAY] ⚠️  Could not clear PBP_ACTIVE flag: {_e}")
                        
                        # --- Resume narrator after PBP ---
                        try:
                            meta = self.active_meta_plugin
                            if meta and hasattr(meta, 'narrator') and meta.narrator:
                                meta.narrator.suspended = False
                                _dbg("[FTB RACE DAY] 🔊 Narrator RESUMED after PBP")
                        except Exception as _e:
                            _dbg(f"[FTB RACE DAY] ⚠️  Could not resume narrator: {_e}")
                        
                        # --- Tell audio engine: restore music ---
                        _pbp_restored = False
                        try:
                            import sys as _sys
                            _ae_mod = _sys.modules.get('ftb_audio_engine')
                            if _ae_mod and hasattr(_ae_mod, 'set_pbp_mode'):
                                _ae_mod.set_pbp_mode(False)
                                _pbp_restored = True
                                _dbg("[FTB RACE DAY] 🔊 Called set_pbp_mode(False) – music restoring")
                            elif _ae_mod and hasattr(_ae_mod, '_audio_engine') and _ae_mod._audio_engine:
                                _ae_mod._audio_engine.music_controller.set_pbp_mute(False)
                                _pbp_restored = True
                                _dbg("[FTB RACE DAY] 🔊 Direct set_pbp_mute(False) – music restoring")
                        except Exception as _e:
                            _dbg(f"[FTB RACE DAY] ⚠️  set_pbp_mode restore via sys.modules failed: {_e}")
                        
                        if not _pbp_restored:
                            try:
                                from plugins import ftb_audio_engine as _ae_direct
                                if hasattr(_ae_direct, 'set_pbp_mode'):
                                    _ae_direct.set_pbp_mode(False)
                                    _dbg("[FTB RACE DAY] 🔊 Direct import set_pbp_mode(False) – music restoring")
                            except Exception as _e2:
                                _dbg(f"[FTB RACE DAY] ⚠️  All audio restore methods failed: {_e2}")
                        
                        # --- Flush PBP queue: kill all queued broadcast segments ---
                        # When skipping/completing a race, any remaining PBP
                        # commentary still sitting in the DB or audio queue is
                        # stale and must not play after the tick advances.
                        try:
                            _db_conn_fn = self.runtime.get('db_connect')
                            if _db_conn_fn:
                                _conn = _db_conn_fn()
                                _flushed = _conn.execute(
                                    "UPDATE segments SET status='done' "
                                    "WHERE status='queued' AND source='broadcast'"
                                ).rowcount
                                _conn.commit()
                                _conn.close()
                                if _flushed:
                                    _dbg(f"[FTB RACE DAY] 🧹 Flushed {_flushed} queued PBP broadcast segments")
                        except Exception as _flush_err:
                            _dbg(f"[FTB RACE DAY] ⚠️  Could not flush PBP segments from DB: {_flush_err}")
                        
                        # --- Drain pre-rendered audio queue ---
                        try:
                            _audio_q = self.runtime.get('audio_queue')
                            if _audio_q:
                                _drained = 0
                                while not _audio_q.empty():
                                    try:
                                        _audio_q.get_nowait()
                                        _drained += 1
                                    except Exception:
                                        break
                                if _drained:
                                    _dbg(f"[FTB RACE DAY] 🧹 Drained {_drained} pre-rendered audio items from queue")
                        except Exception as _drain_err:
                            _dbg(f"[FTB RACE DAY] ⚠️  Could not drain audio queue: {_drain_err}")
                        
                        # --- Stop ftb_pbp live feed ---
                        try:
                            import plugins.ftb_pbp as _pbp_mod
                            _pbp_mod.LIVE_FEED_ACTIVE = False
                            _dbg("[FTB RACE DAY] 🧹 ftb_pbp live feed stopped")
                        except Exception as _pbp_err:
                            _dbg(f"[FTB RACE DAY] ⚠️  Could not stop ftb_pbp live feed: {_pbp_err}")
                        
                        # --- Clear live PBP mode on state ---
                        if self.state:
                            self.state._live_pbp_mode = False
                        
                        # ---- Phase 1: fast state mutations under lock ----
                        _deferred_result_events = []
                        with self.state_lock:
                            rds = self.state.race_day_state
                            
                            # Process race results (points, prizes, standings)
                            if rds.race_result and rds.league_id:
                                try:
                                    league = self.state.leagues.get(rds.league_id)
                                    track = self.state.tracks.get(rds.track_id) if rds.track_id else None
                                    
                                    if league:
                                        result_events = FTBSimulation._process_race_results(
                                            self.state, 
                                            league, 
                                            track,
                                            rds.race_result, 
                                            rds.quali_grid
                                        )
                                        self.state.event_history.extend(result_events)
                                        _deferred_result_events = result_events  # emit AFTER lock
                                        
                                        self.state.completed_race_ticks.add((league.league_id, rds.race_tick))
                                        
                                        self.state.mark_dirty('stats')
                                        self.state.mark_dirty('standings')
                                        self.state.mark_dirty('finance')
                                        
                                        _dbg(f"[FTB RACE DAY] ✅ Race results processed: {len(result_events)} events")
                                except Exception as e:
                                    _dbg(f"[FTB RACE DAY] ⚠️  Failed to process race results: {e}")
                                    import traceback
                                    traceback.print_exc()
                            
                            # Create race result notification for player
                            if rds.race_result and self.state.player_team:
                                try:
                                    import plugins.ftb_notifications as ftb_notif
                                    
                                    player_results = [
                                        (pos, driver_name, team_name, status)
                                        for pos, (driver_name, team_name, status) in enumerate(rds.race_result.final_positions, 1)
                                        if team_name == self.state.player_team.name
                                    ]
                                    
                                    if player_results:
                                        race_events = [e for e in rds.race_result.race_events if hasattr(e, 'metadata')]
                                        track_name = "Unknown Circuit"
                                        if race_events and hasattr(race_events[0], 'metadata'):
                                            track_name = race_events[0].metadata.get('track_name', 'Unknown Circuit')
                                        
                                        driver_1_pos, driver_1_name, _, driver_1_status = player_results[0]
                                        
                                        if len(player_results) > 1:
                                            driver_2_pos, driver_2_name, _, driver_2_status = player_results[1]
                                            best_pos = min(driver_1_pos, driver_2_pos)
                                            if best_pos <= 3:
                                                priority = 80
                                                title = f"🏆 Podium Finish at {track_name}!"
                                            else:
                                                priority = 60
                                                title = f"🏁 Race Complete at {track_name}"
                                            message = f"{self.state.player_team.name} Results:\n"
                                            message += f"  {driver_1_name}: P{driver_1_pos}"
                                            if driver_1_status != 'finished':
                                                message += f" ({driver_1_status.upper()})"
                                            message += f"\n  {driver_2_name}: P{driver_2_pos}"
                                            if driver_2_status != 'finished':
                                                message += f" ({driver_2_status.upper()})"
                                        else:
                                            if driver_1_pos <= 3:
                                                priority = 80
                                                title = f"🏆 P{driver_1_pos} Finish at {track_name}!"
                                            else:
                                                priority = 60
                                                title = f"🏁 P{driver_1_pos} Finish at {track_name}"
                                            message = f"{driver_1_name} finished P{driver_1_pos}"
                                            if driver_1_status != 'finished':
                                                message += f" ({driver_1_status.upper()})"
                                        
                                        ftb_notif.create_notification(
                                            category='race_result',
                                            title=title,
                                            message=message,
                                            priority=priority,
                                            metadata={'positions': [p for p, _, _, _ in player_results], 'track': track_name},
                                            db_path=getattr(self.state, 'state_db_path', None)
                                        )
                                        _dbg(f"[FTB RACE DAY] ✅ Created race result notification: {title}")
                                except Exception as e:
                                    _dbg(f"[FTB RACE DAY] ⚠️  Failed to create race result notification: {e}")
                                    import traceback
                                    traceback.print_exc()
                            
                            # Mark race day complete and allow tick to advance
                            self.state.race_day_state.phase = RaceDayPhase.IDLE
                            self.state.race_day_active = False
                            self.state.race_day_started_ts = None
                            self.state.race_day_state.live_race_active = False
                            self.state.race_day_state.player_wants_live_race = False
                            
                            # Advance tick past the race tick so the game doesn't
                            # get stuck at the pre-race tick.
                            # tick_simulation is fast (no LLM), safe under lock.
                            _catchup_race_tick = self.state.race_day_state.race_tick
                            _catchup_events = []
                            if _catchup_race_tick is not None and self.state.tick < _catchup_race_tick:
                                old_tick = self.state.tick
                                while self.state.tick < _catchup_race_tick:
                                    try:
                                        _catchup_events.extend(FTBSimulation.tick_simulation(self.state))
                                    except Exception as e:
                                        _dbg(f"[FTB RACE DAY] ⚠️  tick_simulation error during catch-up: {e}")
                                        self.state.tick = _catchup_race_tick
                                        break
                                _dbg(f"[FTB RACE DAY] ▶️  Tick caught up: {old_tick} -> {self.state.tick} (race_tick={_catchup_race_tick})")
                            
                            # Clear race_day_state identification (prevent stale re-triggers)
                            self.state.race_day_state.race_tick = None
                            self.state.race_day_state.league_id = None
                            self.state.race_day_state.track_id = None
                            
                            _dbg(f"[FTB RACE DAY] ▶️  Ready to advance tick (phase=IDLE, tick={self.state.tick})")
                        
                        # ---- Phase 2: emit events OUTSIDE the lock (may trigger LLM) ----
                        if _deferred_result_events:
                            self._emit_events(_deferred_result_events)
                        if _catchup_events:
                            self._emit_events(_catchup_events)
                
                elif cmd == "ftb_reset":
                    # Reset to wizard (clear state)
                    with self.state_lock:
                        self.state = None
                    self.log("ftb", "Reset to menu")
                
                elif cmd == "ftb_set_time_mode":
                    mode = msg.get("mode", "manual")
                    if self.state:
                        # Map modes and adjust tick rate
                        if mode == "manual":
                            target_mode = "manual"
                            self.tick_rate = 2.0
                            # SAFETY: If switching to manual while in delegated mode, disable delegation
                            if self.state.control_mode == "delegated":
                                self.state.control_mode = "human"
                                self.delegate_next_tick_ts = None
                                self.log("ftb", "Time mode set to manual - delegation automatically disabled")
                        elif mode == "auto_slow":
                            target_mode = "auto"
                            self.tick_rate = 2.0  # 2 seconds per tick
                        elif mode == "auto_fast":
                            target_mode = "auto"
                            self.tick_rate = 0.5  # 0.5 seconds per tick
                        else:
                            target_mode = mode
                        
                        with self.state_lock:
                            self.state.time_mode = target_mode
                        self.log("ftb", f"Time mode set to {mode} (internal: {target_mode}, rate: {self.tick_rate}s)")

                elif cmd == "ftb_set_tick_rate":
                    sec = float(msg.get("sec", 2.0))
                    self.tick_rate = max(0.1, min(10.0, sec))
                    self.log("ftb", f"Tick rate set to {self.tick_rate}s")
                
                elif cmd == "ftb_delegate":
                    if self.state:
                        with self.state_lock:
                            self.state.control_mode = "delegated"
                            self.state.time_mode = "auto"
                        self.delegate_next_tick_ts = time.time() + self.delegate_start_delay
                        self.log("ftb", f"Delegation enabled - auto-tick will start in {self.delegate_start_delay}s, then every {self.delegate_tick_interval}s")
                
                elif cmd == "ftb_regain_control":
                    if self.state:
                        with self.state_lock:
                            self.state.control_mode = "human"
                            self.state.time_mode = "paused"  # Explicitly stop auto-ticking
                        self.delegate_next_tick_ts = None  # Cancel any pending delegation ticks
                        self.log("ftb", "Human control restored - delegation stopped, auto-tick disabled")
                
                elif cmd == "ftb_apply_focus":
                    """Apply delegation focus (focus modifiers currently disabled)"""
                    focus_text = msg.get("focus_text", "")
                    if self.state and self.state.player_team and focus_text:
                        with self.state_lock:
                            # Get player team's principal (created during world gen)
                            if not self.state.player_team.principal:
                                self.log("ftb", "ERROR: Cannot apply focus - player team has no principal")
                                return
                            
                            # Translate focus text to stat modifiers (currently stubbed - returns empty dict)
                            base_stats = self.state.player_team.principal.current_ratings
                            modifiers = translate_focus_to_modifiers(focus_text, base_stats)
                            
                            # Create DelegationFocus object
                            self.state.delegation_focus = DelegationFocus(
                                focus_text=focus_text,
                                active_modifiers=modifiers,
                                applied_at=self.state.tick,
                                narrative_summary=""
                            )
                            
                            self.log("ftb", f"Focus applied: '{focus_text}' ({len(modifiers)} stat modifiers)")
                            
                            # Log modifier details (debug)
                            for stat, modifier in modifiers.items():
                                self.log("ftb", f"  {stat}: {modifier:+.1f}")
                
                elif cmd == "ftb_clear_focus":
                    """Clear delegation focus modifiers, return to base personality"""
                    if self.state:
                        with self.state_lock:
                            self.state.delegation_focus = None
                        self.log("ftb", "Delegation focus cleared - using base personality")
                
                elif cmd == "ftb_fire_entity":
                    entity_name = msg.get("entity_name")
                    confirmed = msg.get("confirmed", False)
                    
                    # Require confirmation flag from wizard to prevent accidental fires
                    if not confirmed:
                        self.log("ftb", f"Fire command for {entity_name} rejected - not confirmed")
                        continue
                    
                    if self.state and self.state.player_team and entity_name:
                        try:
                            fired_successfully = False
                            with self.state_lock:
                                # Find entity by name
                                entity_to_fire = None
                                for entity in (self.state.player_team.drivers + 
                                             self.state.player_team.engineers + 
                                             self.state.player_team.mechanics):
                                    if entity.name == entity_name:
                                        entity_to_fire = entity
                                        break
                                if not entity_to_fire and self.state.player_team.strategist:
                                    if self.state.player_team.strategist.name == entity_name:
                                        entity_to_fire = self.state.player_team.strategist
                                
                                if entity_to_fire:
                                    events = []

                                    if isinstance(entity_to_fire, Driver):
                                        action = Action("fire_driver", cost=0, target=entity_to_fire.name)
                                        events = FTBSimulation.apply_action(action, self.state.player_team, self.state)
                                    elif isinstance(entity_to_fire, Engineer):
                                        action = Action("fire_engineer", cost=0, target=entity_to_fire.name)
                                        events = FTBSimulation.apply_action(action, self.state.player_team, self.state)
                                    else:
                                        # Fallback for roles without dedicated action handlers.
                                        self.state.player_team.remove_entity(entity_to_fire)
                                        self.state.player_team.normalize_roster()

                                        if hasattr(entity_to_fire, 'entity_id') and entity_to_fire.entity_id in self.state.contracts:
                                            contract = self.state.contracts.get(entity_to_fire.entity_id)
                                            self.state.apply_contract_buyout(self.state.player_team, contract, entity_name)
                                            del self.state.contracts[entity_to_fire.entity_id]

                                        asking_salary = estimate_salary_expectation(
                                            entity_to_fire,
                                            team_tier=self.state.player_team.tier,
                                            fired=True
                                        ) * 365  # Convert per-tick to annual
                                        self.state.add_to_free_agent_pool(entity_to_fire, "fired", asking_salary)

                                        event = SimEvent(
                                            event_type="structural",
                                            category="staff_change",
                                            ts=self.state.tick,
                                            priority=70.0,
                                            severity="info",
                                            event_id=FTBSimulation._generate_event_id(self.state),
                                            data={
                                                'team': self.state.player_team.name,
                                                'entity': entity_name,
                                                'action': 'fired',
                                                'type': type(entity_to_fire).__name__
                                            }
                                        )
                                        events = [event]

                                    if events:
                                        self.state.event_history.extend(events)
                                    
                                    # Only mark as successful if events were generated
                                    if events:
                                        # Mark all domains dirty to force complete UI refresh
                                        self.state.mark_dirty('all')
                                        fired_successfully = True
                                        self.log("ftb", f"Fired: {entity_name}")
                                    else:
                                        self.log("ftb", f"Failed to fire {entity_name} - no events generated")
                            
                            # Trigger immediate UI refresh (outside lock)
                            if fired_successfully:
                                self._refresh_widget()
                        except Exception as e:
                            self.log("ftb", f"ERROR firing {entity_name}: {e}")
                            import traceback
                            traceback.print_exc()
                
                elif cmd == "ftb_hire_free_agent":
                    free_agent_id = msg.get("free_agent_id")
                    if self.state and self.state.player_team and free_agent_id is not None:
                        with self.state_lock:
                            # Find free agent by id
                            free_agent = None
                            for fa in self.state.free_agents:
                                if id(fa) == free_agent_id:
                                    free_agent = fa
                                    break
                            
                            if free_agent:
                                entity = free_agent.entity
                                asking_salary = free_agent.asking_salary
                                
                                # Check if team can afford
                                if self.state.player_team.budget.cash >= asking_salary:
                                    offer_data = {
                                        'entity_id': entity.entity_id,
                                        'seasons_duration': 2,
                                        'base_salary': asking_salary,
                                        'signing_bonus': 0,
                                        'performance_clauses': {},
                                        'exit_clauses': {},
                                        'role': type(entity).__name__
                                    }

                                    rng = self.state.get_rng("contracts", entity.entity_id)
                                    result = self.state.evaluate_contract_offer(entity.entity_id, offer_data, rng)

                                    if result.get('accepted'):
                                        contract_data = {
                                            **offer_data,
                                            'team_name': self.state.player_team.name
                                        }

                                        if self.state.finalize_contract(entity.entity_id, contract_data):
                                            # Generate event
                                            event = SimEvent(
                                                event_type="structural",
                                                category="staff_change",
                                                ts=self.state.tick,
                                                priority=70.0,
                                                severity="info",
                                                event_id=FTBSimulation._generate_event_id(self.state),
                                                data={
                                                    'team': self.state.player_team.name,
                                                    'entity': entity.name,
                                                    'action': 'hired',
                                                    'type': type(entity).__name__,
                                                    'salary': asking_salary,
                                                    'source': 'free_agency'
                                                }
                                            )
                                            self.state.event_history.append(event)
                                            self._emit_events([event], skip_narration=True)
                                            
                                            # Mark dirty and trigger UI refresh
                                            self.state._team_dirty = True
                                            self.state._finance_dirty = True
                                            self._refresh_widget()
                                            
                                            self.log("ftb", f"Hired from free agency: {entity.name} for {format_currency(asking_salary)}/year")
                                    else:
                                        self.log("ftb", f"Negotiation failed with {entity.name}: {result.get('message', 'Offer rejected')}")
                                else:
                                    self.log("ftb", f"Cannot afford to hire {entity.name}")
                
                elif cmd == "ftb_poach_driver":
                    driver_entity_id = msg.get("driver_entity_id")
                    original_team_name = msg.get("original_team_name")
                    buyout_amount = msg.get("buyout_amount")
                    
                    if self.state and self.state.player_team and driver_entity_id and original_team_name:
                        with self.state_lock:
                            # Find the driver and original team
                            driver = None
                            original_team = None
                            
                            # Search all teams for the driver
                            all_teams = ([self.state.player_team] if self.state.player_team else []) + self.state.ai_teams
                            for team in all_teams:
                                if team.name == original_team_name:
                                    original_team = team
                                for d in team.drivers:
                                    if d and getattr(d, 'entity_id', None) == driver_entity_id:
                                        driver = d
                                        break
                                if driver:
                                    break
                            
                            if driver and original_team:
                                # Get contract
                                contract = self.state.contracts.get(driver_entity_id)
                                if not contract:
                                    self.log("ftb", f"ERROR: No contract found for {driver.name}")
                                    return
                                
                                # Execute buyout
                                # 1. Pay buyout to original team
                                self.state.player_team.budget.cash -= buyout_amount
                                original_team.budget.cash += buyout_amount
                                
                                self.state.log_transaction(
                                    type="expense",
                                    category="buyout",
                                    amount=buyout_amount,
                                    description=f"Contract buyout for {driver.name} from {original_team_name}",
                                    balance_after=self.state.player_team.budget.cash,
                                    related_entity=driver.name
                                )
                                
                                # 2. Remove driver from original team
                                original_team.drivers = [d for d in original_team.drivers if d != driver]
                                original_team.budget.remove_staff_salary(driver.name)
                                
                                # 3. Terminate old contract
                                del self.state.contracts[driver_entity_id]
                                
                                # 4. Reset morale (fresh start)
                                if hasattr(driver, 'morale'):
                                    driver.morale = 60.0  # Start at slightly positive
                                
                                # 5. Add to player team
                                self.state.player_team.drivers.append(driver)
                                
                                # 6. Generate event
                                self.state.event_history.append(SimEvent(
                                    event_type="transaction",
                                    category="driver_poached",
                                    ts=self.state.tick,
                                    priority=85.0,
                                    severity="major",
                                    data={
                                        'driver': driver.name,
                                        'from_team': original_team_name,
                                        'to_team': self.state.player_team.name,
                                        'buyout': buyout_amount,
                                        'rating': driver.overall_rating,
                                        'message': f'{driver.name} poached from {original_team_name} via buyout clause'
                                    }
                                ))
                                
                                # 7. Automatically create a fair contract
                                # Calculate fair contract terms based on driver rating and old contract
                                old_contract = contract if 'contract' in locals() else None
                                old_salary = old_contract.base_salary if old_contract else int(driver.overall_rating * 3000)
                                
                                # New salary: 25% raise (standard for switching teams)
                                new_salary = int(old_salary * 1.25)
                                signing_bonus = int(new_salary * 0.3)
                                
                                # Create new contract (2 seasons with 30-day protection)
                                new_contract = Contract(
                                    entity_id=driver_entity_id,
                                    entity_name=driver.name,
                                    team_name=self.state.player_team.name,
                                    role="Driver",
                                    start_day=self.state.sim_day_of_year,
                                    duration_days=Contract.seasons_to_days(2),
                                    base_salary=new_salary,
                                    seasons_duration=2,
                                    signing_bonus=signing_bonus,
                                    poaching_protection_until=self.state.sim_day_of_year + 30
                                )
                                
                                # Register contract
                                self.state.contracts[driver_entity_id] = new_contract
                                
                                # Add to payroll
                                self.state.player_team.budget.add_staff_salary(driver.name, new_salary)
                                
                                # Pay signing bonus
                                self.state.player_team.budget.cash -= signing_bonus
                                self.state.log_transaction(
                                    type="expense",
                                    category="signing_bonus",
                                    amount=signing_bonus,
                                    description=f"Signing bonus for {driver.name}",
                                    balance_after=self.state.player_team.budget.cash,
                                    related_entity=driver.name
                                )
                                
                                self.log("ftb", f"✅ {driver.name} poached from {original_team_name} for ${buyout_amount:,}")
                                self.log("ftb", f"📄 Contract signed: ${new_salary:,}/year for 2 seasons (Bonus: ${signing_bonus:,})")
                                
                                # Mark dirty
                                self.state._team_dirty = True
                                self.state._roster_dirty = True
                                self.state._finance_dirty = True
                                self._refresh_widget()
                            else:
                                self.log("ftb", f"ERROR: Could not find driver or team for poaching")
                
                elif cmd == "ftb_submit_contract_offer":
                    # Handle contract negotiation offer
                    offer_data = msg.get("offer_data", {})
                    entity_id = offer_data.get('entity_id')
                    
                    if self.state and entity_id is not None:
                        with self.state_lock:
                            # Evaluate the offer with deterministic RNG
                            rng = self.state.get_rng("contracts", entity_id)
                            result = self.state.evaluate_contract_offer(entity_id, offer_data, rng)
                            
                            # Send result back to UI
                            self.runtime["ui_cmd_q"].put(("ftb_contract_offer_result", {
                                "result": result,
                                "entity_id": entity_id
                            }))
                            
                            self.log("ftb", f"Contract offer evaluated for entity {entity_id}: {result.get('accepted', False)}")
                
                elif cmd == "ftb_finalize_contract":
                    # Finalize and sign a contract
                    contract_data = msg.get("contract_data", {})
                    entity_id = contract_data.get('entity_id')
                    
                    if self.state and entity_id is not None:
                        try:
                            # Finalize contract with state lock
                            with self.state_lock:
                                success = self.state.finalize_contract(entity_id, contract_data)
                                
                                if success:
                                    # Mark ALL domains dirty to force complete UI refresh
                                    self.state.mark_dirty('all')
                            
                            # Release lock before UI updates
                            if success:
                                # Send success back to UI
                                self.runtime["ui_cmd_q"].put(("ftb_contract_signed", {
                                    "success": True,
                                    "entity_id": entity_id
                                }))
                                
                                # Trigger immediate UI refresh (no lock needed)
                                self._refresh_widget()
                                
                                self.log("ftb", f"Contract finalized for entity {entity_id}")
                            else:
                                self.runtime["ui_cmd_q"].put(("ftb_contract_signed", {
                                    "success": False,
                                    "entity_id": entity_id
                                }))
                        except Exception as e:
                            self.log("ftb", f"ERROR finalizing contract: {e}")
                            import traceback
                            traceback.print_exc()
                            # Send failure to UI
                            try:
                                self.runtime["ui_cmd_q"].put(("ftb_contract_signed", {
                                    "success": False,
                                    "entity_id": entity_id
                                }))
                            except:
                                pass
                
                elif cmd == "ftb_apply_job":
                    listing_id = msg.get("listing_id")
                    if self.state and self.state.player_team and listing_id:
                        with self.state_lock:
                            # Find job listing by id
                            listing = None
                            for job in self.state.job_board.vacancies:
                                if id(job) == listing_id:
                                    listing = job
                                    break
                            
                            if listing:
                                # Check if can afford
                                application_cost = 1000.0
                                if not self.state.player_team.budget.can_afford(application_cost):
                                    self.log("ftb", "Cannot afford job application")
                                    return
                                
                                # Deduct cost
                                self.state.player_team.budget.cash -= application_cost
                                
                                # Calculate acceptance
                                player_metrics = self.state.player_team.standing_metrics
                                acceptance_chance = self.state.job_board.get_acceptance_chance(player_metrics, listing)
                                rng = self.state.get_rng("jobs", f"application_{self.state.tick}")
                                accepted = rng.random() < acceptance_chance
                                
                                if accepted:
                                    # Remove job from board
                                    self.state.job_board.vacancies.remove(listing)
                                    
                                    # Transfer player to new team
                                    old_team = self.state.player_team.name
                                    target_team = listing.team
                                    if not target_team:
                                        target_team = next((t for t in self.state.ai_teams if t.name == listing.team_name), None)
                                    if not target_team:
                                        target_team = self.state.player_team
                                    self.state.player_team = target_team
                                    
                                    # Generate success event
                                    event = SimEvent(
                                        event_type="structural",
                                        category="job_accepted",
                                        ts=self.state.tick,
                                        priority=90.0,
                                        severity="success",
                                        event_id=FTBSimulation._generate_event_id(self.state),
                                        data={
                                            'old_team': old_team,
                                            'new_team': target_team.name,
                                            'role': listing.role,
                                            'cost': application_cost
                                        }
                                    )
                                    self.state.event_history.append(event)
                                    self._emit_events([event], skip_narration=True)
                                    self.log("ftb", f"Job accepted: {listing.role} at {listing.team.name}")
                                else:
                                    # Generate rejection event
                                    event = SimEvent(
                                        event_type="structural",
                                        category="job_rejected",
                                        ts=self.state.tick,
                                        priority=70.0,
                                        severity="warning",
                                        event_id=FTBSimulation._generate_event_id(self.state),
                                        data={
                                            'team': listing.team.name if listing.team else listing.team_name,
                                            'role': listing.role,
                                            'cost': application_cost
                                        }
                                    )
                                    self.state.event_history.append(event)
                                    self._emit_events([event], skip_narration=True)
                                    self.log("ftb", f"Job rejected: {listing.role} at {listing.team.name if listing.team else listing.team_name}")
                
                elif cmd == "ftb_start_development":
                    config = msg.get("config")
                    if self.state and self.state.player_team and config:
                        with self.state_lock:
                            # Map subsystem to project_id (use first available project for that subsystem)
                            subsystem = config.get('subsystem', 'general')
                            subsystem_to_project = {
                                'Aerodynamics': 'rd_aero_efficiency',
                                'Power Unit': 'rd_power_output',
                                'Suspension': 'rd_mechanical_grip',
                                'Reliability': 'rd_reliability',
                                'Driveability': 'rd_driveability',
                                'Strategy Tools': 'rd_setup_window'
                            }
                            
                            project_id = subsystem_to_project.get(subsystem)
                            if not project_id:
                                self.log("ftb", f"ERROR: Unknown subsystem '{subsystem}' - cannot map to project")
                                project_id = 'rd_driveability'  # Fallback
                            
                            # Get engineer entity IDs from names
                            assigned_engineer_ids = []
                            assigned_engineers = config.get('engineers', [])
                            for eng in assigned_engineers:
                                # eng is an Engineer object from the wizard
                                if hasattr(eng, 'entity_id'):
                                    assigned_engineer_ids.append(eng.entity_id)
                                elif hasattr(eng, 'name'):
                                    self.log("ftb", f"Engineer {eng.name} missing entity_id")
                            
                            # Create action to start R&D project
                            action = Action(
                                name="start_rd_" + project_id,
                                target=project_id,
                                cost=config.get('budget', 0),
                                params={
                                    'assigned_engineers': assigned_engineer_ids,
                                    'risk_level': config.get('risk_level', 0.5),
                                    'priority': config.get('priority', 'normal')
                                }
                            )
                            
                            # Apply action (this will handle cost deduction and validation)
                            events = FTBSimulation._apply_start_rd_project(action, self.state.player_team, self.state)
                            if events:
                                self.state.event_history.extend(events)
                                self._emit_events(events, skip_narration=True)
                                self.log("ftb", f"✓ Started R&D project: {project_id} ({subsystem})")
                                self.state._rd_projects_dirty = True
                            else:
                                self.log("ftb", f"WARNING: Failed to start R&D project {project_id} - no events returned")
                
                elif cmd == "ftb_cancel_rd_project":
                    project_id = msg.get("project_id")
                    if self.state and self.state.player_team and project_id:
                        with self.state_lock:
                            # Create action to cancel R&D project
                            action = Action(
                                name="rd_cancel",
                                target=project_id,
                                cost=0
                            )
                            
                            # Apply action
                            events = FTBSimulation._apply_cancel_rd_project(action, self.state.player_team, self.state)
                            if events:
                                self.state.event_history.extend(events)
                                self._emit_events(events, skip_narration=True)
                                self.log("ftb", f"Cancelled R&D project: {project_id}")
                
                elif cmd == "ftb_rename_car":
                    new_name = msg.get("new_name")
                    if self.state and self.state.player_team and self.state.player_team.car and new_name:
                        with self.state_lock:
                            old_name = self.state.player_team.car.name
                            self.state.player_team.car.name = new_name
                            
                            # Generate event
                            event = SimEvent(
                                event_type="structural",
                                category="car_renamed",
                                ts=self.state.tick,
                                priority=30.0,
                                severity="info",
                                event_id=FTBSimulation._generate_event_id(self.state),
                                data={
                                    'team': self.state.player_team.name,
                                    'old_name': old_name,
                                    'new_name': new_name
                                }
                            )
                            self.state.event_history.append(event)
                            self._emit_events([event], skip_narration=True)
                            self.state.mark_dirty('car')
                            self.log("ftb", f"Car renamed: {old_name} -> {new_name}")
                
                elif cmd == "ftb_equip_part":
                    part_id = msg.get("part_id")
                    if self.state and self.state.player_team and part_id:
                        with self.state_lock:
                            # Find part in inventory
                            part = None
                            for p in self.state.player_team.parts_inventory:
                                if p.part_id == part_id:
                                    part = p
                                    break
                            
                            if not part:
                                self.log("ftb", f"Part {part_id} not found in inventory")
                                _dbg(f"[FTB CONTROLLER] ❌ Equip FAILED - part not found in inventory: {part_id}")
                                return
                            
                            _dbg(f"[FTB CONTROLLER] Equipping part: {part.name} ({part.part_type})")
                            _dbg(f"[FTB CONTROLLER] Before: Inventory={len(self.state.player_team.parts_inventory)} parts, Equipped={len(self.state.player_team.equipped_parts)} parts")
                            
                            # Remove from inventory
                            self.state.player_team.parts_inventory.remove(part)
                            
                            # If slot occupied, move old part to inventory
                            old_part = self.state.player_team.equipped_parts.get(part.part_type)
                            if old_part:
                                self.state.player_team.parts_inventory.append(old_part)
                                _dbg(f"[FTB CONTROLLER] Unequipped old part: {old_part.name}")
                            
                            # Equip new part
                            self.state.player_team.equipped_parts[part.part_type] = part
                            
                            # Update car ratings - use car's base_ratings (tier-specific), not schema defaults!
                            # If base_ratings doesn't exist (old save), fall back to current_ratings as baseline
                            if hasattr(self.state.player_team.car, 'base_ratings') and self.state.player_team.car.base_ratings:
                                base_ratings = self.state.player_team.car.base_ratings.copy()
                            else:
                                # Fallback for old saves: use current ratings without parts as baseline
                                # This isn't perfect but prevents jumping to 50s
                                base_ratings = self.state.player_team.car.current_ratings.copy()
                                _dbg(f"[FTB CONTROLLER] ⚠️  Car missing base_ratings, using current_ratings as fallback")
                            
                            self.state.player_team.car.update_ratings(base_ratings, self.state.player_team.equipped_parts)
                            
                            _dbg(f"[FTB CONTROLLER] After: Inventory={len(self.state.player_team.parts_inventory)} parts, Equipped={len(self.state.player_team.equipped_parts)} parts")
                            
                            # Generate event
                            event = SimEvent(
                                event_type="structural",
                                category="part_equipped",
                                ts=self.state.tick,
                                priority=55.0,
                                severity="info",
                                event_id=FTBSimulation._generate_event_id(self.state),
                                data={
                                    'team': self.state.player_team.name,
                                    'part_id': part_id,
                                    'part_name': part.name,
                                    'part_type': part.part_type,
                                    'performance_score': round(part.performance_score, 2),
                                    'replaced': old_part.name if old_part else None
                                }
                            )
                            self.state.event_history.append(event)
                            self._emit_events([event], skip_narration=True)
                            self.state.mark_dirty('car')
                            _dbg(f"[FTB CONTROLLER] ✅ Part equipped successfully")
                            self.log("ftb", f"Part equipped: {part.name} ({part.part_type})")
                
                elif cmd == "ftb_sell_part":
                    part_id = msg.get("part_id")
                    if self.state and self.state.player_team and part_id:
                        with self.state_lock:
                            # Find part in inventory
                            part = None
                            for p in self.state.player_team.parts_inventory:
                                if p.part_id == part_id:
                                    part = p
                                    break
                            
                            if not part:
                                self.log("ftb", f"Part {part_id} not found in inventory")
                                _dbg(f"[FTB CONTROLLER] ❌ Sell FAILED - part not found in inventory: {part_id}")
                                return
                            
                            # Check if part is equipped
                            is_equipped = False
                            for equipped_part in self.state.player_team.equipped_parts.values():
                                if equipped_part.part_id == part_id:
                                    is_equipped = True
                                    break
                            
                            if is_equipped:
                                self.log("ftb", f"Cannot sell equipped part {part.name}")
                                _dbg(f"[FTB CONTROLLER] ❌ Sell FAILED - part is equipped: {part.name}")
                                return
                            
                            _dbg(f"[FTB CONTROLLER] Selling part: {part.name} ({part.part_type})")
                            _dbg(f"[FTB CONTROLLER] Before: Cash=${self.state.player_team.budget.cash:,}, Inventory={len(self.state.player_team.parts_inventory)} parts")
                            
                            # Create sell_part action and apply it
                            original_cost = FTBSimulation.calculate_part_cost(part)
                            action = Action(
                                name="sell_part",
                                target=part_id,
                                cost=0,
                                original_cost=original_cost
                            )
                            
                            events = FTBSimulation._apply_sell_part(action, self.state.player_team, self.state)
                            
                            _dbg(f"[FTB CONTROLLER] After: Cash=${self.state.player_team.budget.cash:,}, Inventory={len(self.state.player_team.parts_inventory)} parts")
                            
                            # Emit events
                            if events:
                                self.state.event_history.extend(events)
                                self._emit_events(events, skip_narration=True)
                                _dbg(f"[FTB CONTROLLER] ✅ Part sold successfully - generated {len(events)} events")
                            else:
                                _dbg(f"[FTB CONTROLLER] ⚠️ Part sale completed but no events generated")
                            
                            self.state.mark_dirty('car')
                            self.state.mark_dirty('finance')  # Also mark finance dirty for cash update
                            self.log("ftb", f"Part sold: {part.name}")
                
                elif cmd == "ftb_purchase_part":
                    part_id = msg.get("part_id")
                    cost = msg.get("cost", 0)
                    _dbg(f"[FTB CONTROLLER] Purchase command received: part_id={part_id}, cost=${cost:,}")
                    if self.state and self.state.player_team and part_id:
                        with self.state_lock:
                            # Check if can afford
                            if self.state.player_team.budget.cash < cost:
                                _dbg(f"[FTB CONTROLLER] ❌ Purchase FAILED - insufficient funds: have ${self.state.player_team.budget.cash:,}, need ${cost:,}")
                                self.log("ftb", f"Cannot afford part {part_id}")
                                return
                            
                            # Find part in catalog
                            part = self.state.parts_catalog.get(part_id)
                            if not part:
                                _dbg(f"[FTB CONTROLLER] ❌ Purchase FAILED - part not found in catalog: {part_id}")
                                self.log("ftb", f"Part {part_id} not found in catalog")
                                return
                            
                            _dbg(f"[FTB CONTROLLER] Processing purchase: {part.name} (${cost:,})")
                            _dbg(f"[FTB CONTROLLER] Before: Cash=${self.state.player_team.budget.cash:,}, Inventory={len(self.state.player_team.parts_inventory)} parts")
                            
                            # Create purchase_part action and apply it
                            action = Action(
                                name="purchase_part",
                                target=part_id,
                                cost=cost
                            )
                            
                            events = FTBSimulation._apply_purchase_part(action, self.state.player_team, self.state)
                            
                            _dbg(f"[FTB CONTROLLER] After: Cash=${self.state.player_team.budget.cash:,}, Inventory={len(self.state.player_team.parts_inventory)} parts")
                            _dbg(f"[FTB CONTROLLER] Part now in inventory: {part in self.state.player_team.parts_inventory}")
                            
                            # Emit events
                            if events:
                                self.state.event_history.extend(events)
                                self._emit_events(events, skip_narration=True)
                                
                            self.state.mark_dirty('car')
                            self.state.mark_dirty('development')
                            self.state.mark_dirty('finance')  # Also update finance for cash change
                            _dbg(f"[FTB CONTROLLER] ✅ Purchase complete - dirty flags set: car={self.state._car_dirty}, dev={self.state._development_dirty}, finance={self.state._finance_dirty}")
                            self.log("ftb", f"Part purchased: {part.name} for ${cost:,}")
                            
                            # Force immediate UI refresh via ui_q (not needed - dirty flags handle it)
                            # Commenting out the force_refresh since tab-based dirty flags already handle updates
                
                elif cmd == "ftb_upgrade_infrastructure":
                    facility = msg.get("facility")
                    amount = msg.get("amount", 10.0)  # Default to 10 if not specified
                    
                    if self.state and self.state.player_team and facility:
                        try:
                            with self.state_lock:
                                # Use Team's direct_upgrade_facility method which handles validation
                                result = self.state.player_team.direct_upgrade_facility(facility, amount)
                                
                                if result['success']:
                                    # Generate event
                                    event = SimEvent(
                                        event_type="structural",
                                        category="infrastructure_upgraded",
                                        ts=self.state.tick,
                                        priority=65.0,
                                        severity="info",
                                        event_id=FTBSimulation._generate_event_id(self.state),
                                        data={
                                            'team': self.state.player_team.name,
                                            'facility': facility,
                                            'old_quality': result['old_quality'],
                                            'new_quality': result['new_quality'],
                                            'cost': result['cost'],
                                            'amount': result['amount']
                                        }
                                    )
                                    self.state.event_history.append(event)
                                    self._emit_events([event], skip_narration=True)
                                    self.state.mark_dirty('development')
                                    self.state.mark_dirty('finance')
                                    self.log("ftb", f"Upgraded {facility}: {result['old_quality']:.0f} → {result['new_quality']:.0f} for ${result['cost']:,.0f}")
                                else:
                                    self.log("ftb", f"Infrastructure upgrade failed: {result['message']}")
                        except Exception as e:
                            self.log("ftb", f"ERROR upgrading infrastructure: {e}")
                            import traceback
                            traceback.print_exc()
                
                elif cmd == "ftb_sell_infrastructure":
                    facility = msg.get("facility")
                    if self.state and self.state.player_team and facility:
                        with self.state_lock:
                            # Use the new sell_facility method
                            result = self.state.player_team.sell_facility(facility)
                            
                            if result['success']:
                                # Generate event
                                event = SimEvent(
                                    event_type="structural",
                                    category="infrastructure_sold",
                                    ts=self.state.tick,
                                    priority=75.0,  # Higher priority - this is dramatic
                                    severity="warning" if result['tier'] < 5 else "danger",
                                    event_id=FTBSimulation._generate_event_id(self.state),
                                    data={
                                        'team': self.state.player_team.name,
                                        'facility': facility,
                                        'old_quality': result['old_quality'],
                                        'recovery_cash': result['recovery_cash'],
                                        'tier': result['tier'],
                                        'tier_name': result['tier_name']
                                    }
                                )
                                self.state.event_history.append(event)
                                self._emit_events([event], skip_narration=True)
                                self.log("ftb", f"Sold {facility}: Q{result['old_quality']:.0f} for ${result['recovery_cash']:,.0f}")
                            else:
                                self.log("ftb", f"Failed to sell {facility}: {result['message']}")
                
                elif cmd == "ftb_action":
                    action_id = msg.get("action_id")
                    params = msg.get("params", {})
                    # TODO: Apply action to state
                    self.log("ftb", f"Action: {action_id} {params}")
                
                else:
                    self.log("ftb", f"WARNING: Unknown command '{cmd}' - ignoring")
            
            except Exception as e:
                # Individual command error - log but continue processing queue
                import traceback
                self.log("ftb", f"ERROR processing command '{cmd}': {e}")
                self.log("ftb", traceback.format_exc())
                _dbg(f"[FTB] COMMAND ERROR: {cmd} failed with {e}")
                # Continue to next command instead of crashing entire handler
    
    def _emit_events(self, sim_events: List[SimEvent], batch_mode: bool = False, tick_range: tuple = None, skip_narration: bool = False) -> None:
        """
        Emit From the Backmarker simulation events.

        Architectural guarantees:
        - SimEvents are NEVER spoken directly.
        - StationEvents are UI / observability ONLY.
        - ALL narration is produced exclusively by the FTB meta plugin
        via beat → segment emission.
        
        Args:
            sim_events: List of simulation events to emit
            batch_mode: If True, events are from multi-day batch (hint to narrator)
            tick_range: Tuple of (start_tick, end_tick) for batch context
            skip_narration: If True, skip narration generation (for UI commands)
        """
        
        # Filter out hire and fire events
        filtered_events = [
            event for event in sim_events 
            if event.category not in ("driver_hired", "driver_fired", "engineer_hired", "engineer_fired")
        ]
        sim_events = filtered_events
        
        # DEBUG: Log event count
        mode_str = f" [BATCH {tick_range[0]}→{tick_range[1]}]" if batch_mode else ""
        self.log("ftb", f"_emit_events called with {len(sim_events)} events{mode_str}")
        
        # Tag all events as FTB events so narrator recognizes them
        for event in sim_events:
            event.data["_ftb"] = True
        
        # Add batch metadata to events if in batch mode
        if batch_mode and tick_range:
            for event in sim_events:
                event.data["_batch_mode"] = True
                event.data["_batch_start_tick"] = tick_range[0]
                event.data["_batch_end_tick"] = tick_range[1]

        # ------------------------------------------------------------------
        # 0. Write events to event pool for continuous narrator
        # ------------------------------------------------------------------
        if self.event_pool:
            try:
                self.event_pool.extend(sim_events)
                
                # Update player state cache for narrator queries
                if self.state and self.state.player_team:
                    # Find player's league and position
                    player_league = None
                    player_position = 0
                    for league in self.state.leagues.values():
                        if self.state.player_team in league.teams:
                            player_league = league
                            standings = sorted(
                                league.championship_table.items(),
                                key=lambda x: x[1],
                                reverse=True
                            )
                            for pos, (team_name, _) in enumerate(standings, 1):
                                if team_name == self.state.player_team.name:
                                    player_position = pos
                                    break
                            break
                    
                    player_state = {
                        "budget": self.state.player_team.budget.cash,
                        "championship_position": player_position,
                        "points": player_league.championship_table.get(self.state.player_team.name, 0) if player_league else 0,
                        "morale": self.state.player_team.standing_metrics.get("morale", 50.0),
                        "reputation": self.state.player_team.standing_metrics.get("reputation", 0.0),
                        "tier": player_league.tier if player_league else 1,
                        "current_day": self.state.sim_day_of_year,
                        "season": self.state.season_number
                    }
                    self.event_pool.update_player_state(player_state)
                    
                    # NEW: Call narrator with state snapshot and events (state-aware narration contract)
                    if self.narrator and self.state:
                        try:
                            from plugins_disabled.perhapsuse import StateSnapshot
                            
                            # Build state snapshot for narrator
                            snapshot = StateSnapshot(
                                tick=self.state.tick,
                                player_team=self.state.player_team.name,
                                player_role=self.state.player_identity[0] if self.state.player_identity else "Manager",
                                league_tier=player_league.tier if player_league else 1,
                                league_name=player_league.name if player_league else "Unknown",
                                championship_position=player_position,
                                championship_points=player_state["points"],
                                budget=int(self.state.player_team.budget.cash),
                                budget_status=self._classify_budget_status(self.state.player_team.budget.cash, self.state.player_team.budget.budget_limit),
                                driver_names=[d.name for d in self.state.player_team.drivers],
                                staff_names=[],  # Could expand
                                car_exists=True,
                                morale_level=self._classify_morale(player_state["morale"]),
                                organizational_posture="new" if self.state.tick < 10 else "unstable",
                                has_financial_crisis=self.state.player_team.budget.cash < 0,
                                has_morale_crisis=player_state["morale"] < 30.0,
                                current_day=self.state.sim_day_of_year,
                                current_season=self.state.season_number,
                                environment_crowded=len([t for t in player_league.teams if t]) > 10 if player_league else False,
                                recent_trend=self._get_recent_trend()
                            )
                            
                            # Call narrator with state and events
                            self.narrator.narrate_tick(snapshot, sim_events, self.state.tick)
                            
                        except Exception as e:
                            self.log("ftb", f"Error calling narrator.narrate_tick: {e}")
                            import traceback
                            self.log("ftb", traceback.format_exc())
            except Exception as e:
                self.log("ftb", f"Event pool write error: {e}")

        # ------------------------------------------------------------------
        # 1. Emit UI-only StationEvents (NO radio path, NO narration)
        # ------------------------------------------------------------------
        ui_event_q = self.runtime.get("ui_event_q")
        event_q = self.runtime.get("event_q")  # For audio engine
        StationEvent = self.runtime.get("StationEvent")

        if ui_event_q and StationEvent:
            for sim_event in sim_events:
                try:
                    ui_event_q.put(StationEvent(
                        source="ftb_game",
                        type=sim_event.category,
                        ts=sim_event.ts,
                        severity=sim_event.severity,
                        priority=0,  # irrelevant for UI-only
                        payload={
                            **sim_event.data,
                            "_ftb": True,
                            "_ui_only": True,
                            "_event_id": sim_event.event_id,
                        },
                    ))
                    
                    # Also route audio events to event_q for audio engine
                    if sim_event.event_type == "audio" and event_q:
                        event_q.put(StationEvent(
                            source="ftb",
                            type=sim_event.category,
                            ts=sim_event.ts,
                            severity=sim_event.severity,
                            priority=sim_event.priority,
                            payload=sim_event.data,
                        ))
                except Exception as e:
                    self.log("ftb", f"UI StationEvent emit error: {e}")

        # ------------------------------------------------------------------
        # 2. Emit narrative beats via FTB meta plugin (ASYNC, non-blocking)
        # ------------------------------------------------------------------
        if skip_narration:
            self.log("ftb", f"Skipping narration for {len(sim_events)} UI command events")
            return
            
        ACTIVE_META_PLUGIN = self.runtime.get("ACTIVE_META_PLUGIN")
        if not ACTIVE_META_PLUGIN:
            self.log("ftb", "No ACTIVE_META_PLUGIN found in runtime")
            return

        if not hasattr(ACTIVE_META_PLUGIN, "ftb_emit_segments"):
            self.log("ftb", f"Meta plugin {type(ACTIVE_META_PLUGIN).__name__} missing ftb_emit_segments method")
            return
        
        # Snapshot sim state NOW (while holding lock)
        with self.state_lock:
            state_snapshot = self.state
        
        # Launch narration generation in background thread
        # This prevents LLM timeouts from freezing the simulation
        self.log("ftb", f"Launching async narration for {len(sim_events)} events")
        
        narration_thread = threading.Thread(
            target=self._async_emit_narration,
            args=(sim_events, state_snapshot, ACTIVE_META_PLUGIN),
            daemon=True,
            name="FTB-Narration"
        )
        narration_thread.start()
        
        self.log("ftb", "Narration thread launched, simulation continues")
    
    def _async_emit_narration(self, sim_events: List[SimEvent], state_snapshot: Any, meta_plugin: Any) -> None:
        """
        Background thread worker for narration generation.
        Isolated from simulation flow to prevent LLM timeouts from blocking.
        """
        conn = None
        try:
            self.log("ftb", f"[ASYNC] Narration thread started for {len(sim_events)} events")
            
            import bookmark
            conn = bookmark.db_connect()
            self.log("ftb", "[ASYNC] Database connection established")

            # Call meta plugin to generate beats
            self.log("ftb", "[ASYNC] Calling meta plugin ftb_emit_segments...")
            meta_plugin.ftb_emit_segments(
                sim_events,
                state_snapshot,
                conn
            )
            self.log("ftb", "[ASYNC] Meta plugin ftb_emit_segments completed successfully")

        except Exception as e:
            self.log("ftb", f"[ASYNC] Narrative beat emission error: {e}")
            import traceback
            self.log("ftb", f"[ASYNC] {traceback.format_exc()}")
        finally:
            if conn:
                try:
                    conn.close()
                    self.log("ftb", "[ASYNC] Database connection closed")
                except Exception as e:
                    self.log("ftb", f"[ASYNC] Error closing database connection: {e}")

    def _refresh_widget(self, clear_stats_cache: bool = False) -> None:
        """Send widget update to UI
        
        Args:
            clear_stats_cache: If True, clears racing stats cache to force full refresh
        """
        _dbg(f"[FTB CONTROLLER] 🔄 _refresh_widget ENTRY (clear_stats_cache={clear_stats_cache})")
        ui_q = self.runtime.get("ui_q")
        _dbg(f"[FTB CONTROLLER] 🔄 ui_q: {ui_q is not None}, state: {self.state is not None}")
        if not ui_q or not self.state:
            _dbg(f"[FTB CONTROLLER] 🔄 Skipping refresh - missing ui_q or state")
            return
        
        # Send command to clear stats cache if requested
        if clear_stats_cache:
            try:
                ui_cmd_q = self.runtime.get("ui_cmd_q")
                if ui_cmd_q:
                    ui_cmd_q.put(("ftb_clear_stats_cache", {}))
                    _dbg(f"[FTB CONTROLLER] 🗑️ Sent clear stats cache command to UI")
            except Exception as e:
                _dbg(f"[FTB CONTROLLER] ⚠️ Failed to send clear stats cache command: {e}")
        
        try:
            _dbg(f"[FTB CONTROLLER] 🔄 Acquiring state lock for widget refresh...")
            with self.state_lock:
                _dbg(f"[FTB CONTROLLER] 🔄 Building update data for tick {self.state.tick}...")
                update_data = {
                    "tick": self.state.tick,
                    "date_str": self.state.current_date_str(),
                    "phase": self.state.phase,
                    "time_mode": self.state.time_mode,
                    "control_mode": self.state.control_mode,
                    "player_focus": self.state.player_focus,
                }
                _dbg(f"[FTB CONTROLLER] 🔄 Core update data: {update_data}")
                
                if self.state.player_team:
                    _dbg(f"[FTB CONTROLLER] 🔄 Adding player team data: {self.state.player_team.name}")
                    update_data["team_name"] = self.state.player_team.name
                    update_data["league_name"] = "Unknown League"
                    # Find league of player team
                    _dbg(f"[FTB CONTROLLER] 🔄 Searching {len(self.state.leagues)} leagues for player team...")
                    for lg in self.state.leagues.values():
                        if self.state.player_team in lg.teams:
                            update_data["league_name"] = lg.name
                            _dbg(f"[FTB CONTROLLER] 🔄 Found player team in league: {lg.name}")
                            break
                    else:
                        _dbg(f"[FTB CONTROLLER] ⚠️ Player team not found in any league!")
                            
                    update_data["budget"] = self.state.player_team.budget.cash
                    _dbg(f"[FTB CONTROLLER] 🔄 Player team budget: ${self.state.player_team.budget.cash:,.0f}")
                else:
                    _dbg(f"[FTB CONTROLLER] ⚠️ No player team available!")
            
            _dbg(f"[FTB CONTROLLER] 🔄 Sending widget update to ui_q: {update_data}")
            ui_q.put(("widget_update", {
                "widget_key": "ftb_game",
                "data": update_data
            }))
            _dbg(f"[FTB CONTROLLER] ✅ Widget update sent to ui_q")
        
        except Exception as e:
            _dbg(f"[FTB CONTROLLER] ❌ Widget refresh error: {e}")
            import traceback
            _dbg(f"[FTB CONTROLLER] ❌ Widget refresh traceback: {traceback.format_exc()}")
            self.log("ftb", f"Widget refresh error: {e}")
    
    def _classify_budget_status(self, cash: float, budget_limit: float) -> str:
        """Classify budget status for narrator"""
        if cash < 0:
            return "critical"
        ratio = cash / max(budget_limit, 1.0)
        if ratio < 0.2:
            return "strained"
        return "healthy"
    
    def _classify_morale(self, morale: float) -> str:
        """Classify morale level for narrator"""
        if morale < 40:
            return "low"
        elif morale > 70:
            return "high"
        return "stable"
    
    def _get_recent_trend(self) -> str:
        """Get recent performance trend for narrator"""
        if not self.state or not self.state.player_team:
            return "flat"
        
        # Would analyze last 3-5 races for trend
        # Simplified for now
        return "flat"


# ====================================================
# SECTION 6.5: Narrator Settings Widget
# ============================================================

if ctk is not None:
    class NarratorSettingsWidget(ctk.CTkFrame):
        """Widget for controlling narrator frequency and behavior"""
        
        def __init__(self, parent, runtime_stub):
            super().__init__(parent, fg_color=FTBTheme.BACKGROUND)
            self.runtime = runtime_stub
            self.cfg = runtime_stub.get("cfg") or {}
            
            # Get current narrator settings
            narrator_cfg = self.cfg.get("ftb", {}).get("narrator", {})
            current_min = narrator_cfg.get("cadence_seconds", [2, 5])[0]
            current_max = narrator_cfg.get("cadence_seconds", [2, 5])[1]
            
            # Title
            title = ctk.CTkLabel(
                self,
                text="🎙️ Narrator Controls",
                font=("Arial", 16, "bold"),
                text_color=FTBTheme.ACCENT
            )
            title.pack(pady=(15, 10))
            
            # Instructions
            info = ctk.CTkLabel(
                self,
                text="Adjust how frequently Jarvis speaks",
                font=("Arial", 11),
                text_color=FTBTheme.TEXT_MUTED
            )
            info.pack(pady=(0, 15))
            
            # Min interval slider
            min_frame = ctk.CTkFrame(self, fg_color=FTBTheme.CARD, corner_radius=8)
            min_frame.pack(fill=tk.X, padx=15, pady=5)
            
            self.min_var = tk.IntVar(value=current_min)
            self.min_label = ctk.CTkLabel(
                min_frame,
                text=f"Min: {current_min}s",
                font=("Arial", 12),
                text_color=FTBTheme.TEXT
            )
            self.min_label.pack(side=tk.RIGHT, padx=10)
            
            def update_min(val):
                v = int(float(val))
                self.min_var.set(v)
                self.min_label.configure(text=f"Min: {v}s")
                self.save_settings()
            
            min_slider = ctk.CTkSlider(
                min_frame,
                from_=1,
                to=30,
                number_of_steps=29,
                command=update_min,
                fg_color=FTBTheme.SURFACE,
                progress_color=FTBTheme.ACCENT,
                button_color=FTBTheme.ACCENT
            )
            min_slider.set(current_min)
            min_slider.pack(side=tk.LEFT, fill=tk.X, expand=True, padx=10, pady=10)
            
            # Max interval slider
            max_frame = ctk.CTkFrame(self, fg_color=FTBTheme.CARD, corner_radius=8)
            max_frame.pack(fill=tk.X, padx=15, pady=5)
            
            self.max_var = tk.IntVar(value=current_max)
            self.max_label = ctk.CTkLabel(
                max_frame,
                text=f"Max: {current_max}s",
                font=("Arial", 12),
                text_color=FTBTheme.TEXT
            )
            self.max_label.pack(side=tk.RIGHT, padx=10)
            
            def update_max(val):
                v = int(float(val))
                self.max_var.set(v)
                self.max_label.configure(text=f"Max: {v}s")
                self.save_settings()
            
            max_slider = ctk.CTkSlider(
                max_frame,
                from_=2,
                to=60,
                number_of_steps=58,
                command=update_max,
                fg_color=FTBTheme.SURFACE,
                progress_color=FTBTheme.ACCENT,
                button_color=FTBTheme.ACCENT
            )
            max_slider.set(current_max)
            max_slider.pack(side=tk.LEFT, fill=tk.X, expand=True, padx=10, pady=10)
            
            # Help text
            help_text = ctk.CTkLabel(
                self,
                text="Lower = More frequent | Higher = More quiet",
                font=("Arial", 10),
                text_color=FTBTheme.TEXT_MUTED
            )
            help_text.pack(pady=(15, 10))
        
        def save_settings(self):
            """Save narrator settings to config and update running narrator"""
            min_val = self.min_var.get()
            max_val = self.max_var.get()
            
            # Ensure min < max
            if min_val >= max_val:
                max_val = min_val + 1
                self.max_var.set(max_val)
                self.max_label.configure(text=f"Max: {max_val}s")
            
            # Update config
            if "ftb" not in self.cfg:
                self.cfg["ftb"] = {}
            if "narrator" not in self.cfg["ftb"]:
                self.cfg["ftb"]["narrator"] = {}
            
            self.cfg["ftb"]["narrator"]["cadence_seconds"] = [min_val, max_val]
            
            # Update running narrator if it exists
            try:
                meta_plugin = self.runtime.get("ACTIVE_META_PLUGIN")
                if meta_plugin and hasattr(meta_plugin, "narrator") and meta_plugin.narrator:
                    narrator = meta_plugin.narrator
                    narrator.cadence_range = [min_val, max_val]
                    _dbg(f"[Narrator Settings] Updated cadence to {min_val}-{max_val}s")
            except Exception as e:
                _dbg(f"[Narrator Settings] Error updating narrator: {e}")
else:
    # Dummy class for headless mode
    class NarratorSettingsWidget:
        def __init__(self, parent, runtime_stub):
            pass


# ============================================================
# WIDGET REGISTRATION
# ============================================================

def register_widgets(registry, runtime_stub):
    """Register FTB game widgets with the runtime"""
    
    # Initialize FTB command queue and controller
    if "ftb_cmd_q" not in runtime_stub:
        runtime_stub["ftb_cmd_q"] = queue.Queue()
        _dbg("[FTB Game] Created ftb_cmd_q")
    
    # Initialize dedicated FTB UI queue (separate from main ui_q which bookmark.py consumes)
    if "ftb_ui_q" not in runtime_stub:
        runtime_stub["ftb_ui_q"] = queue.Queue()
        _dbg("[FTB Game] Created ftb_ui_q (dedicated FTB UI queue)")
    
    if "ftb_controller" not in runtime_stub:
        # Initialize controller with runtime and memory dict
        mem = {}  # Controller manages its own memory/state
        controller = FTBController(runtime_stub, mem)
        runtime_stub["ftb_controller"] = controller
        _dbg("[FTB Game] Created ftb_controller")
        
        # Start the controller thread to process commands
        controller.start()
        _dbg("[FTB Game] Started ftb_controller thread")
    
    # Start web server if not already running
    if "ftb_web_server_started" not in runtime_stub:
        try:
            import plugins.ftb_web_server as web_server_mod
            import threading
            
            # Get stop event from runtime
            stop_event = runtime_stub.get('stop_event', threading.Event())
            
            # Start web server in daemon thread
            web_thread = threading.Thread(
                target=web_server_mod.start_web_server,
                args=(stop_event, runtime_stub),
                daemon=True
            )
            web_thread.start()
            runtime_stub["ftb_web_server_started"] = True
            _dbg("[FTB Game] Started web server on port 7555")
        except Exception as e:
            _dbg(f"[FTB Game] Failed to start web server: {e}")

    # Start HTTP-only remote server (no WebSocket, works over Tailscale)
    if "ftb_remote_started" not in runtime_stub:
        try:
            import plugins.ftb_remote as remote_mod
            import threading

            stop_event = runtime_stub.get('stop_event', threading.Event())
            remote_thread = threading.Thread(
                target=remote_mod.start_remote_server,
                args=(stop_event, runtime_stub),
                daemon=True
            )
            remote_thread.start()
            runtime_stub["ftb_remote_started"] = True
            _dbg("[FTB Game] Started HTTP remote on port 7580 (no WebSocket)")
        except Exception as e:
            _dbg(f"[FTB Game] Failed to start remote server: {e}")

    # Main game widget
    def ftb_widget_factory(parent_frame):
        """Factory function to create FTB game widget instance"""
        widget = FTBWidget(parent_frame, runtime_stub) if ctk else None
        return widget
    
    registry.register("ftb_game", ftb_widget_factory)
    
    # Narrator settings widget
    def narrator_settings_factory(parent_frame):
        """Factory function to create narrator settings widget"""
        widget = NarratorSettingsWidget(parent_frame, runtime_stub)
        return widget
    
    registry.register("ftb_narrator_settings", narrator_settings_factory)
    
    _dbg("[FTB Game] Widgets registered: ftb_game, ftb_narrator_settings")
